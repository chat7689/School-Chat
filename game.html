<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Racers Online</title>
    <link rel="icon" type="image/png" id="favicon">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #2c2c2c;
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        canvas {
            border: 5px solid #4facfe;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(79, 172, 254, 0.4);
            background: #87CEEB;
        }

        .screen {
            display: none;
            position: absolute;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            backdrop-filter: blur(10px);
            color: white;
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #4facfe;
            text-align: center;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .screen.active {
            display: block;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #FFC107;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }

        h2 {
            font-size: 32px;
            margin: 20px 0;
            color: #4facfe;
        }

        button {
            padding: 15px 30px;
            font-size: 18px;
            margin: 10px;
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.3);
            font-weight: bold;
        }

        button:hover {
            background: linear-gradient(135deg, #6fd0ff, #20f5ff);
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.5);
        }

        button.secondary {
            background: linear-gradient(135deg, #666, #888);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        button.danger {
            background: linear-gradient(135deg, rgba(255,0,0,0.7), rgba(255,50,50,0.7));
            box-shadow: 0 4px 15px rgba(255, 0, 0, 0.3);
        }

        button.success {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        input, select {
            padding: 12px;
            font-size: 16px;
            margin: 10px;
            border-radius: 12px;
            border: 2px solid #4facfe;
            background: rgba(255,255,255,0.9);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #00f2fe;
            box-shadow: 0 4px 20px rgba(79, 172, 254, 0.4);
        }

        #creditPanel {
            position: absolute;
            top: 100px;
            left: 20px;
            width: 280px;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            border: 3px solid #4facfe;
            border-radius: 15px;
            padding: 25px;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .cosmetic-item {
            background: rgba(0,0,0,0.4);
            padding: 15px;
            margin: 10px;
            border-radius: 12px;
            display: inline-block;
            min-width: 200px;
            border: 2px solid rgba(79, 172, 254, 0.3);
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .cosmetic-item:hover {
            border-color: #4facfe;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.4);
        }

        .cosmetic-item.owned {
            border: 2px solid #4facfe;
            background: rgba(79, 172, 254, 0.2);
        }

        .cosmetic-item.equipped {
            background: rgba(79, 172, 254, 0.3);
            border: 2px solid #FFC107;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #4facfe;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            display: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }

        #timer {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            z-index: 50;
            display: none;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            padding: 20px 40px;
            border-radius: 15px;
            border: 3px solid #4facfe;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            font-family: 'Courier New', monospace;
        }

        .party-member {
            background: rgba(0,0,0,0.4);
            padding: 12px;
            margin: 8px;
            border-radius: 12px;
            border: 2px solid rgba(79, 172, 254, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s;
        }

        .party-member:hover {
            border-color: #4facfe;
            transform: translateY(-2px);
        }

        .party-member.ready {
            background: rgba(0,255,0,0.2);
            border: 2px solid #0f0;
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.3);
        }

        .invitation {
            background: rgba(255,215,0,0.2);
            padding: 18px;
            margin: 10px;
            border-radius: 15px;
            border: 2px solid #FFC107;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
        }

        .platform-button {
            position: absolute;
            background: rgba(79, 172, 254, 0.3);
            border: 3px solid #4facfe;
            color: #4facfe;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
        }

        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            color: white;
            text-shadow: 5px 5px 10px rgba(0,0,0,0.9);
            z-index: 200;
            display: none;
            font-weight: bold;
        }

        .player-list {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
        }

        .shop-category {
            margin: 20px 0;
        }

        .cosmetics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .levels-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .level-card {
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            border: 2px solid #4facfe;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .level-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(79, 172, 254, 0.5);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
        }

        #menuCanvas {
            display: block;
        }

        .menu-hud {
            position: absolute;
            top: 20px;
            text-align: center;
            width: 100%;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            z-index: 10;
            pointer-events: none;
        }

        .menu-title {
            font-size: 64px;
            color: #FFC107;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .scroll-container {
            max-height: 60vh;
            overflow-y: auto;
            padding: 20px;
        }

        #raceResults {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 20px;
            z-index: 200;
            display: none;
            min-width: 400px;
        }

        .result-entry {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        .result-entry.winner {
            background: rgba(255,215,0,0.3);
            border: 2px solid gold;
        }

        #racePositions {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            z-index: 50;
            display: none;
        }
    </style>
</head>
<body>
    <!-- Main Menu Canvas (Interactive Platformer) -->
    <canvas id="menuCanvas" width="1200" height="800"></canvas>
    <div class="menu-hud" id="menuHUD" style="display: none;">
    </div>

    <!-- Left Side Credit Panel -->
    <div id="creditPanel" style="display: none;"></div>

    <!-- Practice Mode Canvas -->
    <canvas id="practiceCanvas" width="1200" height="800" style="display: none;"></canvas>
    <div id="hud"></div>
    <button id="practiceBackBtn" onclick="exitPracticeMode()" style="position: absolute; top: 20px; right: 20px; z-index: 100; display: none; padding: 10px 20px; background: rgba(255,0,0,0.7); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">Back to Menu</button>

    <!-- Race Canvas -->
    <canvas id="raceCanvas" width="1200" height="800" style="display: none;"></canvas>
    <div id="timer"></div>
    <div id="racePositions"></div>
    <div id="countdown"></div>

    <!-- Party Screen -->
    <div id="partyScreen" class="screen">
        <h1>Party</h1>
        <div id="partyInfo"></div>
        <div id="partyMembers" class="player-list"></div>
        <div id="partyInvitations"></div>
        <div style="margin-top: 20px;">
            <input type="text" id="inviteUsername" placeholder="Enter username to invite">
            <button onclick="sendInvite()">Send Invite</button>
        </div>
        <div id="partyControls" style="margin-top: 20px;"></div>
        <button onclick="leaveParty()" class="secondary">Leave Party</button>
        <button onclick="backToMainMenu()" class="secondary">Back to Menu</button>
    </div>

    <!-- Join Party Screen -->
    <div id="joinPartyScreen" class="screen">
        <h1>Join Party</h1>
        <input type="text" id="partyIdInput" placeholder="Enter Party ID">
        <button onclick="joinPartyById()">Join Party</button>
        <button onclick="backToMainMenu()" class="secondary">Back</button>
    </div>

    <!-- Lobby Screen -->
    <div id="lobbyScreen" class="screen">
        <h1>Race Lobby</h1>
        <div id="lobbyInfo"></div>
        <div id="lobbyPlayers" class="player-list"></div>
        <div id="lobbyControls"></div>
        <button onclick="leaveLobby()" class="secondary">Leave Lobby</button>
    </div>

    <!-- Cosmetic Shop Screen -->
    <div id="shopScreen" class="screen">
        <h1>Cosmetic Shop</h1>
        <div id="shopCredits" style="font-size: 24px; color: #FFC107; margin-bottom: 20px;"></div>
        <div class="scroll-container">
            <div id="shopContent"></div>
        </div>
        <button onclick="backToMainMenu()">Back to Menu</button>
    </div>

    <!-- Practice Levels Screen -->
    <div id="practiceLevelsScreen" class="screen">
        <h1>Practice Levels</h1>
        <div class="scroll-container">
            <div id="practiceLevelsContent"></div>
        </div>
        <button onclick="backToMainMenu()">Back to Menu</button>
    </div>

    <!-- Stats Screen -->
    <div id="statsScreen" class="screen">
        <h1>Your Stats</h1>
        <div id="statsContent" style="font-size: 20px;"></div>
        <button onclick="backToMainMenu()">Back to Menu</button>
    </div>

    <!-- Base Screen -->
    <div id="baseScreen" class="screen">
        <h1>Your Base</h1>
        <div id="baseCredits" style="font-size: 24px; color: #FFC107; margin-bottom: 20px;"></div>
        <canvas id="baseCanvas" width="800" height="600" style="border: 3px solid #4facfe; border-radius: 10px;"></canvas>
        <div style="margin-top: 20px;">
            <p>Click on the grid to place 40x40px blocks (costs 1 credit each)</p>
            <p>Right-click to remove blocks (refunds 1 credit)</p>
        </div>
        <button onclick="backToMainMenu()">Back to Menu</button>
    </div>

    <!-- Leaderboard Screen -->
    <div id="leaderboardScreen" class="screen">
        <div class="scroll-container" style="padding-top: 20px;">
            <div id="leaderboardContent" style="max-width: 1000px; margin: 0 auto;"></div>
        </div>
        <button onclick="backToMainMenu()" style="margin-top: 20px;">Back to Menu</button>
    </div>

    <!-- Race Results -->
    <div id="raceResults">
        <h2>Race Complete!</h2>
        <div id="resultsContent"></div>
        <button onclick="returnToParty()" class="success">Return to Party</button>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBLkFMipRS631fDNr8uwgozmxXBnqLd5_o",
            authDomain: "base-control-b391e.firebaseapp.com",
            databaseURL: "https://base-control-b391e-default-rtdb.firebaseio.com",
            projectId: "base-control-b391e",
            storageBucket: "base-control-b391e.firebasestorage.app",
            messagingSenderId: "116375376675",
            appId: "1:116375376675:web:cdc8688222c7c35accf296",
            measurementId: "G-JY7P6D49HM"
        };

        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const database = firebase.database();

        // Create favicon
        const faviconCanvas = document.createElement('canvas');
        faviconCanvas.width = 32;
        faviconCanvas.height = 32;
        const faviconCtx = faviconCanvas.getContext('2d');
        faviconCtx.fillStyle = '#FF8C42';
        faviconCtx.fillRect(6, 6, 20, 20);
        faviconCtx.strokeStyle = '#333';
        faviconCtx.lineWidth = 2;
        faviconCtx.strokeRect(6, 6, 20, 20);
        document.getElementById('favicon').href = faviconCanvas.toDataURL('image/png');

        // Global variables
        let currentUser = null;
        let currentUsername = '';
        let userCredits = 0; // On-hand credits (can be spent)
        let secureCredits = 0; // Secure credits (stored at base, main credits display)
        let userCosmetics = { skins: ['default_orange'], trails: ['none'], hats: ['none'], effects: ['none'] };
        let equippedCosmetics = { skin: 'default_orange', trail: 'none', hat: 'none', effect: 'none' };
        let userStats = { racesWon: 0, racesPlayed: 0, totalCreditsEarned: 0 };

        let currentParty = null;
        let currentPartyId = null;
        let currentLobby = null;
        let currentLobbyId = null;

        // Jump state tracking
        let menuIsJumping = false;
        let practiceIsJumping = false;
        let raceIsJumping = false;

        // Game constants
        const GRAVITY = 0.042;
        const MOVE_SPEED = 0.28;
        const GROUND_MAX_SPEED = 3.5;
        const AIR_MAX_SPEED = 4.375; // 1.25x ground speed
        const AIR_RESISTANCE = 0.88;
        const GROUND_FRICTION = 0.94;
        const GROUND_ACCELERATION = 0.15; // Gradual acceleration when grounded
        const JUMP_POWER = 3.70;
        const FAST_FALL_MULTIPLIER = 2.0;

        // Game feel constants
        const COYOTE_TIME = 6; // Frames you can still jump after leaving platform
        const JUMP_BUFFER_TIME = 8; // Frames to remember jump input before landing
        const ACCELERATION = 0.5; // Smoother acceleration
        const DECELERATION = 0.8; // Smoother deceleration

        // Particle system
        class Particle {
            constructor(x, y, vx, vy, color, life) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
            }

            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.vy += GRAVITY * deltaTime * 0.5;
                this.life -= deltaTime;
            }

            draw(ctx, cameraX, cameraY) {
                const alpha = this.life / this.maxLife;
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                ctx.fillRect(screenX, screenY, 4, 4);
            }
        }

        let particles = [];

        function spawnParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 2 + 1;
                particles.push(new Particle(
                    x,
                    y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed - 1,
                    color,
                    30 + Math.random() * 20
                ));
            }
        }

        function updateAndDrawParticles(ctx, cameraX, cameraY, deltaTime) {
            // Update and draw all particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(deltaTime);
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                } else {
                    particles[i].draw(ctx, cameraX, cameraY);
                }
            }
        }

        // Cosmetics catalog
        const cosmeticsCatalog = {
            skins: [
                { id: 'default_orange', name: 'Default Orange', price: 0, color: '#FF8C42' },
                { id: 'red_racer', name: 'Red Racer', price: 50, color: '#FF0000' },
                { id: 'blue_blur', name: 'Blue Blur', price: 50, color: '#0066FF' },
                { id: 'green_machine', name: 'Green Machine', price: 100, color: '#00FF00' },
                { id: 'purple_pro', name: 'Purple Pro', price: 100, color: '#9900FF' },
                { id: 'golden_champion', name: 'Golden Champion', price: 500, color: '#FFD700' }
            ],
            trails: [
                { id: 'none', name: 'None', price: 0 },
                { id: 'rainbow', name: 'Rainbow Trail', price: 100 },
                { id: 'fire', name: 'Fire Trail', price: 150 },
                { id: 'ice', name: 'Ice Trail', price: 150 },
                { id: 'star', name: 'Star Trail', price: 200 }
            ],
            hats: [
                { id: 'none', name: 'None', price: 0 },
                { id: 'crown', name: 'Crown', price: 200 },
                { id: 'propeller', name: 'Propeller', price: 150 },
                { id: 'halo', name: 'Halo', price: 300 }
            ],
            effects: [
                { id: 'none', name: 'None', price: 0 },
                { id: 'sparkles', name: 'Sparkles', price: 100 },
                { id: 'glow', name: 'Glow', price: 150 },
                { id: 'shadow_clone', name: 'Shadow Clone', price: 300 }
            ]
        };

        // Map definitions (preserved from original)
        const maps = [
            {
                id: 'simple_map',
                name: 'Simple Map',
                difficulty: 'Easy',
                platforms: [
                    { x: -40, y: -280, width: 40, height: 320 },
                    { x: 0, y: -280, width: 280, height: 40 },
                    { x: 280, y: -280, width: 40, height: 320 },
                    { x: 0, y: 0, width: 280, height: 40 }
                ],
                hazards: [
                    { x: 120, y: -120, width: 40, height: 120 }
                ],
                growers: [],
                shrinkers: [],
                defaultSizeBlocks: [],
                start: { x: 0, y: -40, width: 40, height: 40 },
                finish: { x: 240, y: -40, width: 40, height: 40 }
            },
            {
                id: 'custom_level',
                name: 'Original Map',
                difficulty: 'Medium',
                platforms: [
                    { x: 0, y: 400, width: 40, height: 200 },
                    { x: 40, y: 560, width: 520, height: 40 },
                    { x: 240, y: 440, width: 80, height: 40 },
                    { x: 320, y: 320, width: 80, height: 40 },
                    { x: 240, y: 200, width: 80, height: 40 },
                    { x: 320, y: 80, width: 80, height: 40 },
                    { x: 160, y: -80, width: 360, height: 40 },
                    { x: 480, y: -40, width: 40, height: 480 },
                    { x: -240, y: 160, width: 400, height: 40 },
                    { x: -80, y: 40, width: 40, height: 160 },
                    { x: -160, y: -80, width: 320, height: 40 },
                    { x: -200, y: -80, width: 40, height: 200 },
                    { x: -320, y: 80, width: 120, height: 40 },
                    { x: -320, y: 120, width: 40, height: 240 },
                    { x: -240, y: 480, width: 40, height: 40 },
                    { x: 0, y: 720, width: 40, height: 40 },
                    { x: 160, y: 720, width: 40, height: 40 },
                    { x: 560, y: 320, width: 40, height: 280 },
                    { x: 160, y: 40, width: 80, height: 40 },
                    { x: 440, y: 680, width: 40, height: 40 },
                    { x: 600, y: 520, width: 240, height: 40 },
                    { x: 480, y: 640, width: 440, height: 40 },
                    { x: 920, y: 320, width: 40, height: 360 },
                    { x: 600, y: 320, width: 320, height: 40 },
                    { x: 320, y: 760, width: 120, height: 40 }
                ],
                hazards: [
                    { x: 200, y: 80, width: 40, height: 80 },
                    { x: 0, y: 360, width: 40, height: 40 },
                    { x: -520, y: 800, width: 1560, height: 80 }
                ],
                growers: [],
                shrinkers: [],
                defaultSizeBlocks: [],
                start: { x: 80, y: 480 },
                finish: { x: 700, y: 470, width: 100, height: 50 }
            },
            {
                id: 'hard_level',
                name: 'Hard Level',
                difficulty: 'Hard',
                platforms: [
                    { x: 40, y: -200, width: 240, height: 30 },
                    { x: 40, y: -170, width: 80, height: 30 },
                    { x: 200, y: -170, width: 80, height: 30 },
                    { x: -280, y: -410, width: 60, height: 90 },
                    { x: -280, y: -260, width: 60, height: 20 },
                    { x: -280, y: -120, width: 40, height: 40 },
                    { x: -200, y: -40, width: 40, height: 40 },
                    { x: 560, y: -400, width: 240, height: 80 },
                    { x: 400, y: -640, width: 160, height: 80 },
                    { x: 560, y: -800, width: 80, height: 80 },
                    { x: 240, y: -1040, width: 160, height: 80 },
                    { x: -80, y: 0, width: 115, height: 40 },
                    { x: 340, y: 20, width: 180, height: 20 },
                    { x: 360, y: 0, width: 160, height: 20 },
                    { x: 40, y: 100, width: 100, height: 20 },
                    { x: 160, y: 140, width: 80, height: 20 },
                    { x: 260, y: 80, width: 60, height: 20 },
                    { x: 320, y: -80, width: 20, height: 80 },
                    { x: 520, y: -120, width: 160, height: 40 },
                    { x: 640, y: -80, width: 40, height: 120 },
                    { x: 520, y: 0, width: 120, height: 40 }
                ],
                hazards: [
                    { x: 40, y: -320, width: 80, height: 120 },
                    { x: -80, y: -200, width: 40, height: 200 },
                    { x: 240, y: -1120, width: 80, height: 80 },
                    { x: -360, y: 280, width: 1280, height: 40 },
                    { x: 920, y: -1280, width: 40, height: 1600 },
                    { x: -360, y: -1280, width: 1280, height: 40 },
                    { x: -400, y: -1280, width: 40, height: 1600 }
                ],
                growers: [
                    { x: 80, y: -640, width: 80, height: 80 }
                ],
                shrinkers: [
                    { x: 80, y: -1200, width: 80, height: 80 }
                ],
                defaultSizeBlocks: [
                    { x: 520, y: -80, width: 40, height: 80 }
                ],
                start: { x: 0, y: -80, width: 40, height: 40 },
                finish: { x: 600, y: -80, width: 40, height: 80 }
            }
        ];

        // Player class for rendering
        class Player {
            constructor(x, y, cosmetics) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.velocityX = 0;
                this.velocityY = 0;
                this.cosmetics = cosmetics || { skin: 'default_orange', trail: 'none', hat: 'none', effect: 'none' };
                this.trail = [];
                this.currentSize = 40;

                // Game feel variables
                this.coyoteTimer = 0;
                this.jumpBufferTimer = 0;
                this.wasGrounded = false;
                this.squashStretch = 1; // For squash and stretch animation
            }

            getSkinColor() {
                const skin = cosmeticsCatalog.skins.find(s => s.id === this.cosmetics.skin);
                return skin ? skin.color : '#FF8C42';
            }

            updateTrail() {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 10) {
                    this.trail.shift();
                }
            }

            draw(ctx, cameraX, cameraY, showName, name) {
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;

                // Draw trail
                if (this.cosmetics.trail !== 'none' && this.trail.length > 1) {
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const alpha = i / this.trail.length;
                        const trailX = this.trail[i].x - cameraX;
                        const trailY = this.trail[i].y - cameraY;

                        ctx.globalAlpha = alpha * 0.5;

                        if (this.cosmetics.trail === 'rainbow') {
                            ctx.fillStyle = `hsl(${(i * 36) % 360}, 100%, 50%)`;
                        } else if (this.cosmetics.trail === 'fire') {
                            ctx.fillStyle = i % 2 === 0 ? '#FF6600' : '#FF0000';
                        } else if (this.cosmetics.trail === 'ice') {
                            ctx.fillStyle = i % 2 === 0 ? '#00FFFF' : '#FFFFFF';
                        } else if (this.cosmetics.trail === 'star') {
                            ctx.fillStyle = '#FFFF00';
                        }

                        ctx.fillRect(trailX, trailY, this.width, this.height);
                    }
                    ctx.restore();
                }

                // Draw effect (behind player)
                if (this.cosmetics.effect === 'glow') {
                    ctx.save();
                    ctx.shadowColor = this.getSkinColor();
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = this.getSkinColor();
                    ctx.fillRect(screenX, screenY, this.width, this.height);
                    ctx.restore();
                } else if (this.cosmetics.effect === 'shadow_clone') {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = this.getSkinColor();
                    ctx.fillRect(screenX - 10, screenY + 5, this.width, this.height);
                    ctx.restore();
                }

                // Draw player with squash and stretch
                ctx.save();

                // Apply squash/stretch transformation
                const squash = this.squashStretch || 1;
                const stretchWidth = this.width * squash;
                const stretchHeight = this.height / squash;
                const offsetX = (this.width - stretchWidth) / 2;
                const offsetY = this.height - stretchHeight;

                ctx.fillStyle = this.getSkinColor();
                ctx.fillRect(screenX + offsetX, screenY + offsetY, stretchWidth, stretchHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX + offsetX, screenY + offsetY, stretchWidth, stretchHeight);

                ctx.restore();

                // Draw hat
                if (this.cosmetics.hat === 'crown') {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(screenX + this.width / 2, screenY - 15);
                    ctx.lineTo(screenX + 5, screenY - 5);
                    ctx.lineTo(screenX + this.width - 5, screenY - 5);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.cosmetics.hat === 'propeller') {
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(screenX + 10, screenY - 10);
                    ctx.lineTo(screenX + this.width - 10, screenY - 10);
                    ctx.stroke();
                } else if (this.cosmetics.hat === 'halo') {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, screenY - 10, 15, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw sparkles effect
                if (this.cosmetics.effect === 'sparkles') {
                    ctx.fillStyle = '#FFFF00';
                    for (let i = 0; i < 5; i++) {
                        const angle = (Date.now() / 100 + i * 72) % 360;
                        const rad = angle * Math.PI / 180;
                        const sparkX = screenX + this.width / 2 + Math.cos(rad) * 30;
                        const sparkY = screenY + this.height / 2 + Math.sin(rad) * 30;
                        ctx.fillRect(sparkX - 2, sparkY - 2, 4, 4);
                    }
                }

                // Draw name
                if (showName && name) {
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(name, screenX + this.width / 2, screenY - 10);
                }
            }
        }

        // Initialize user data
        async function initUserData() {
            if (!currentUser) return;

            const userRef = database.ref('players/' + currentUser.uid);
            const snapshot = await userRef.once('value');
            const data = snapshot.val();

            if (data) {
                userCredits = data.credits || 0;
                secureCredits = data.secureCredits || 0;
                userCosmetics = data.cosmetics || { skins: ['default_orange'], trails: ['none'], hats: ['none'], effects: ['none'] };
                equippedCosmetics = data.equippedCosmetics || { skin: 'default_orange', trail: 'none', hat: 'none', effect: 'none' };
                userStats = data.stats || { racesWon: 0, racesPlayed: 0, totalCreditsEarned: 0 };
            } else {
                // Initialize new user
                await userRef.set({
                    username: currentUsername,
                    credits: 0,
                    secureCredits: 0,
                    cosmetics: userCosmetics,
                    equippedCosmetics: equippedCosmetics,
                    stats: userStats
                });
            }
        }

        // Update credits in Firebase
        async function updateCredits(amount, type = 'onhand') {
            if (type === 'onhand') {
                userCredits += amount;
            } else if (type === 'secure') {
                secureCredits += amount;
            }

            if (amount > 0) {
                userStats.totalCreditsEarned += amount;
            }

            await database.ref('players/' + currentUser.uid).update({
                credits: userCredits,
                secureCredits: secureCredits,
                stats: userStats
            });
        }

        async function transferCredits(amount, fromType, toType) {
            if (fromType === 'onhand' && userCredits >= amount) {
                userCredits -= amount;
                secureCredits += amount;
            } else if (fromType === 'secure' && secureCredits >= amount) {
                secureCredits -= amount;
                userCredits += amount;
            } else {
                return false; // Insufficient funds
            }

            await database.ref('players/' + currentUser.uid).update({
                credits: userCredits,
                secureCredits: secureCredits
            });
            return true;
        }

        // Main menu (interactive platformer)
        let menuPlayer = null;
        let menuKeys = {};
        let menuPlatforms = [];
        let menuCameraX = 0;
        let menuCameraY = 0;

        function initMainMenu() {
            const canvas = document.getElementById('menuCanvas');
            const ctx = canvas.getContext('2d');

            canvas.style.display = 'block';
            document.getElementById('menuHUD').style.display = 'block';

            // Create menu platforms with labels
            menuPlatforms = [
                { x: 100, y: 600, width: 200, height: 60, label: 'EARN MODE', action: 'practice' },
                { x: 350, y: 550, width: 220, height: 60, label: 'PRACTICE LEVELS', action: 'practiceLevels' },
                { x: 620, y: 500, width: 200, height: 60, label: 'CREATE PARTY', action: 'createParty' },
                { x: 870, y: 450, width: 200, height: 60, label: 'JOIN PARTY', action: 'joinParty' },
                { x: 150, y: 400, width: 200, height: 60, label: 'COSMETIC SHOP', action: 'shop' },
                { x: 400, y: 350, width: 180, height: 60, label: 'VIEW STATS', action: 'stats' },
                { x: 650, y: 300, width: 200, height: 60, label: 'LEVEL CREATOR', action: 'creator' },
                { x: 200, y: 250, width: 160, height: 60, label: 'BASE', action: 'base' },
                { x: 450, y: 200, width: 200, height: 60, label: 'LEADERBOARD', action: 'leaderboard' },
                { x: 0, y: 720, width: 1200, height: 80, label: '', action: 'none' }, // Ground
                // Left wall - 100 blocks high (4000px)
                { x: -40, y: -3280, width: 40, height: 4000, label: '', action: 'none' },
                // Right wall - 100 blocks high (4000px)
                { x: 1200, y: -3280, width: 40, height: 4000, label: '', action: 'none' }
            ];

            // Spawn player in center of screen on the ground platform
            menuPlayer = new Player(600 - 20, 720 - 40, equippedCosmetics);

            // Populate and show credit panel (after player is created)
            const skinData = cosmeticsCatalog.skins.find(s => s.id === equippedCosmetics.skin);
            const playerColor = skinData ? skinData.color : '#FF8C42';
            document.getElementById('creditPanel').innerHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="width: 80px; height: 80px; background: ${playerColor}; border: 4px solid #333; border-radius: 12px; margin: 0 auto 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);"></div>
                    <div style="font-size: 22px; font-weight: bold; color: #fff; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">${currentUsername}</div>
                </div>
                <div style="background: rgba(0,0,0,0.5); border-radius: 12px; padding: 18px; margin-bottom: 12px; border: 2px solid rgba(255, 215, 0, 0.3);">
                    <div style="color: #4facfe; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px;">Secure Credits</div>
                    <div style="font-size: 42px; font-weight: bold; color: #FFD700; text-shadow: 0 0 15px rgba(255, 215, 0, 0.6); font-family: 'Arial Black', sans-serif;">${secureCredits.toLocaleString()}</div>
                </div>
                <div style="background: rgba(0,0,0,0.5); border-radius: 12px; padding: 15px; border: 2px solid rgba(170, 170, 170, 0.2);">
                    <div style="color: #4facfe; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px;">On Hand</div>
                    <div style="font-size: 28px; font-weight: bold; color: #bbb; text-shadow: 0 0 8px rgba(187, 187, 187, 0.4);">${userCredits.toLocaleString()}</div>
                </div>
            `;
            document.getElementById('creditPanel').style.display = 'block';

            // Game loop with delta time
            let lastMenuFrameTime = performance.now();
            function menuLoop(currentTime) {
                if (canvas.style.display === 'none') return;

                // Calculate delta time (normalize to 60fps baseline)
                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastMenuFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1; // Clamp deltaTime
                lastMenuFrameTime = currentTime;

                // Update player physics
                updateMenuPlayer(deltaTime);

                // Render
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw platforms
                for (const platform of menuPlatforms) {
                    const screenX = platform.x - menuCameraX;
                    const screenY = platform.y - menuCameraY;

                    if (platform.label) {
                        // Gradient background for platform buttons
                        const gradient = ctx.createLinearGradient(screenX, screenY, screenX, screenY + platform.height);
                        gradient.addColorStop(0, 'rgba(79, 172, 254, 0.5)');
                        gradient.addColorStop(1, 'rgba(79, 172, 254, 0.2)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);

                        // Glowing border
                        ctx.shadowColor = '#4facfe';
                        ctx.shadowBlur = 15;
                        ctx.strokeStyle = '#4facfe';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(screenX, screenY, platform.width, platform.height);
                        ctx.shadowBlur = 0;

                        // Text with shadow
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = 'rgba(0,0,0,0.5)';
                        ctx.shadowBlur = 5;
                        ctx.fillText(platform.label, screenX + platform.width / 2, screenY + platform.height / 2 + 5);
                        ctx.shadowBlur = 0;
                    } else {
                        // Green platform
                        ctx.fillStyle = '#00AA00';
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);

                        // Draw 40x40 grid lines
                        ctx.strokeStyle = '#006600';
                        ctx.lineWidth = 1;
                        for (let gx = 0; gx < platform.width; gx += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX + gx, screenY);
                            ctx.lineTo(screenX + gx, screenY + platform.height);
                            ctx.stroke();
                        }
                        for (let gy = 0; gy < platform.height; gy += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY + gy);
                            ctx.lineTo(screenX + platform.width, screenY + gy);
                            ctx.stroke();
                        }
                    }
                }

                // Draw player
                menuPlayer.updateTrail();
                menuPlayer.draw(ctx, menuCameraX, menuCameraY, false);

                requestAnimationFrame(menuLoop);
            }

            menuLoop();
        }

        function updateMenuPlayer(deltaTime = 1) {
            // Check current grounded state BEFORE applying physics
            // Check if player is standing on a platform (touching from above)
            let isGrounded = false;
            let standingOnPlatform = null;
            for (const platform of menuPlatforms) {
                // Check if player is directly above platform
                const onTop = menuPlayer.y + menuPlayer.height >= platform.y &&
                              menuPlayer.y + menuPlayer.height <= platform.y + 5;
                const horizontalOverlap = menuPlayer.x + menuPlayer.width > platform.x &&
                                         menuPlayer.x < platform.x + platform.width;

                if (onTop && horizontalOverlap) {
                    isGrounded = true;
                    standingOnPlatform = platform;
                    break;
                }
            }

            // Check for platform interaction when standing on action platform
            if (standingOnPlatform && standingOnPlatform.action && standingOnPlatform.action !== 'none') {
                if (menuKeys[' ']) {
                    executePlatformAction(standingOnPlatform.action);
                }
            }

            // Apply gravity with fast fall
            if ((menuKeys['s'] || menuKeys['ArrowDown']) && !isGrounded) {
                menuPlayer.velocityY += GRAVITY * FAST_FALL_MULTIPLIER * deltaTime;
            } else {
                menuPlayer.velocityY += GRAVITY * deltaTime;
            }

            // Handle input
            if (menuKeys['a'] || menuKeys['ArrowLeft']) {
                menuPlayer.velocityX -= MOVE_SPEED * deltaTime;
            }
            if (menuKeys['d'] || menuKeys['ArrowRight']) {
                menuPlayer.velocityX += MOVE_SPEED * deltaTime;
            }

            // Jump with variable height (W or Up Arrow only, NOT space)
            if ((menuKeys['w'] || menuKeys['ArrowUp']) && isGrounded) {
                menuPlayer.velocityY = -JUMP_POWER;
                menuIsJumping = true;
            }

            // Cut jump short if button released (variable jump height)
            if (menuIsJumping && !menuKeys['w'] && !menuKeys['ArrowUp']) {
                if (menuPlayer.velocityY < 0) {
                    menuPlayer.velocityY *= 0.5;
                }
                menuIsJumping = false;
            }

            // Reset jump state when grounded
            if (isGrounded && menuPlayer.velocityY >= 0) {
                menuIsJumping = false;
            }

            // Apply friction using exponential decay
            if (isGrounded) {
                menuPlayer.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                menuPlayer.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Limit speed
            menuPlayer.velocityX = Math.max(-GROUND_MAX_SPEED, Math.min(GROUND_MAX_SPEED, menuPlayer.velocityX));

            // Update position HORIZONTALLY first, then check X collisions
            menuPlayer.x += menuPlayer.velocityX * deltaTime;

            // Check horizontal collisions
            for (const platform of menuPlatforms) {
                if (checkCollision(menuPlayer, platform)) {
                    if (menuPlayer.velocityX > 0) {
                        // Moving right, hit left side of platform
                        menuPlayer.x = platform.x - menuPlayer.width;
                    } else if (menuPlayer.velocityX < 0) {
                        // Moving left, hit right side of platform
                        menuPlayer.x = platform.x + platform.width;
                    }
                    menuPlayer.velocityX = 0;
                }
            }

            // Update position VERTICALLY, then check Y collisions
            menuPlayer.y += menuPlayer.velocityY * deltaTime;

            // Check vertical collisions
            for (const platform of menuPlatforms) {
                if (checkCollision(menuPlayer, platform)) {
                    if (menuPlayer.velocityY > 0) {
                        // Moving down, hit top of platform
                        menuPlayer.y = platform.y - menuPlayer.height;
                        menuPlayer.velocityY = 0;
                    } else if (menuPlayer.velocityY < 0) {
                        // Moving up, hit bottom of platform
                        menuPlayer.y = platform.y + platform.height;
                        menuPlayer.velocityY = 0;
                        menuIsJumping = false;
                    }
                }
            }

            // Keep player in bounds (but allow vertical movement)
            if (menuPlayer.x < 0) menuPlayer.x = 0;
            if (menuPlayer.x > 1200 - menuPlayer.width) menuPlayer.x = 1200 - menuPlayer.width;

            // Respawn if fall too far
            if (menuPlayer.y > 1500) {
                menuPlayer.x = 600 - 20;
                menuPlayer.y = 720 - 40;
                menuPlayer.velocityX = 0;
                menuPlayer.velocityY = 0;
            }

            // Keep camera fixed (do not follow player on home page)
            menuCameraX = 0;
            menuCameraY = 0;
        }

        function checkCollision(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

        function executePlatformAction(action) {
            document.getElementById('menuCanvas').style.display = 'none';
            document.getElementById('menuHUD').style.display = 'none';
            document.getElementById('creditPanel').style.display = 'none';

            switch(action) {
                case 'practice':
                    startPracticeMode();
                    break;
                case 'practiceLevels':
                    showPracticeLevels();
                    break;
                case 'createParty':
                    createParty();
                    break;
                case 'joinParty':
                    showScreen('joinPartyScreen');
                    break;
                case 'shop':
                    showShop();
                    break;
                case 'stats':
                    showStats();
                    break;
                case 'creator':
                    window.location.href = 'creator.html';
                    break;
                case 'base':
                    showBase();
                    break;
                case 'leaderboard':
                    showLeaderboard();
                    break;
            }
        }

        async function showPracticeLevels() {
            showScreen('practiceLevelsScreen');

            // Load levels from Firebase
            const levelsSnapshot = await database.ref('levels').once('value');
            const levels = levelsSnapshot.val();

            let html = '<div class="levels-grid">';

            if (levels) {
                for (const [levelId, levelData] of Object.entries(levels)) {
                    html += `<div class="level-card">
                        <div style="font-weight: bold; font-size: 18px;">${levelData.name}</div>
                        <div style="color: #aaa; margin: 5px 0;">By ${levelData.creator}</div>
                        <button onclick="playLevel('${levelId}')">Play</button>
                    </div>`;
                }
            } else {
                html += '<div style="color: #fff; font-size: 18px;">No levels available yet!</div>';
            }

            html += '</div>';
            document.getElementById('practiceLevelsContent').innerHTML = html;
        }

        async function playLevel(levelId) {
            try {
                // Load level from Firebase
                const levelSnapshot = await database.ref('levels/' + levelId).once('value');
                const levelInfo = levelSnapshot.val();

                if (!levelInfo || !levelInfo.data) {
                    alert('Error: Level data not found!');
                    return;
                }

                const levelData = levelInfo.data;

                // Hide practice levels screen
                document.getElementById('practiceLevelsScreen').classList.remove('active');

                // Show practice canvas
                const canvas = document.getElementById('practiceCanvas');
                canvas.style.display = 'block';
                document.getElementById('hud').style.display = 'block';
                document.getElementById('practiceBackBtn').style.display = 'block';

                // Initialize practice mode with level data
                practiceMode.active = true;
                practiceMode.isLevelMode = true; // Flag to indicate we're playing a level, not infinite mode
                practiceMode.levelData = levelData;
                practiceMode.player = new Player(100, -50, equippedCosmetics); // Start position

                // Load platforms from level
                practiceMode.platforms = levelData.platforms || [];

                // Load other level elements
                practiceMode.hazards = levelData.hazards || [];
                practiceMode.growers = levelData.growers || [];
                practiceMode.shrinkers = levelData.shrinkers || [];
                practiceMode.defaultSizeBlocks = levelData.defaultSizeBlocks || [];

                // Reset other properties
                practiceMode.credits = [];
                practiceMode.creditsCollected = 0;
                practiceMode.cameraX = 0;
                practiceMode.cameraY = 0;

                // Start the practice loop
                let lastPracticeFrameTime = performance.now();
                function practiceLoop(currentTime) {
                    if (!practiceMode.active) return;

                    // Calculate delta time
                    if (!currentTime) currentTime = performance.now();
                    let deltaTime = (currentTime - lastPracticeFrameTime) / 16.67;
                    if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                    lastPracticeFrameTime = currentTime;

                    // Update player
                    updatePracticePlayer(deltaTime);

                    // Update HUD
                    document.getElementById('hud').innerHTML = `
                        <div style="font-size: 24px; font-weight: bold;">${levelInfo.name}</div>
                        <div style="font-size: 14px; margin-top: 3px; color: #aaa;">By ${levelInfo.creator}</div>
                        <div style="font-size: 16px; color: #FFD700; margin-top: 5px;">WASD/Arrows to move!</div>
                    `;

                    // Render
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Camera follows player
                    practiceMode.cameraX = practiceMode.player.x - canvas.width / 2 + practiceMode.player.width / 2;
                    practiceMode.cameraY = practiceMode.player.y - canvas.height / 2 + practiceMode.player.height / 2;

                    // Draw platforms (dark gray with borders)
                    ctx.fillStyle = '#333';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    for (const platform of practiceMode.platforms) {
                        const screenX = platform.x - practiceMode.cameraX;
                        const screenY = platform.y - practiceMode.cameraY;
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);
                        ctx.strokeRect(screenX, screenY, platform.width, platform.height);
                    }

                    // Draw hazards (red with borders)
                    ctx.fillStyle = '#FF0000';
                    ctx.strokeStyle = '#8B0000';
                    for (const hazard of practiceMode.hazards) {
                        const screenX = hazard.x - practiceMode.cameraX;
                        const screenY = hazard.y - practiceMode.cameraY;
                        ctx.fillRect(screenX, screenY, hazard.width, hazard.height);
                        ctx.strokeRect(screenX, screenY, hazard.width, hazard.height);
                    }

                    // Draw growers (green with borders)
                    ctx.fillStyle = '#00FF00';
                    ctx.strokeStyle = '#006400';
                    for (const grower of practiceMode.growers) {
                        const screenX = grower.x - practiceMode.cameraX;
                        const screenY = grower.y - practiceMode.cameraY;
                        ctx.fillRect(screenX, screenY, grower.width, grower.height);
                        ctx.strokeRect(screenX, screenY, grower.width, grower.height);
                    }

                    // Draw shrinkers (blue with borders)
                    ctx.fillStyle = '#0000FF';
                    ctx.strokeStyle = '#000080';
                    for (const shrinker of practiceMode.shrinkers) {
                        const screenX = shrinker.x - practiceMode.cameraX;
                        const screenY = shrinker.y - practiceMode.cameraY;
                        ctx.fillRect(screenX, screenY, shrinker.width, shrinker.height);
                        ctx.strokeRect(screenX, screenY, shrinker.width, shrinker.height);
                    }

                    // Draw default size blocks (yellow with borders)
                    ctx.fillStyle = '#FFFF00';
                    ctx.strokeStyle = '#B8860B';
                    for (const block of practiceMode.defaultSizeBlocks) {
                        const screenX = block.x - practiceMode.cameraX;
                        const screenY = block.y - practiceMode.cameraY;
                        ctx.fillRect(screenX, screenY, block.width, block.height);
                        ctx.strokeRect(screenX, screenY, block.width, block.height);
                    }

                    // Draw particles
                    updateAndDrawParticles(ctx, practiceMode.cameraX, practiceMode.cameraY, deltaTime);

                    // Draw player
                    const screenX = practiceMode.player.x - practiceMode.cameraX;
                    const screenY = practiceMode.player.y - practiceMode.cameraY;

                    ctx.save();
                    ctx.translate(screenX + practiceMode.player.width / 2, screenY + practiceMode.player.height / 2);
                    ctx.scale(1, practiceMode.player.squashStretch || 1);
                    ctx.translate(-(screenX + practiceMode.player.width / 2), -(screenY + practiceMode.player.height / 2));

                    // Draw player with cosmetics
                    ctx.fillStyle = practiceMode.player.getSkinColor();
                    ctx.fillRect(screenX, screenY, practiceMode.player.width, practiceMode.player.height);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, screenY, practiceMode.player.width, practiceMode.player.height);

                    // Draw face
                    if (practiceMode.player.cosmetics.face !== 'none') {
                        ctx.fillStyle = '#000';
                        ctx.font = `${practiceMode.player.width * 0.6}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const faceEmoji = practiceMode.player.cosmetics.face === 'happy' ? '' :
                                        practiceMode.player.cosmetics.face === 'cool' ? '' :
                                        practiceMode.player.cosmetics.face === 'angry' ? '' : '';
                        ctx.fillText(faceEmoji, screenX + practiceMode.player.width / 2, screenY + practiceMode.player.height / 2);
                    }

                    ctx.restore();

                    requestAnimationFrame(practiceLoop);
                }

                practiceLoop();

            } catch (error) {
                console.error('Error loading level:', error);
                alert('Error loading level: ' + error.message);
            }
        }

        // Admin function to add levels to Firebase
        async function addLevelToDatabase(levelName, creatorName, levelData) {
            try {
                const levelId = 'level_' + Date.now();
                await database.ref('levels/' + levelId).set({
                    name: levelName,
                    creator: creatorName,
                    data: levelData,
                    createdAt: firebase.database.ServerValue.TIMESTAMP
                });
                console.log('Level added successfully with ID:', levelId);
                return levelId;
            } catch (error) {
                console.error('Error adding level:', error);
                throw error;
            }
        }

        // Add the "Vertical Challenge" level on first load
        async function initializeDefaultLevels() {
            const levelsSnapshot = await database.ref('levels').once('value');
            const levels = levelsSnapshot.val();

            // Only add default level if no levels exist
            if (!levels) {
                const verticalChallengeData = {
                    "platforms": [
                        {"x": 0, "y": 0, "width": 240, "height": 40},
                        {"x": 280, "y": -40, "width": 200, "height": 40},
                        {"x": 520, "y": -80, "width": 160, "height": 40},
                        {"x": 720, "y": -120, "width": 120, "height": 40},
                        {"x": 880, "y": -160, "width": 80, "height": 40},
                        {"x": 1000, "y": -200, "width": 40, "height": 40},
                        {"x": 1040, "y": -320, "width": 40, "height": 80},
                        {"x": 1080, "y": -480, "width": 40, "height": 120},
                        {"x": 1120, "y": -680, "width": 40, "height": 160},
                        {"x": 1160, "y": -920, "width": 40, "height": 200},
                        {"x": 1200, "y": -1200, "width": 40, "height": 240},
                        {"x": -320, "y": 40, "width": 280, "height": 40},
                        {"x": -680, "y": 80, "width": 320, "height": 40},
                        {"x": -1120, "y": 120, "width": 400, "height": 40},
                        {"x": 1240, "y": -1520, "width": 40, "height": 280},
                        {"x": 1280, "y": -1880, "width": 40, "height": 320},
                        {"x": 1320, "y": -2280, "width": 40, "height": 360},
                        {"x": 1360, "y": -2720, "width": 40, "height": 400},
                        {"x": 1030, "y": -250, "width": 10, "height": 10},
                        {"x": 1070, "y": -400, "width": 10, "height": 10},
                        {"x": 1110, "y": -560, "width": 10, "height": 10},
                        {"x": 1110, "y": -640, "width": 10, "height": 10},
                        {"x": 1150, "y": -760, "width": 10, "height": 10},
                        {"x": 1150, "y": -840, "width": 10, "height": 10},
                        {"x": 1180, "y": -1080, "width": 20, "height": 20},
                        {"x": 1220, "y": -1360, "width": 20, "height": 20},
                        {"x": 1260, "y": -1640, "width": 20, "height": 20},
                        {"x": 1260, "y": -1760, "width": 20, "height": 20},
                        {"x": 1300, "y": -2040, "width": 20, "height": 20},
                        {"x": 1300, "y": -2180, "width": 20, "height": 20},
                        {"x": 1340, "y": -2400, "width": 20, "height": 20},
                        {"x": 1340, "y": -2520, "width": 20, "height": 20},
                        {"x": 1340, "y": -2640, "width": 20, "height": 20},
                        {"x": 1400, "y": -3200, "width": 40, "height": 440},
                        {"x": 1440, "y": -3680, "width": 40, "height": 440},
                        {"x": 1360, "y": -3040, "width": 40, "height": 40},
                        {"x": 1320, "y": -3960, "width": 280, "height": 40},
                        {"x": -1600, "y": 160, "width": 440, "height": 40},
                        {"x": -2120, "y": 200, "width": 480, "height": 40},
                        {"x": 1400, "y": -3480, "width": 40, "height": 40},
                        {"x": 1400, "y": -3720, "width": 120, "height": 40}
                    ],
                    "hazards": [],
                    "growers": [
                        {"x": 1360, "y": -2760, "width": 40, "height": 40},
                        {"x": -2120, "y": 120, "width": 40, "height": 80},
                        {"x": -2080, "y": 120, "width": 40, "height": 40},
                        {"x": -2040, "y": 120, "width": 40, "height": 80}
                    ],
                    "shrinkers": [
                        {"x": 280, "y": -280, "width": 20, "height": 240}
                    ],
                    "defaultSizeBlocks": [
                        {"x": 1160, "y": -930, "width": 40, "height": 10},
                        {"x": 1560, "y": -4160, "width": 40, "height": 200},
                        {"x": 1360, "y": -4160, "width": 200, "height": 40},
                        {"x": 1320, "y": -4160, "width": 40, "height": 200},
                        {"x": -680, "y": -280, "width": 20, "height": 360}
                    ],
                    "backgroundBlocks": [],
                    "foregroundBlocks": [],
                    "triggers": [],
                    "start": {"x": -2080, "y": 160, "width": 40, "height": 40},
                    "finish": {"x": 1400, "y": -4080, "width": 120, "height": 120},
                    "physics": {
                        "gravity": 0.042,
                        "moveSpeed": 0.28,
                        "jumpPower": 3.7,
                        "maxSpeed": 3.5,
                        "friction": 0.94,
                        "airRes": 0.88,
                        "fastFallMultiplier": 2
                    }
                };

                await addLevelToDatabase('Vertical Challenge', 'System', verticalChallengeData);
                console.log('Default level "Vertical Challenge" added to database');
            }
        }

        // Practice mode (infinite runner with credit earning)
        let practiceMode = {
            active: false,
            player: null,
            platforms: [],
            credits: [], // Physical credit coins to collect
            platformsPassed: 0,
            creditsCollected: 0,
            lastPlatformX: 0,
            cameraX: 0,
            cameraY: 0,
            keys: {}
        };

        function startPracticeMode() {
            try {
                console.log('Starting practice mode...');

                const canvas = document.getElementById('practiceCanvas');
                const ctx = canvas.getContext('2d');

                if (!canvas || !ctx) {
                    console.error('Canvas or context not found!');
                    alert('Error: Practice canvas not found. Please refresh the page.');
                    return;
                }

                canvas.style.display = 'block';
                document.getElementById('hud').style.display = 'block';
                document.getElementById('practiceBackBtn').style.display = 'block';

                practiceMode.active = true;
                practiceMode.player = new Player(100, 300, equippedCosmetics);
                practiceMode.platforms = [];
                practiceMode.credits = [];
                practiceMode.platformsPassed = 0;
                practiceMode.creditsCollected = 0;
                practiceMode.lastPlatformX = -200; // Start from negative to generate from beginning

                console.log('Player created:', practiceMode.player);

                // Generate initial platforms
                for (let i = 0; i < 20; i++) {
                    generatePracticePlatform();
                }

                console.log('Generated platforms:', practiceMode.platforms.length);
                console.log('Generated credits:', practiceMode.credits.length);

            let lastPracticeFrameTime = performance.now();
            function practiceLoop(currentTime) {
                if (!practiceMode.active) return;

                // Calculate delta time
                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastPracticeFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                lastPracticeFrameTime = currentTime;

                // Update
                updatePracticePlayer(deltaTime);

                // Generate new platforms
                while (practiceMode.lastPlatformX < practiceMode.cameraX + 1500) {
                    generatePracticePlatform();
                }

                // Remove old platforms and credits
                practiceMode.platforms = practiceMode.platforms.filter(p => p.x > practiceMode.cameraX - 200);
                practiceMode.credits = practiceMode.credits.filter(c => c.x > practiceMode.cameraX - 200);

                // Update HUD
                document.getElementById('hud').innerHTML = `
                    <div style="font-size: 24px; font-weight: bold;">EARN MODE</div>
                    <div style="font-size: 18px; margin-top: 5px;">Collected This Run: ${practiceMode.creditsCollected}</div>
                    <div style="font-size: 16px; margin-top: 3px;">Credits: ${secureCredits} <span style="font-size: 12px; color: #aaa;">(${userCredits} on hand)</span></div>
                    <div style="font-size: 14px; margin-top: 3px; color: #aaa;">Active Credits: ${practiceMode.credits.filter(c => !c.collected).length}</div>
                    <div style="font-size: 16px; color: #FFD700; margin-top: 5px;">Collect coins!</div>
                `;

                // Render
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw death zone at bottom (red warning blocks)
                ctx.fillStyle = '#FF0000';
                const deathZoneY = 900 - practiceMode.cameraY;
                ctx.fillRect(0, deathZoneY, canvas.width, canvas.height - deathZoneY);

                // Draw skull icons on death zone
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 30px Arial';
                for (let x = 0; x < canvas.width; x += 60) {
                    ctx.fillText('', x, deathZoneY + 40);
                }

                // Draw platforms
                for (const platform of practiceMode.platforms) {
                    const screenX = platform.x - practiceMode.cameraX;
                    const screenY = platform.y - practiceMode.cameraY;

                    if (platform.isHazard) {
                        ctx.fillStyle = '#FF0000';
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);
                    } else {
                        // Green platform
                        ctx.fillStyle = '#00AA00';
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);

                        // Draw 40x40 grid lines
                        ctx.strokeStyle = '#006600';
                        ctx.lineWidth = 1;
                        for (let gx = 0; gx < platform.width; gx += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX + gx, screenY);
                            ctx.lineTo(screenX + gx, screenY + platform.height);
                            ctx.stroke();
                        }
                        for (let gy = 0; gy < platform.height; gy += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY + gy);
                            ctx.lineTo(screenX + platform.width, screenY + gy);
                            ctx.stroke();
                        }
                    }
                }

                // Draw credit coins
                for (const credit of practiceMode.credits) {
                    if (!credit.collected) {
                        const screenX = credit.x - practiceMode.cameraX;
                        const screenY = credit.y - practiceMode.cameraY;

                        // Draw golden coin with glow
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 15;

                        // Outer golden circle
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(screenX + 15, screenY + 15, 15, 0, Math.PI * 2);
                        ctx.fill();

                        // Inner darker circle for depth
                        ctx.fillStyle = '#FFA500';
                        ctx.beginPath();
                        ctx.arc(screenX + 15, screenY + 15, 10, 0, Math.PI * 2);
                        ctx.fill();

                        // Dollar sign
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('$', screenX + 15, screenY + 20);
                    }
                }

                // Update and draw particles
                particles = particles.filter(p => p.life > 0);
                for (const particle of particles) {
                    particle.update(deltaTime);
                    particle.draw(ctx, practiceMode.cameraX, practiceMode.cameraY);
                }

                // Draw player with squash/stretch
                practiceMode.player.updateTrail();
                practiceMode.player.draw(ctx, practiceMode.cameraX, practiceMode.cameraY, false);

                requestAnimationFrame(practiceLoop);
            }

            console.log('Starting practice loop...');
            practiceLoop();

            } catch (error) {
                console.error('Error starting practice mode:', error);
                alert('Error starting earn mode: ' + error.message);
            }
        }

        function generatePracticePlatform() {
            const lastPlatform = practiceMode.platforms[practiceMode.platforms.length - 1];
            const baseX = lastPlatform ? lastPlatform.x + lastPlatform.width + Math.random() * 150 + 50 : 0;
            const baseY = lastPlatform ? lastPlatform.y + (Math.random() - 0.5) * 100 : 500;

            // Width must be multiples of 40 (40x40 blocks only)
            const numBlocks = Math.floor(Math.random() * 4) + 2; // 2-5 blocks wide
            const width = numBlocks * 40;
            const platformY = Math.max(200, Math.min(600, Math.round(baseY / 40) * 40)); // Snap Y to 40px grid

            practiceMode.platforms.push({
                x: baseX,
                y: platformY,
                width: width,
                height: 40,
                isHazard: false
            });

            // Spawn credit coin above platform (70% chance per platform)
            if (Math.random() < 0.7) {
                practiceMode.credits.push({
                    x: baseX + width / 2 - 15, // Center above platform
                    y: platformY - 60, // Float above platform
                    width: 30,
                    height: 30,
                    collected: false
                });
            }

            practiceMode.lastPlatformX = baseX;
        }

        function updatePracticePlayer(deltaTime = 1) {
            const player = practiceMode.player;

            // Check if grounded first
            let isGrounded = false;
            for (const platform of practiceMode.platforms) {
                if (checkCollision(player, platform)) {
                    if (player.velocityY > 0 && player.y + player.height <= platform.y + 10) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        isGrounded = true;
                    }
                }
            }

            // COYOTE TIME: Allow jumping shortly after leaving platform
            if (isGrounded) {
                player.coyoteTimer = COYOTE_TIME;
                // Landing particles and squash
                if (!player.wasGrounded) {
                    spawnParticles(player.x + player.width / 2, player.y + player.height, 8, 'rgb(200, 200, 200)');
                    player.squashStretch = 0.7; // Squash on landing
                }
            } else {
                player.coyoteTimer = Math.max(0, player.coyoteTimer - deltaTime);
            }
            player.wasGrounded = isGrounded;

            // Return squash/stretch to normal
            player.squashStretch += (1 - player.squashStretch) * 0.3;

            // Handle input with different behavior for ground vs air
            if (isGrounded) {
                // On ground: gradual acceleration to ground max speed
                const currentSpeed = Math.abs(player.velocityX);
                const speedRatio = currentSpeed / GROUND_MAX_SPEED;
                const accelMultiplier = 1 - (speedRatio * GROUND_ACCELERATION);

                if (practiceMode.keys['a'] || practiceMode.keys['ArrowLeft']) {
                    player.velocityX -= MOVE_SPEED * deltaTime * accelMultiplier;
                }
                if (practiceMode.keys['d'] || practiceMode.keys['ArrowRight']) {
                    player.velocityX += MOVE_SPEED * deltaTime * accelMultiplier;
                }
            } else {
                // In air: full control up to air max speed
                if (practiceMode.keys['a'] || practiceMode.keys['ArrowLeft']) {
                    player.velocityX -= MOVE_SPEED * deltaTime;
                }
                if (practiceMode.keys['d'] || practiceMode.keys['ArrowRight']) {
                    player.velocityX += MOVE_SPEED * deltaTime;
                }
            }

            // Speed-based movement particles
            const speed = Math.abs(player.velocityX);
            if (speed > 0.5) {
                // More particles = faster movement
                const particleChance = Math.min(speed / 10, 0.8); // Max 80% chance
                if (Math.random() < particleChance) {
                    const particleCount = Math.floor(speed / 2);
                    spawnParticles(
                        player.x + player.width / 2 + (Math.random() - 0.5) * player.width,
                        player.y + player.height,
                        Math.max(1, particleCount),
                        player.getSkinColor()
                    );
                }
            }

            // JUMP BUFFER: Remember jump input
            if (practiceMode.keys['w'] || practiceMode.keys['ArrowUp'] || practiceMode.keys[' ']) {
                player.jumpBufferTimer = JUMP_BUFFER_TIME;
            } else {
                player.jumpBufferTimer = Math.max(0, player.jumpBufferTimer - deltaTime);
            }

            // Jump with coyote time and jump buffering
            if (player.jumpBufferTimer > 0 && player.coyoteTimer > 0 && !practiceIsJumping) {
                player.velocityY = -JUMP_POWER;
                practiceIsJumping = true;
                player.coyoteTimer = 0;
                player.jumpBufferTimer = 0;
                player.squashStretch = 1.3; // Stretch on jump
                // Jump particles
                spawnParticles(player.x + player.width / 2, player.y + player.height, 12, 'rgb(255, 255, 255)');
            }

            // Cut jump short if button released (variable jump height)
            if (practiceIsJumping && !practiceMode.keys['w'] && !practiceMode.keys['ArrowUp'] && !practiceMode.keys[' ']) {
                if (player.velocityY < 0) {
                    player.velocityY *= 0.5;
                }
                practiceIsJumping = false;
            }

            // Reset jump state when grounded
            if (isGrounded && player.velocityY >= 0) {
                practiceIsJumping = false;
            }

            // Apply gravity with fast fall
            if ((practiceMode.keys['s'] || practiceMode.keys['ArrowDown']) && !isGrounded) {
                player.velocityY += GRAVITY * FAST_FALL_MULTIPLIER * deltaTime;
                // Fast fall particles
                if (Math.random() < 0.3) {
                    spawnParticles(player.x + player.width / 2, player.y, 1, 'rgb(200, 255, 255)');
                }
            } else {
                player.velocityY += GRAVITY * deltaTime;
            }

            // Apply friction using exponential decay
            if (isGrounded) {
                player.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                player.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Limit speed based on whether grounded or in air
            const maxSpeed = isGrounded ? GROUND_MAX_SPEED : AIR_MAX_SPEED;
            player.velocityX = Math.max(-maxSpeed, Math.min(maxSpeed, player.velocityX));

            // Update position
            player.x += player.velocityX * deltaTime;
            player.y += player.velocityY * deltaTime;

            // Check credit collection
            for (const credit of practiceMode.credits) {
                if (!credit.collected && checkCollision(player, credit)) {
                    credit.collected = true;
                    practiceMode.creditsCollected++;
                    updateCredits(1);
                }
            }

            // Die if fall off (instant death, respawn at start)
            if (player.y > 900) {
                // Death particles
                spawnParticles(player.x + player.width / 2, player.y + player.height / 2, 30, 'rgb(255, 0, 0)');

                // Reset to start
                player.x = 100;
                player.y = 300;
                player.velocityX = 0;
                player.velocityY = 0;
                practiceMode.creditsCollected = 0; // Lose collected credits on death

                // Reset camera
                practiceMode.cameraX = 0;
            }

            // Update camera
            practiceMode.cameraX = player.x - 300;
            practiceMode.cameraY = 0;
        }

        // Party system
        async function createParty() {
            const partyId = 'party_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            currentPartyId = partyId;

            await database.ref('parties/' + partyId).set({
                leaderId: currentUser.uid,
                members: {
                    [currentUser.uid]: {
                        username: currentUsername,
                        ready: false
                    }
                },
                invitations: {},
                createdAt: firebase.database.ServerValue.TIMESTAMP
            });

            listenToParty(partyId);
            showScreen('partyScreen');
        }

        function listenToParty(partyId) {
            database.ref('parties/' + partyId).on('value', (snapshot) => {
                const party = snapshot.val();
                if (!party) {
                    // Party was deleted
                    currentPartyId = null;
                    backToMainMenu();
                    return;
                }

                currentParty = party;
                updatePartyUI();
            });

            // Listen for invitations
            database.ref('parties/' + partyId + '/invitations/' + currentUser.uid).on('value', (snapshot) => {
                const invite = snapshot.val();
                if (invite && invite.status === 'pending') {
                    // Show invitation
                }
            });
        }

        function updatePartyUI() {
            if (!currentParty) return;

            const isLeader = currentParty.leaderId === currentUser.uid;

            document.getElementById('partyInfo').innerHTML = `
                <div style="font-size: 20px; color: #4facfe; margin-bottom: 10px;">
                    Party ID: <span style="color: #FFC107;">${currentPartyId}</span>
                </div>
                <div>Share this ID with friends to invite them!</div>
            `;

            let membersHTML = '<h3>Members:</h3>';
            for (const [uid, member] of Object.entries(currentParty.members || {})) {
                const readyBadge = member.ready ? ' [READY]' : '';
                const leaderBadge = uid === currentParty.leaderId ? ' [LEADER]' : '';
                membersHTML += `<div class="party-member ${member.ready ? 'ready' : ''}">${member.username}${leaderBadge}${readyBadge}</div>`;
            }
            document.getElementById('partyMembers').innerHTML = membersHTML;

            // Party controls
            if (isLeader) {
                const memberCount = Object.keys(currentParty.members || {}).length;
                const canStart = memberCount >= 2 && Object.values(currentParty.members).every(m => m.ready);
                document.getElementById('partyControls').innerHTML = `
                    <button onclick="toggleReady()">Toggle Ready</button>
                    <button onclick="startRaceLobby()" ${canStart ? '' : 'disabled'}>Start Race</button>
                `;
            } else {
                document.getElementById('partyControls').innerHTML = `
                    <button onclick="toggleReady()">Toggle Ready</button>
                `;
            }
        }

        async function sendInvite() {
            const username = document.getElementById('inviteUsername').value.trim();
            if (!username) return;

            // Find user by username
            const usersSnapshot = await database.ref('users').orderByChild('username').equalTo(username).once('value');
            const users = usersSnapshot.val();

            if (!users) {
                alert('User not found');
                return;
            }

            const userId = Object.keys(users)[0];

            await database.ref('parties/' + currentPartyId + '/invitations/' + userId).set({
                username: username,
                status: 'pending',
                from: currentUsername
            });

            document.getElementById('inviteUsername').value = '';
            alert('Invite sent!');
        }

        async function joinPartyById() {
            const partyId = document.getElementById('partyIdInput').value.trim();
            if (!partyId) return;

            const partySnapshot = await database.ref('parties/' + partyId).once('value');
            if (!partySnapshot.exists()) {
                alert('Party not found');
                return;
            }

            currentPartyId = partyId;
            await database.ref('parties/' + partyId + '/members/' + currentUser.uid).set({
                username: currentUsername,
                ready: false
            });

            listenToParty(partyId);
            showScreen('partyScreen');
        }

        async function toggleReady() {
            if (!currentPartyId) return;
            const currentReady = currentParty.members[currentUser.uid].ready;
            await database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid + '/ready').set(!currentReady);
        }

        async function leaveParty() {
            if (!currentPartyId) return;

            await database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid).remove();

            // If leader, delete party
            if (currentParty.leaderId === currentUser.uid) {
                await database.ref('parties/' + currentPartyId).remove();
            }

            database.ref('parties/' + currentPartyId).off();
            currentPartyId = null;
            backToMainMenu();
        }

        // Lobby system
        async function startRaceLobby() {
            const lobbyId = 'lobby_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            currentLobbyId = lobbyId;

            // Move all party members to lobby
            const lobbyPlayers = {};
            for (const [uid, member] of Object.entries(currentParty.members)) {
                lobbyPlayers[uid] = {
                    username: member.username,
                    ready: false,
                    credits: 0 // Will be fetched
                };
            }

            await database.ref('lobbies/' + lobbyId).set({
                mapId: maps[0].id,
                betAmount: 0,
                players: lobbyPlayers,
                raceStarted: false,
                leaderId: currentParty.leaderId
            });

            // Notify all party members to join lobby
            for (const uid of Object.keys(currentParty.members)) {
                await database.ref('parties/' + currentPartyId + '/lobbyId').set(lobbyId);
            }

            listenToLobby(lobbyId);
            showScreen('lobbyScreen');
        }

        function listenToLobby(lobbyId) {
            database.ref('lobbies/' + lobbyId).on('value', (snapshot) => {
                const lobby = snapshot.val();
                if (!lobby) {
                    currentLobbyId = null;
                    backToMainMenu();
                    return;
                }

                currentLobby = lobby;

                if (lobby.raceStarted && lobby.raceStartTime) {
                    startMultiplayerRace();
                } else {
                    updateLobbyUI();
                }
            });
        }

        function updateLobbyUI() {
            if (!currentLobby) return;

            const isLeader = currentLobby.leaderId === currentUser.uid;

            // Map selection
            let mapOptions = '';
            for (const map of maps) {
                mapOptions += `<option value="${map.id}" ${currentLobby.mapId === map.id ? 'selected' : ''}>${map.name}</option>`;
            }

            document.getElementById('lobbyInfo').innerHTML = `
                <div>
                    <label>Map:</label>
                    <select id="lobbyMapSelect" onchange="updateLobbyMap()" ${isLeader ? '' : 'disabled'}>
                        ${mapOptions}
                    </select>
                </div>
                <div>
                    <label>Bet Amount:</label>
                    <input type="number" id="lobbyBetAmount" value="${currentLobby.betAmount}" min="0" max="1000" onchange="updateLobbyBet()" ${isLeader ? '' : 'readonly'}>
                </div>
            `;

            // Players
            let playersHTML = '<h3>Players:</h3>';
            for (const [uid, player] of Object.entries(currentLobby.players || {})) {
                const readyBadge = player.ready ? ' [READY]' : '';
                playersHTML += `<div class="party-member ${player.ready ? 'ready' : ''}">${player.username}${readyBadge}</div>`;
            }
            document.getElementById('lobbyPlayers').innerHTML = playersHTML;

            // Controls
            const allReady = Object.values(currentLobby.players).every(p => p.ready);
            if (isLeader) {
                document.getElementById('lobbyControls').innerHTML = `
                    <button onclick="toggleLobbyReady()">Toggle Ready</button>
                    <button onclick="startRace()" ${allReady ? '' : 'disabled'}>Start Race</button>
                `;
            } else {
                document.getElementById('lobbyControls').innerHTML = `
                    <button onclick="toggleLobbyReady()">Toggle Ready</button>
                `;
            }
        }

        async function updateLobbyMap() {
            const mapId = document.getElementById('lobbyMapSelect').value;
            await database.ref('lobbies/' + currentLobbyId + '/mapId').set(mapId);
        }

        async function updateLobbyBet() {
            const betAmount = parseInt(document.getElementById('lobbyBetAmount').value) || 0;
            await database.ref('lobbies/' + currentLobbyId + '/betAmount').set(betAmount);
        }

        async function toggleLobbyReady() {
            if (!currentLobbyId) return;
            const currentReady = currentLobby.players[currentUser.uid].ready;
            await database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid + '/ready').set(!currentReady);
        }

        async function startRace() {
            await database.ref('lobbies/' + currentLobbyId).update({
                raceStarted: true,
                raceStartTime: firebase.database.ServerValue.TIMESTAMP
            });
        }

        async function leaveLobby() {
            if (!currentLobbyId) return;
            database.ref('lobbies/' + currentLobbyId).off();
            await database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid).remove();
            currentLobbyId = null;
            backToMainMenu();
        }

        // Multiplayer racing
        let raceState = {
            active: false,
            player: null,
            opponents: {},
            map: null,
            startTime: 0,
            finishTime: 0,
            finished: false,
            cameraX: 0,
            cameraY: 0,
            keys: {},
            platforms: [],
            hazards: []
        };

        async function startMultiplayerRace() {
            const canvas = document.getElementById('raceCanvas');
            const ctx = canvas.getContext('2d');
            canvas.style.display = 'block';
            document.getElementById('timer').style.display = 'block';
            document.getElementById('racePositions').style.display = 'block';

            // Hide lobby screen
            document.getElementById('lobbyScreen').classList.remove('active');

            // Get map
            raceState.map = maps.find(m => m.id === currentLobby.mapId);
            raceState.platforms = raceState.map.platforms;
            raceState.hazards = raceState.map.hazards;

            // Create player at start position
            raceState.player = new Player(raceState.map.start.x, raceState.map.start.y, equippedCosmetics);
            raceState.active = true;
            raceState.finished = false;
            raceState.startTime = Date.now();

            // Countdown
            await showCountdown();

            // Listen for opponent positions
            database.ref('lobbies/' + currentLobbyId + '/players').on('value', (snapshot) => {
                const players = snapshot.val();
                raceState.opponents = {};
                for (const [uid, player] of Object.entries(players)) {
                    if (uid !== currentUser.uid && player.position) {
                        raceState.opponents[uid] = {
                            username: player.username,
                            player: new Player(player.position.x, player.position.y, player.equippedCosmetics || {}),
                            finished: player.finished || false
                        };
                    }
                }
            });

            // Start position sync
            const positionSyncInterval = setInterval(() => {
                if (!raceState.active || raceState.finished) {
                    clearInterval(positionSyncInterval);
                    return;
                }

                database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid).update({
                    position: { x: raceState.player.x, y: raceState.player.y },
                    velocity: { x: raceState.player.velocityX, y: raceState.player.velocityY },
                    equippedCosmetics: equippedCosmetics
                });
            }, 100);

            let lastRaceFrameTime = performance.now();
            function raceLoop(currentTime) {
                if (!raceState.active) return;

                // Calculate delta time
                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastRaceFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                lastRaceFrameTime = currentTime;

                // Update
                updateRacePlayer(deltaTime);

                // Check finish
                if (!raceState.finished && checkCollision(raceState.player, raceState.map.finish)) {
                    finishRace();
                }

                // Update timer
                const elapsed = (Date.now() - raceState.startTime) / 1000;
                document.getElementById('timer').textContent = elapsed.toFixed(2);

                // Update positions
                updateRacePositions();

                // Render
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw platforms
                for (const platform of raceState.platforms) {
                    const screenX = platform.x - raceState.cameraX;
                    const screenY = platform.y - raceState.cameraY;

                    // Green platform
                    ctx.fillStyle = '#00AA00';
                    ctx.fillRect(screenX, screenY, platform.width, platform.height);

                    // Draw 40x40 grid lines
                    ctx.strokeStyle = '#006600';
                    ctx.lineWidth = 1;
                    for (let gx = 0; gx < platform.width; gx += 40) {
                        ctx.beginPath();
                        ctx.moveTo(screenX + gx, screenY);
                        ctx.lineTo(screenX + gx, screenY + platform.height);
                        ctx.stroke();
                    }
                    for (let gy = 0; gy < platform.height; gy += 40) {
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY + gy);
                        ctx.lineTo(screenX + platform.width, screenY + gy);
                        ctx.stroke();
                    }
                }

                // Draw hazards (red)
                for (const hazard of raceState.hazards) {
                    const screenX = hazard.x - raceState.cameraX;
                    const screenY = hazard.y - raceState.cameraY;
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(screenX, screenY, hazard.width, hazard.height);
                }

                // Draw finish line
                const finishScreenX = raceState.map.finish.x - raceState.cameraX;
                const finishScreenY = raceState.map.finish.y - raceState.cameraY;
                ctx.fillStyle = '#00FF00';
                ctx.fillRect(finishScreenX, finishScreenY, raceState.map.finish.width, raceState.map.finish.height);

                // Draw opponents
                for (const opponent of Object.values(raceState.opponents)) {
                    opponent.player.updateTrail();
                    opponent.player.draw(ctx, raceState.cameraX, raceState.cameraY, true, opponent.username);
                }

                // Draw local player
                raceState.player.updateTrail();
                raceState.player.draw(ctx, raceState.cameraX, raceState.cameraY, true, currentUsername);

                requestAnimationFrame(raceLoop);
            }

            raceLoop();
        }

        function updateRacePlayer(deltaTime = 1) {
            const player = raceState.player;

            // Check collisions first
            let isGrounded = false;
            for (const platform of raceState.platforms) {
                if (checkCollision(player, platform)) {
                    if (player.velocityY > 0 && player.y + player.height <= platform.y + 10) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        isGrounded = true;
                    }
                }
            }

            // Check hazards
            for (const hazard of raceState.hazards) {
                if (checkCollision(player, hazard)) {
                    // Reset to start
                    player.x = raceState.map.start.x;
                    player.y = raceState.map.start.y;
                    player.velocityX = 0;
                    player.velocityY = 0;
                    raceIsJumping = false;
                }
            }

            // Apply gravity with fast fall
            if ((raceState.keys['s'] || raceState.keys['ArrowDown']) && !isGrounded) {
                player.velocityY += GRAVITY * FAST_FALL_MULTIPLIER * deltaTime;
            } else {
                player.velocityY += GRAVITY * deltaTime;
            }

            // Handle input
            if (raceState.keys['a'] || raceState.keys['ArrowLeft']) {
                player.velocityX -= MOVE_SPEED * deltaTime;
            }
            if (raceState.keys['d'] || raceState.keys['ArrowRight']) {
                player.velocityX += MOVE_SPEED * deltaTime;
            }

            // Jump with variable height
            if ((raceState.keys['w'] || raceState.keys['ArrowUp'] || raceState.keys[' ']) && isGrounded) {
                player.velocityY = -JUMP_POWER;
                raceIsJumping = true;
            }

            // Cut jump short if button released (variable jump height)
            if (raceIsJumping && !raceState.keys['w'] && !raceState.keys['ArrowUp'] && !raceState.keys[' ']) {
                if (player.velocityY < 0) {
                    player.velocityY *= 0.5;
                }
                raceIsJumping = false;
            }

            // Reset jump state when grounded
            if (isGrounded && player.velocityY >= 0) {
                raceIsJumping = false;
            }

            // Apply friction using exponential decay
            if (isGrounded) {
                player.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                player.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Limit speed based on whether grounded or in air
            const maxSpeed = isGrounded ? GROUND_MAX_SPEED : AIR_MAX_SPEED;
            player.velocityX = Math.max(-maxSpeed, Math.min(maxSpeed, player.velocityX));

            // Update position
            player.x += player.velocityX * deltaTime;
            player.y += player.velocityY * deltaTime;

            // Update camera
            raceState.cameraX = player.x - 400;
            raceState.cameraY = player.y - 300;
        }

        function updateRacePositions() {
            // Calculate positions based on distance to finish
            const finishX = raceState.map.finish.x;

            const positions = [
                { uid: currentUser.uid, username: currentUsername, distance: Math.abs(raceState.player.x - finishX), finished: raceState.finished }
            ];

            for (const [uid, opponent] of Object.entries(raceState.opponents)) {
                positions.push({
                    uid: uid,
                    username: opponent.username,
                    distance: Math.abs(opponent.player.x - finishX),
                    finished: opponent.finished
                });
            }

            positions.sort((a, b) => {
                if (a.finished && !b.finished) return -1;
                if (!a.finished && b.finished) return 1;
                return a.distance - b.distance;
            });

            let html = '<h3>Positions</h3>';
            for (let i = 0; i < positions.length; i++) {
                html += `<div>${i + 1}. ${positions[i].username}${positions[i].finished ? ' [FINISHED]' : ''}</div>`;
            }
            document.getElementById('racePositions').innerHTML = html;
        }

        async function finishRace() {
            raceState.finished = true;
            raceState.finishTime = Date.now() - raceState.startTime;

            await database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid).update({
                finished: true,
                finishTime: raceState.finishTime
            });

            // Check if all finished
            setTimeout(checkRaceComplete, 2000);
        }

        async function checkRaceComplete() {
            const snapshot = await database.ref('lobbies/' + currentLobbyId + '/players').once('value');
            const players = snapshot.val();

            const allFinished = Object.values(players).every(p => p.finished);

            if (allFinished) {
                // Calculate results
                const results = [];
                for (const [uid, player] of Object.entries(players)) {
                    results.push({
                        uid: uid,
                        username: player.username,
                        time: player.finishTime
                    });
                }

                results.sort((a, b) => a.time - b.time);

                // Award credits to winner
                if (results[0].uid === currentUser.uid) {
                    const pot = currentLobby.betAmount * Object.keys(players).length;
                    await updateCredits(pot);
                    userStats.racesWon++;
                }

                userStats.racesPlayed++;
                await database.ref('players/' + currentUser.uid + '/stats').set(userStats);

                // Show results
                showRaceResults(results);
            }
        }

        function showRaceResults(results) {
            let html = '';
            for (let i = 0; i < results.length; i++) {
                const isMe = results[i].uid === currentUser.uid;
                const isWinner = i === 0;
                html += `<div class="result-entry ${isWinner ? 'winner' : ''}" style="${isMe ? 'font-weight: bold; color: #4facfe;' : ''}">
                    ${i + 1}. ${results[i].username} - ${(results[i].time / 1000).toFixed(2)}s
                </div>`;
            }

            if (results[0].uid === currentUser.uid) {
                const pot = currentLobby.betAmount * results.length;
                html = `<div style="color: #FFD700; font-size: 24px; margin-bottom: 20px;">YOU WIN! +${pot} credits</div>` + html;
            }

            document.getElementById('resultsContent').innerHTML = html;
            document.getElementById('raceResults').style.display = 'block';
        }

        async function returnToParty() {
            document.getElementById('raceResults').style.display = 'none';
            document.getElementById('raceCanvas').style.display = 'none';
            document.getElementById('timer').style.display = 'none';
            document.getElementById('racePositions').style.display = 'none';

            raceState.active = false;
            database.ref('lobbies/' + currentLobbyId + '/players').off();

            await database.ref('lobbies/' + currentLobbyId).remove();

            showScreen('partyScreen');
        }

        async function showCountdown() {
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';

            for (let i = 3; i > 0; i--) {
                countdownEl.textContent = i;
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            countdownEl.textContent = 'GO!';
            await new Promise(resolve => setTimeout(resolve, 500));
            countdownEl.style.display = 'none';
        }

        // Cosmetic shop
        function showShop() {
            showScreen('shopScreen');
            updateShopUI();
        }

        function updateShopUI() {
            document.getElementById('shopCredits').textContent = `On-Hand Credits: ${userCredits}`;

            let html = '';

            for (const [category, items] of Object.entries(cosmeticsCatalog)) {
                html += `<div class="shop-category">
                    <h2>${category.toUpperCase()}</h2>
                    <div class="cosmetics-grid">`;

                for (const item of items) {
                    const owned = userCosmetics[category].includes(item.id);
                    const equipped = equippedCosmetics[category === 'skins' ? 'skin' : category.slice(0, -1)] === item.id;

                    html += `<div class="cosmetic-item ${owned ? 'owned' : ''} ${equipped ? 'equipped' : ''}">
                        <div style="font-weight: bold;">${item.name}</div>
                        <div style="color: #FFC107;">${item.price} credits</div>`;

                    if (equipped) {
                        html += `<div style="display: flex; flex-direction: column; gap: 5px; margin-top: 5px;">
                            <div style="color: #0f0;"> EQUIPPED</div>
                            <button onclick="unequipCosmetic('${category}')">Unequip</button>
                        </div>`;
                    } else if (owned) {
                        html += `<button onclick="equipCosmetic('${category}', '${item.id}')" style="margin-top: 5px;">Equip</button>`;
                    } else {
                        html += `<button onclick="buyCosmetic('${category}', '${item.id}', ${item.price})" ${userCredits >= item.price ? '' : 'disabled'} style="margin-top: 5px;">Buy</button>`;
                    }

                    html += `</div>`;
                }

                html += `</div></div>`;
            }

            document.getElementById('shopContent').innerHTML = html;
        }

        async function buyCosmetic(category, itemId, price) {
            if (userCredits < price) {
                alert('Not enough credits!');
                return;
            }

            await updateCredits(-price);
            userCosmetics[category].push(itemId);
            await database.ref('players/' + currentUser.uid + '/cosmetics').set(userCosmetics);

            updateShopUI();
        }

        async function equipCosmetic(category, itemId) {
            const slot = category === 'skins' ? 'skin' : category.slice(0, -1);
            equippedCosmetics[slot] = itemId;
            await database.ref('players/' + currentUser.uid + '/equippedCosmetics').set(equippedCosmetics);

            // Update menu player cosmetics immediately
            if (menuPlayer) {
                menuPlayer.cosmetics = equippedCosmetics;
            }

            updateShopUI();
        }

        async function unequipCosmetic(category) {
            const slot = category === 'skins' ? 'skin' : category.slice(0, -1);
            const defaultValue = slot === 'skin' ? 'default_orange' : 'none';
            equippedCosmetics[slot] = defaultValue;
            await database.ref('players/' + currentUser.uid + '/equippedCosmetics').set(equippedCosmetics);

            // Update menu player cosmetics immediately
            if (menuPlayer) {
                menuPlayer.cosmetics = equippedCosmetics;
            }

            updateShopUI();
        }

        // Stats screen
        function showStats() {
            showScreen('statsScreen');
            document.getElementById('statsContent').innerHTML = `
                <div style="margin: 20px 0;">Races Won: ${userStats.racesWon}</div>
                <div style="margin: 20px 0;">Races Played: ${userStats.racesPlayed}</div>
                <div style="margin: 20px 0;">Win Rate: ${userStats.racesPlayed > 0 ? ((userStats.racesWon / userStats.racesPlayed) * 100).toFixed(1) : 0}%</div>
                <div style="margin: 20px 0;">Total Credits Earned: ${userStats.totalCreditsEarned}</div>
            `;
        }

        // Base screen (build with credits)
        let baseBlocks = [];
        let baseCanvas, baseCtx;
        let basePlayer = null;
        let baseKeys = {};
        let baseIsJumping = false;
        let basePlatforms = [];

        async function showBase() {
            showScreen('baseScreen');
            document.getElementById('baseCredits').textContent = `Credits: ${secureCredits} (${userCredits} on hand)`;

            baseCanvas = document.getElementById('baseCanvas');
            baseCtx = baseCanvas.getContext('2d');

            // Load base blocks from Firebase
            const baseSnapshot = await database.ref('players/' + currentUser.uid + '/baseBlocks').once('value');
            baseBlocks = baseSnapshot.val() || [];

            // Create base platforms (100x100 blocks = 4000x4000px area)
            basePlatforms = [
                // Ground
                { x: 0, y: 4000, width: 4000, height: 80 },
                // Left wall (100 blocks high)
                { x: -40, y: 0, width: 40, height: 4080 },
                // Right wall
                { x: 4000, y: 0, width: 40, height: 4080 }
            ];

            // Initialize player at center bottom of base
            basePlayer = new Player(2000, 3960, equippedCosmetics);

            renderBase();

            // Add click handlers
            baseCanvas.onclick = handleBaseClick;
            baseCanvas.oncontextmenu = handleBaseRightClick;

            // Start base loop
            let lastBaseFrameTime = performance.now();
            function baseLoop(currentTime) {
                if (baseCanvas.style.display === 'none') return;

                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastBaseFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                lastBaseFrameTime = currentTime;

                updateBasePlayer(deltaTime);
                renderBase();

                requestAnimationFrame(baseLoop);
            }

            baseLoop();
        }

        function updateBasePlayer(deltaTime = 1) {
            if (!basePlayer) return;

            // Combine user-placed blocks with boundary platforms for collision
            const allPlatforms = [...basePlatforms, ...baseBlocks.map(b => ({ x: b.x, y: b.y, width: 40, height: 40 }))];

            // Check grounded state
            let isGrounded = false;
            for (const platform of allPlatforms) {
                const onTop = basePlayer.y + basePlayer.height >= platform.y &&
                              basePlayer.y + basePlayer.height <= platform.y + 5;
                const horizontalOverlap = basePlayer.x + basePlayer.width > platform.x &&
                                         basePlayer.x < platform.x + platform.width;

                if (onTop && horizontalOverlap) {
                    isGrounded = true;
                    break;
                }
            }

            // Apply gravity
            if ((baseKeys['s'] || baseKeys['ArrowDown']) && !isGrounded) {
                basePlayer.velocityY += GRAVITY * FAST_FALL_MULTIPLIER * deltaTime;
            } else {
                basePlayer.velocityY += GRAVITY * deltaTime;
            }

            // Movement
            if (baseKeys['a'] || baseKeys['ArrowLeft']) {
                basePlayer.velocityX -= MOVE_SPEED * deltaTime;
            }
            if (baseKeys['d'] || baseKeys['ArrowRight']) {
                basePlayer.velocityX += MOVE_SPEED * deltaTime;
            }

            // Jump
            if ((baseKeys['w'] || baseKeys['ArrowUp']) && isGrounded) {
                basePlayer.velocityY = -JUMP_POWER;
                baseIsJumping = true;
            }

            // Variable jump height
            if (baseIsJumping && !baseKeys['w'] && !baseKeys['ArrowUp']) {
                if (basePlayer.velocityY < 0) {
                    basePlayer.velocityY *= 0.5;
                }
                baseIsJumping = false;
            }

            // Friction
            if (isGrounded) {
                basePlayer.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                basePlayer.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Limit speed
            basePlayer.velocityX = Math.max(-GROUND_MAX_SPEED, Math.min(GROUND_MAX_SPEED, basePlayer.velocityX));

            // Update X position, check X collisions
            basePlayer.x += basePlayer.velocityX * deltaTime;
            for (const platform of allPlatforms) {
                if (checkCollision(basePlayer, platform)) {
                    if (basePlayer.velocityX > 0) {
                        basePlayer.x = platform.x - basePlayer.width;
                    } else if (basePlayer.velocityX < 0) {
                        basePlayer.x = platform.x + platform.width;
                    }
                    basePlayer.velocityX = 0;
                }
            }

            // Update Y position, check Y collisions
            basePlayer.y += basePlayer.velocityY * deltaTime;
            for (const platform of allPlatforms) {
                if (checkCollision(basePlayer, platform)) {
                    if (basePlayer.velocityY > 0) {
                        basePlayer.y = platform.y - basePlayer.height;
                        basePlayer.velocityY = 0;
                    } else if (basePlayer.velocityY < 0) {
                        basePlayer.y = platform.y + platform.height;
                        basePlayer.velocityY = 0;
                        baseIsJumping = false;
                    }
                }
            }
        }

        function renderBase() {
            if (!basePlayer) return;

            // Camera follows player
            const cameraX = basePlayer.x - baseCanvas.width / 2;
            const cameraY = basePlayer.y - baseCanvas.height / 2;

            baseCtx.fillStyle = '#87CEEB';
            baseCtx.fillRect(0, 0, baseCanvas.width, baseCanvas.height);

            // Draw grid
            baseCtx.strokeStyle = '#ccc';
            baseCtx.lineWidth = 0.5;
            for (let x = 0; x <= 4000; x += 40) {
                const screenX = x - cameraX;
                baseCtx.beginPath();
                baseCtx.moveTo(screenX, -cameraY);
                baseCtx.lineTo(screenX, 4080 - cameraY);
                baseCtx.stroke();
            }
            for (let y = 0; y <= 4080; y += 40) {
                const screenY = y - cameraY;
                baseCtx.beginPath();
                baseCtx.moveTo(-cameraX, screenY);
                baseCtx.lineTo(4000 - cameraX, screenY);
                baseCtx.stroke();
            }

            // Draw boundary platforms (ground and walls)
            for (const platform of basePlatforms) {
                const screenX = platform.x - cameraX;
                const screenY = platform.y - cameraY;
                baseCtx.fillStyle = '#00AA00';
                baseCtx.fillRect(screenX, screenY, platform.width, platform.height);

                // Grid lines
                baseCtx.strokeStyle = '#006600';
                baseCtx.lineWidth = 1;
                for (let gx = 0; gx < platform.width; gx += 40) {
                    baseCtx.beginPath();
                    baseCtx.moveTo(screenX + gx, screenY);
                    baseCtx.lineTo(screenX + gx, screenY + platform.height);
                    baseCtx.stroke();
                }
                for (let gy = 0; gy < platform.height; gy += 40) {
                    baseCtx.beginPath();
                    baseCtx.moveTo(screenX, screenY + gy);
                    baseCtx.lineTo(screenX + platform.width, screenY + gy);
                    baseCtx.stroke();
                }
            }

            // Draw placed blocks (golden)
            for (const block of baseBlocks) {
                const screenX = block.x - cameraX;
                const screenY = block.y - cameraY;

                // Golden block
                baseCtx.fillStyle = '#FFD700';
                baseCtx.fillRect(screenX, screenY, 40, 40);
                baseCtx.strokeStyle = '#FFA500';
                baseCtx.lineWidth = 2;
                baseCtx.strokeRect(screenX, screenY, 40, 40);
            }

            // Draw player
            basePlayer.updateTrail();
            basePlayer.draw(baseCtx, cameraX, cameraY, false);
        }

        async function handleBaseClick(e) {
            if (!basePlayer) return;

            const rect = baseCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Convert screen coordinates to world coordinates
            const cameraX = basePlayer.x - baseCanvas.width / 2;
            const cameraY = basePlayer.y - baseCanvas.height / 2;
            const worldX = clickX + cameraX;
            const worldY = clickY + cameraY;

            // Snap to grid
            const gridX = Math.floor(worldX / 40) * 40;
            const gridY = Math.floor(worldY / 40) * 40;

            // Check if within base bounds (0-4000, 0-4000)
            if (gridX < 0 || gridX >= 4000 || gridY < 0 || gridY >= 4000) {
                alert('Cannot place blocks outside the base area!');
                return;
            }

            // Check if block already exists
            const exists = baseBlocks.some(b => b.x === gridX && b.y === gridY);
            if (exists) {
                alert('Block already placed here!');
                return;
            }

            // Check if user has credits
            if (userCredits < 1) {
                alert('Not enough on-hand credits! Transfer from secure credits first.');
                return;
            }

            // Place block
            baseBlocks.push({ x: gridX, y: gridY });
            await updateCredits(-1, 'onhand');
            await database.ref('players/' + currentUser.uid + '/baseBlocks').set(baseBlocks);

            document.getElementById('baseCredits').textContent = `Credits: ${secureCredits} (${userCredits} on hand)`;
        }

        async function handleBaseRightClick(e) {
            e.preventDefault();
            if (!basePlayer) return false;

            const rect = baseCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Convert screen coordinates to world coordinates
            const cameraX = basePlayer.x - baseCanvas.width / 2;
            const cameraY = basePlayer.y - baseCanvas.height / 2;
            const worldX = clickX + cameraX;
            const worldY = clickY + cameraY;

            // Snap to grid
            const gridX = Math.floor(worldX / 40) * 40;
            const gridY = Math.floor(worldY / 40) * 40;

            // Find and remove block
            const index = baseBlocks.findIndex(b => b.x === gridX && b.y === gridY);
            if (index === -1) {
                alert('No block here!');
                return false;
            }

            baseBlocks.splice(index, 1);
            await updateCredits(1, 'onhand');
            await database.ref('players/' + currentUser.uid + '/baseBlocks').set(baseBlocks);

            document.getElementById('baseCredits').textContent = `Credits: ${secureCredits} (${userCredits} on hand)`;

            return false;
        }

        // Leaderboard screen
        async function showLeaderboard() {
            showScreen('leaderboardScreen');

            // Fetch all players with their credits
            const playersSnapshot = await database.ref('players').once('value');
            const playersData = playersSnapshot.val();

            if (!playersData) {
                document.getElementById('leaderboardContent').innerHTML = '<p>No players found.</p>';
                return;
            }

            // Create array of players with secure credits
            const leaderboard = [];
            for (const [uid, playerData] of Object.entries(playersData)) {
                if (playerData.username) {
                    leaderboard.push({
                        uid: uid,
                        username: playerData.username,
                        secureCredits: playerData.secureCredits || 0
                    });
                }
            }

            // Sort by secure credits descending
            leaderboard.sort((a, b) => b.secureCredits - a.secureCredits);

            // Build HTML with player info sidebar
            let html = '<div style="display: flex; gap: 20px; height: 100%;">';

            // Left sidebar with player info
            html += `<div style="
                width: 250px;
                background: linear-gradient(135deg, rgba(79, 172, 254, 0.2), rgba(79, 172, 254, 0.05));
                border: 2px solid #4facfe;
                border-radius: 15px;
                padding: 25px;
                box-shadow: 0 8px 32px rgba(79, 172, 254, 0.3);
            ">
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="
                        width: 80px;
                        height: 80px;
                        background: ${menuPlayer ? menuPlayer.getSkinColor() : '#FF8C42'};
                        border: 4px solid #333;
                        border-radius: 10px;
                        margin: 0 auto 15px;
                        box-shadow: 0 4px 15px rgba(0,0,0,0.4);
                    "></div>
                    <div style="font-size: 20px; font-weight: bold; color: #fff; margin-bottom: 5px;">${currentUsername}</div>
                </div>

                <div style="
                    background: rgba(0,0,0,0.3);
                    border-radius: 10px;
                    padding: 15px;
                    margin-bottom: 15px;
                ">
                    <div style="color: #4facfe; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">Secure Credits</div>
                    <div style="font-size: 32px; font-weight: bold; color: #FFD700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);">${secureCredits}</div>
                </div>

                <div style="
                    background: rgba(0,0,0,0.3);
                    border-radius: 10px;
                    padding: 15px;
                ">
                    <div style="color: #4facfe; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">On Hand</div>
                    <div style="font-size: 24px; font-weight: bold; color: #aaa;">${userCredits}</div>
                </div>
            </div>`;

            // Right side with leaderboard
            html += '<div style="flex: 1; background: rgba(0,0,0,0.3); border-radius: 15px; padding: 25px; overflow-y: auto; max-height: 600px;">';

            for (let i = 0; i < Math.min(leaderboard.length, 50); i++) {
                const player = leaderboard[i];
                const isYou = player.uid === currentUser.uid;
                const rankColor = i === 0 ? '#FFD700' : i === 1 ? '#C0C0C0' : i === 2 ? '#CD7F32' : '#4facfe';
                const rankBg = i === 0 ? 'rgba(255, 215, 0, 0.1)' : i === 1 ? 'rgba(192, 192, 192, 0.1)' : i === 2 ? 'rgba(205, 127, 50, 0.1)' : 'rgba(79, 172, 254, 0.05)';

                html += `<div style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 15px 20px;
                    margin: 8px 0;
                    background: ${isYou ? 'rgba(79, 172, 254, 0.2)' : rankBg};
                    border-radius: 10px;
                    border-left: 5px solid ${rankColor};
                    transition: transform 0.2s, box-shadow 0.2s;
                    ${isYou ? 'box-shadow: 0 0 20px rgba(79, 172, 254, 0.5);' : ''}
                " onmouseover="this.style.transform='translateX(5px)'; this.style.boxShadow='0 4px 15px rgba(0,0,0,0.3)';" onmouseout="this.style.transform='translateX(0)'; this.style.boxShadow='none';">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <span style="
                            font-size: 24px;
                            font-weight: bold;
                            color: ${rankColor};
                            min-width: 40px;
                            text-align: center;
                        ">${i === 0 ? '' : i === 1 ? '' : i === 2 ? '' : (i + 1)}</span>
                        <span style="
                            color: white;
                            font-size: 18px;
                            ${isYou ? 'font-weight: bold; text-shadow: 0 0 10px rgba(79, 172, 254, 0.8);' : ''}
                        ">${player.username}${isYou ? ' ' : ''}</span>
                    </div>
                    <span style="
                        color: #FFD700;
                        font-weight: bold;
                        font-size: 20px;
                        text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
                    ">${player.secureCredits.toLocaleString()}</span>
                </div>`;
            }

            html += '</div></div>'; // Close leaderboard div and main flex container
            document.getElementById('leaderboardContent').innerHTML = html;
        }

        // Exit practice mode
        function exitPracticeMode() {
            practiceMode.active = false;
            document.getElementById('practiceCanvas').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('practiceBackBtn').style.display = 'none';
            initMainMenu();
        }

        // Screen management
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        function backToMainMenu() {
            // Clean up listeners
            if (currentPartyId) {
                database.ref('parties/' + currentPartyId).off();
            }
            if (currentLobbyId) {
                database.ref('lobbies/' + currentLobbyId).off();
            }

            currentPartyId = null;
            currentLobbyId = null;
            practiceMode.active = false;
            raceState.active = false;

            // Hide all screens
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('practiceCanvas').style.display = 'none';
            document.getElementById('raceCanvas').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('practiceBackBtn').style.display = 'none';
            document.getElementById('timer').style.display = 'none';
            document.getElementById('racePositions').style.display = 'none';

            // Show main menu
            initMainMenu();
        }

        // Keyboard handling
        document.addEventListener('keydown', (e) => {
            // Store both original key and lowercase for compatibility
            menuKeys[e.key] = true;
            menuKeys[e.key.toLowerCase()] = true;
            practiceMode.keys[e.key] = true;
            raceState.keys[e.key] = true;
            baseKeys[e.key] = true;
            baseKeys[e.key.toLowerCase()] = true;

            if (e.key === 'Escape') {
                if (practiceMode.active) {
                    exitPracticeMode();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            menuKeys[e.key] = false;
            menuKeys[e.key.toLowerCase()] = false;
            baseKeys[e.key] = false;
            baseKeys[e.key.toLowerCase()] = false;
            delete practiceMode.keys[e.key];
            delete raceState.keys[e.key];
        });

        // Initialize on auth
        auth.onAuthStateChanged(async (user) => {
            if (!user) {
                window.location.href = 'index.html';
            } else {
                currentUser = user;

                // Get username
                const userSnapshot = await database.ref('users/' + user.uid).once('value');
                const userData = userSnapshot.val();

                if (userData && userData.username) {
                    currentUsername = userData.username;
                } else {
                    currentUsername = user.email.split('@')[0];
                    await database.ref('users/' + user.uid).set({
                        username: currentUsername,
                        createdAt: firebase.database.ServerValue.TIMESTAMP
                    });
                }

                await initUserData();
                await initializeDefaultLevels();
                initMainMenu();
            }
        });
    </script>
</body>
</html>