<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Racers Online</title>
    <link rel="icon" type="image/png" id="favicon">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #2c2c2c;
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        canvas {
            border: 5px solid #4facfe;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(79, 172, 254, 0.4);
            background: #87CEEB;
        }

        .screen {
            display: none;
            position: absolute;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            backdrop-filter: blur(10px);
            color: white;
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #4facfe;
            text-align: center;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .screen.active {
            display: block;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #FFC107;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }

        h2 {
            font-size: 32px;
            margin: 20px 0;
            color: #4facfe;
        }

        button {
            padding: 15px 30px;
            font-size: 18px;
            margin: 10px;
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.3);
            font-weight: bold;
        }

        button:hover {
            background: linear-gradient(135deg, #6fd0ff, #20f5ff);
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.5);
        }

        button.secondary {
            background: linear-gradient(135deg, #666, #888);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        button.danger {
            background: linear-gradient(135deg, rgba(255,0,0,0.7), rgba(255,50,50,0.7));
            box-shadow: 0 4px 15px rgba(255, 0, 0, 0.3);
        }

        button.success {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        button:disabled {
            background: linear-gradient(135deg, #555, #777);
            color: #999;
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        button:disabled:hover {
            transform: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* Notification container */
        #notificationContainer {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .notification {
            background: linear-gradient(135deg, rgba(40, 40, 40, 0.95), rgba(60, 60, 60, 0.95));
            backdrop-filter: blur(10px);
            color: white;
            padding: 16px 24px;
            border-radius: 12px;
            border-left: 4px solid #4facfe;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            min-width: 300px;
            max-width: 400px;
            font-size: 16px;
            animation: slideIn 0.3s ease-out, fadeOut 0.3s ease-out 2.7s;
            pointer-events: auto;
        }

        .notification.error {
            border-left-color: #ff4444;
        }

        .notification.success {
            border-left-color: #4CAF50;
        }

        .notification.warning {
            border-left-color: #FFC107;
        }

        .notification.info {
            border-left-color: #4facfe;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        input, select {
            padding: 12px;
            font-size: 16px;
            margin: 10px;
            border-radius: 12px;
            border: 2px solid #4facfe;
            background: rgba(255,255,255,0.9);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #00f2fe;
            box-shadow: 0 4px 20px rgba(79, 172, 254, 0.4);
        }

        #creditPanel {
            position: absolute;
            top: 50%;
            left: calc(50% - 600px - 180px); /* Canvas is 1200px wide, center - half - panel spacing */
            transform: translateY(-50%);
            width: 160px;
            height: 800px;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            border: 3px solid #4facfe;
            border-radius: 15px;
            padding: 20px;
            z-index: 50;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #leaderboardPanel {
            position: absolute;
            top: 50%;
            right: calc(50% - 600px - 280px); /* Extended further right */
            transform: translateY(-50%);
            width: 260px; /* Increased from 160px */
            height: 800px;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            border: 3px solid #4facfe;
            border-radius: 15px;
            padding: 15px;
            z-index: 50;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
        }

        .cosmetic-item {
            background: rgba(0,0,0,0.4);
            padding: 15px;
            margin: 10px;
            border-radius: 12px;
            display: inline-block;
            min-width: 200px;
            border: 2px solid rgba(79, 172, 254, 0.3);
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .cosmetic-item:hover {
            border-color: #4facfe;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.4);
        }

        .cosmetic-item.owned {
            border: 2px solid #4facfe;
            background: rgba(79, 172, 254, 0.2);
        }

        .cosmetic-item.equipped {
            background: rgba(79, 172, 254, 0.3);
            border: 2px solid #FFC107;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #4facfe;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            display: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }

        #timer {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            z-index: 50;
            display: none;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            padding: 20px 40px;
            border-radius: 15px;
            border: 3px solid #4facfe;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            font-family: 'Courier New', monospace;
        }

        .party-member {
            background: rgba(0,0,0,0.4);
            padding: 12px;
            margin: 8px;
            border-radius: 12px;
            border: 2px solid rgba(79, 172, 254, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s;
        }

        .party-member:hover {
            border-color: #4facfe;
            transform: translateY(-2px);
        }

        .party-member.ready {
            background: rgba(0,255,0,0.2);
            border: 2px solid #0f0;
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.3);
        }

        .invitation {
            background: rgba(255,215,0,0.2);
            padding: 18px;
            margin: 10px;
            border-radius: 15px;
            border: 2px solid #FFC107;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
        }

        .platform-button {
            position: absolute;
            background: rgba(79, 172, 254, 0.3);
            border: 3px solid #4facfe;
            color: #4facfe;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
        }

        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            color: white;
            text-shadow: 5px 5px 10px rgba(0,0,0,0.9);
            z-index: 200;
            display: none;
            font-weight: bold;
        }

        .player-list {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
        }

        .shop-category {
            margin: 20px 0;
        }

        .cosmetics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .levels-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .level-card {
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            border: 2px solid #4facfe;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .level-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(79, 172, 254, 0.5);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
        }

        #menuCanvas {
            display: block;
        }

        .menu-hud {
            position: absolute;
            top: 20px;
            text-align: center;
            width: 100%;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            z-index: 10;
            pointer-events: none;
        }

        .menu-title {
            font-size: 64px;
            color: #FFC107;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .scroll-container {
            max-height: 60vh;
            overflow-y: auto;
            padding: 20px;
        }

        #raceResults {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 20px;
            z-index: 200;
            display: none;
            min-width: 400px;
        }

        .result-entry {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        .result-entry.winner {
            background: rgba(255,215,0,0.3);
            border: 2px solid gold;
        }

        #racePositions {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            z-index: 50;
            display: none;
        }
    </style>
</head>
<body>
    <!-- Notification Container -->
    <div id="notificationContainer"></div>

    <!-- Main Menu Canvas (Interactive Platformer) -->
    <canvas id="menuCanvas" width="1200" height="800"></canvas>
    <div class="menu-hud" id="menuHUD" style="display: none;">
    </div>

    <!-- Left Side Credit Panel -->
    <div id="creditPanel" style="display: none;"></div>

    <!-- Right Side Leaderboard Panel -->
    <div id="leaderboardPanel" style="display: none;">
        <div style="font-family: 'Inter', Arial, sans-serif; font-size: 18px; color: #fff; margin-bottom: 15px; text-align: center; font-weight: bold;">
            Credits Leaderboard
        </div>
        <div id="leaderboardList" style="font-family: 'Inter', Arial, sans-serif; font-size: 10px; color: #fff;">
        </div>
    </div>

    <!-- Practice Mode Canvas -->
    <canvas id="practiceCanvas" width="1200" height="800" style="display: none;"></canvas>
    <div id="hud"></div>
    <button id="practiceBackBtn" onclick="exitPracticeMode()" style="position: absolute; top: 20px; right: 20px; z-index: 100; display: none; padding: 10px 20px; background: rgba(255,0,0,0.7); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">Back to Menu</button>

    <!-- Race Canvas -->
    <canvas id="raceCanvas" width="1200" height="800" style="display: none;"></canvas>
    <div id="timer"></div>
    <div id="racePositions"></div>
    <div id="countdown"></div>

    <!-- Party Screen -->
    <div id="partyScreen" class="screen">
        <h1>Party</h1>
        <div id="partyInfo"></div>
        <div id="partyMembers" class="player-list"></div>
        <div id="partyInvitations"></div>
        <div style="margin-top: 20px;">
            <input type="text" id="inviteUsername" placeholder="Enter username to invite">
            <button onclick="sendInvite()">Send Invite</button>
        </div>
        <div id="partyControls" style="margin-top: 20px;"></div>
        <button onclick="leaveParty()" class="secondary">Leave Party</button>
        <button onclick="backToMainMenu()" class="secondary">Back to Menu</button>
    </div>

    <!-- Join Party Screen -->
    <div id="joinPartyScreen" class="screen">
        <h1>Join Party</h1>
        <input type="text" id="partyIdInput" placeholder="Enter Party ID">
        <button onclick="joinPartyById()">Join Party</button>
        <button onclick="backToMainMenu()" class="secondary">Back</button>
    </div>

    <!-- Lobby Screen -->
    <div id="lobbyScreen" class="screen">
        <h1>Race Lobby</h1>
        <div id="lobbyInfo"></div>
        <div id="lobbyPlayers" class="player-list"></div>
        <div id="lobbyControls"></div>
        <button onclick="leaveLobby()" class="secondary">Leave Lobby</button>
    </div>

    <!-- Shop Hub Screen (Portal Selection) -->
    <div id="shopHubScreen" class="screen">
        <canvas id="shopHubCanvas" width="1200" height="800" style="display: block; margin: 0 auto; background: #87CEEB;"></canvas>
        <div id="shopHubHUD" style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; color: white; font-size: 18px; text-align: center;">
            Use arrow keys to move, press SPACE to enter portal
        </div>
    </div>

    <!-- Cosmetics Shop Screen -->
    <div id="cosmeticsShopScreen" class="screen">
        <h1>Cosmetics Shop</h1>
        <div id="cosmeticsShopCredits" style="font-size: 24px; color: #FFC107; margin-bottom: 20px;"></div>
        <div class="scroll-container">
            <div id="cosmeticsShopContent"></div>
        </div>
        <button onclick="backToShopHub()">Back to Shop</button>
    </div>

    <!-- Backpack Shop Screen -->
    <div id="backpackShopScreen" class="screen">
        <h1>Backpack Shop</h1>
        <div id="backpackShopCredits" style="font-size: 24px; color: #FFC107; margin-bottom: 20px;"></div>
        <div class="scroll-container">
            <div id="backpackShopContent"></div>
        </div>
        <button onclick="backToShopHub()">Back to Shop</button>
    </div>

    <!-- Practice Levels Screen -->
    <div id="practiceLevelsScreen" class="screen">
        <canvas id="levelSelectCanvas" width="1200" height="800" style="display: block; margin: 0 auto; background: #87CEEB;"></canvas>
        <div id="levelSelectHUD" style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; color: white; font-size: 18px; text-align: center;">
            Use arrow keys to move, press SPACE to select level
        </div>
    </div>

    <!-- Stats Screen -->
    <div id="statsScreen" class="screen">
        <h1>Your Stats</h1>
        <div id="statsContent" style="font-size: 20px;"></div>
        <button onclick="backToMainMenu()">Back to Menu</button>
    </div>

    <!-- Base Screen -->
    <div id="baseScreen" class="screen">
        <h1>Your Base</h1>
        <div id="baseCredits" style="font-size: 24px; color: #FFC107; margin-bottom: 20px;"></div>
        <canvas id="baseCanvas" width="800" height="600" style="border: 3px solid #4facfe; border-radius: 10px;"></canvas>
        <div style="margin-top: 20px;">
            <p>Click/hold to place 40x40px blocks (costs 1 credit each)</p>
            <p>Click on existing blocks to add more credits (max 3 per block)</p>
            <p>Right-click/hold to remove ONE credit from blocks</p>
            <p>Mouse wheel to zoom, press G to reset zoom</p>
        </div>
        <button onclick="backToMainMenu()">Back to Menu</button>
    </div>

    <!-- Leaderboard Screen -->
    <div id="leaderboardScreen" class="screen">
        <canvas id="leaderboardCanvas" width="1200" height="800" style="display: block; margin: 0 auto; background: #87CEEB;"></canvas>
    </div>

    <!-- Leaderboard Detail Screen -->
    <div id="leaderboardDetailScreen" class="screen">
        <div class="scroll-container" style="padding-top: 20px;">
            <div id="leaderboardContent" style="max-width: 1000px; margin: 0 auto;"></div>
        </div>
        <button onclick="showLeaderboard()" style="margin-top: 20px;">Back to Selection</button>
    </div>

    <!-- Settings Screen -->
    <div id="settingsScreen" class="screen">
        <h1>Settings</h1>
        <div style="margin-top: 40px;">
            <button onclick="logout()" style="font-size: 24px; padding: 15px 30px; background: #ff4444; color: white; border: none; border-radius: 10px; cursor: pointer;">Logout</button>
        </div>
        <button onclick="backToMainMenu()" style="margin-top: 40px;">Back to Menu</button>
    </div>

    <!-- Backpack Screen -->
    <div id="backpackScreen" class="screen">
        <h1>Backpack</h1>
        <div style="margin-top: 20px;">
            <div style="font-size: 24px; font-weight: bold; color: #FFD700;">Credits: <span id="backpackCreditsCount">0</span> / <span id="backpackMaxSize">1</span></div>
        </div>
        <div id="backpackGrid" style="margin: 40px auto; display: inline-grid; gap: 5px; padding: 20px; background: rgba(0,0,0,0.3); border-radius: 10px; border: 3px solid #4facfe;"></div>
        <button onclick="closeBackpack()" style="margin-top: 40px;">Close Backpack</button>
    </div>

    <!-- Race Results -->
    <div id="raceResults">
        <h2>Race Complete!</h2>
        <div id="resultsContent"></div>
        <button onclick="returnToParty()" class="success">Return to Party</button>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

    <script>
        // Firebase configuration
        // Last updated: 2025-10-11 (cache bust)
        const firebaseConfig = {
            apiKey: "AIzaSyBLkFMipRS631fDNr8uwgozmxXBnqLd5_o",
            authDomain: "base-control-b391e.firebaseapp.com",
            databaseURL: "https://base-control-b391e-default-rtdb.firebaseio.com",
            projectId: "base-control-b391e",
            storageBucket: "base-control-b391e.firebasestorage.app",
            messagingSenderId: "116375376675",
            appId: "1:116375376675:web:cdc8688222c7c35accf296",
            measurementId: "G-JY7P6D49HM"
        };

        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const database = firebase.database();

        // Set auth persistence to SESSION - lasts until browser closes
        // Login page uses NONE to require re-login when visiting site
        auth.setPersistence(firebase.auth.Auth.Persistence.SESSION);

        // Create favicon
        const faviconCanvas = document.createElement('canvas');
        faviconCanvas.width = 32;
        faviconCanvas.height = 32;
        const faviconCtx = faviconCanvas.getContext('2d');
        faviconCtx.fillStyle = '#FF8C42';
        faviconCtx.fillRect(6, 6, 20, 20);
        faviconCtx.strokeStyle = '#333';
        faviconCtx.lineWidth = 2;
        faviconCtx.strokeRect(6, 6, 20, 20);
        document.getElementById('favicon').href = faviconCanvas.toDataURL('image/png');

        // Global variables
        let currentUser = null;
        let currentUsername = '';
        let userCredits = 0; // On-hand credits (stored in backpack)
        let secureCredits = 0; // Secure credits (stored at base, main credits display)
        let backpackSize = 1; // Max credits that can be held in backpack (1, 4, 9, 16, 25, 36, 49, 64, 81, 100)
        let backpackHoldProgress = 0; // Progress of holding E/H to open backpack (0-1)
        let backpackOpen = false; // Is backpack screen currently open?
        let userCosmetics = { skins: ['default_orange'], trails: ['none'], hats: ['none'], effects: ['none'] };
        let equippedCosmetics = { skin: 'default_orange', trail: 'none', hat: 'none', effect: 'none' };
        let equippedItem = 'none'; // Equippable item: 'none' or 'credits'
        let userStats = { racesWon: 0, racesPlayed: 0, totalCreditsEarned: 0 };

        let currentParty = null;
        let currentPartyId = null;
        let currentLobby = null;
        let currentLobbyId = null;

        // Jump state tracking
        let menuIsJumping = false;
        let practiceIsJumping = false;
        let raceIsJumping = false;

        // Game constants - TUNED VALUES
        const GRAVITY = 0.132; // Tuned for perfect feel
        const MOVE_SPEED = 0.45; // Tuned horizontal movement speed
        const GROUND_MAX_SPEED = 5.625; // Max speed on ground
        const AIR_MAX_SPEED = 7.0313; // Max speed in air (1.25x ground speed)
        const AIR_RESISTANCE = 0.88;
        const GROUND_FRICTION = 0.94;
        const GROUND_ACCELERATION = 0.15; // Gradual acceleration when grounded
        const JUMP_POWER = 5.13; // Tuned jump power for perfect height
        const FAST_FALL_MULTIPLIER = 3.5; // 1.75x stronger than before (was 2.0)
        const JUMP_CHARGE_RATE = 0.41; // Tuned charge rate for responsive variable jumps
        const MAX_JUMP_HOLD_TIME = 16.67; // Maximum time (ms) to hold jump button for max height

        // Game feel constants
        const COYOTE_TIME = 6; // Frames you can still jump after leaving platform
        const JUMP_BUFFER_TIME = 8; // Frames to remember jump input before landing
        const ACCELERATION = 0.5; // Smoother acceleration
        const DECELERATION = 0.8; // Smoother deceleration

        // Particle system
        class Particle {
            constructor(x, y, vx, vy, color, life, size = 4) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.size = size;
            }

            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.vy += GRAVITY * deltaTime * 0.5;
                this.life -= deltaTime;
            }

            draw(ctx, cameraX, cameraY) {
                const alpha = this.life / this.maxLife;
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                ctx.fillRect(screenX, screenY, this.size, this.size);
            }
        }

        let particles = [];

        function spawnParticles(x, y, count, color, playerSize = 40) {
            // Scale particle size based on player size (default 40px)
            const particleSize = Math.max(2, Math.floor(playerSize / 10));

            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 2 + 1;
                particles.push(new Particle(
                    x,
                    y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed - 1,
                    color,
                    30 + Math.random() * 20,
                    particleSize
                ));
            }
        }

        function updateAndDrawParticles(ctx, cameraX, cameraY, deltaTime) {
            // Update and draw all particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(deltaTime);
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                } else {
                    particles[i].draw(ctx, cameraX, cameraY);
                }
            }
        }

        // Cosmetics catalog
        const cosmeticsCatalog = {
            skins: [
                { id: 'default_orange', name: 'Default Orange', price: 0, color: '#FF8C42' },
                { id: 'red_racer', name: 'Red Racer', price: 50, color: '#FF0000' },
                { id: 'blue_blur', name: 'Blue Blur', price: 50, color: '#0066FF' },
                { id: 'green_machine', name: 'Green Machine', price: 100, color: '#00FF00' },
                { id: 'purple_pro', name: 'Purple Pro', price: 100, color: '#9900FF' },
                { id: 'golden_champion', name: 'Golden Champion', price: 500, color: '#FFD700' }
            ],
            trails: [
                { id: 'none', name: 'None', price: 0 },
                { id: 'rainbow', name: 'Rainbow Trail', price: 100 },
                { id: 'fire', name: 'Fire Trail', price: 150 },
                { id: 'ice', name: 'Ice Trail', price: 150 },
                { id: 'star', name: 'Star Trail', price: 200 }
            ],
            hats: [
                { id: 'none', name: 'None', price: 0 },
                { id: 'crown', name: 'Crown', price: 200 },
                { id: 'propeller', name: 'Propeller', price: 150 },
                { id: 'halo', name: 'Halo', price: 300 }
            ],
            effects: [
                { id: 'none', name: 'None', price: 0 },
                { id: 'sparkles', name: 'Sparkles', price: 100 },
                { id: 'glow', name: 'Glow', price: 150 },
                { id: 'shadow_clone', name: 'Shadow Clone', price: 300 }
            ]
        };

        // Map definitions (preserved from original)
        const maps = [
            {
                id: 'simple_map',
                name: 'Simple Map',
                difficulty: 'Easy',
                platforms: [
                    { x: -40, y: -280, width: 40, height: 320 },
                    { x: 0, y: -280, width: 280, height: 40 },
                    { x: 280, y: -280, width: 40, height: 320 },
                    { x: 0, y: 0, width: 280, height: 40 }
                ],
                hazards: [
                    { x: 120, y: -120, width: 40, height: 120 }
                ],
                growers: [],
                shrinkers: [],
                defaultSizeBlocks: [],
                start: { x: 0, y: -40, width: 40, height: 40 },
                finish: { x: 240, y: -40, width: 40, height: 40 }
            },
            {
                id: 'custom_level',
                name: 'Original Map',
                difficulty: 'Medium',
                platforms: [
                    { x: 0, y: 400, width: 40, height: 200 },
                    { x: 40, y: 560, width: 520, height: 40 },
                    { x: 240, y: 440, width: 80, height: 40 },
                    { x: 320, y: 320, width: 80, height: 40 },
                    { x: 240, y: 200, width: 80, height: 40 },
                    { x: 320, y: 80, width: 80, height: 40 },
                    { x: 160, y: -80, width: 360, height: 40 },
                    { x: 480, y: -40, width: 40, height: 480 },
                    { x: -240, y: 160, width: 400, height: 40 },
                    { x: -80, y: 40, width: 40, height: 160 },
                    { x: -160, y: -80, width: 320, height: 40 },
                    { x: -200, y: -80, width: 40, height: 200 },
                    { x: -320, y: 80, width: 120, height: 40 },
                    { x: -320, y: 120, width: 40, height: 240 },
                    { x: -240, y: 480, width: 40, height: 40 },
                    { x: 0, y: 720, width: 40, height: 40 },
                    { x: 160, y: 720, width: 40, height: 40 },
                    { x: 560, y: 320, width: 40, height: 280 },
                    { x: 160, y: 40, width: 80, height: 40 },
                    { x: 440, y: 680, width: 40, height: 40 },
                    { x: 600, y: 520, width: 240, height: 40 },
                    { x: 480, y: 640, width: 440, height: 40 },
                    { x: 920, y: 320, width: 40, height: 360 },
                    { x: 600, y: 320, width: 320, height: 40 },
                    { x: 320, y: 760, width: 120, height: 40 }
                ],
                hazards: [
                    { x: 200, y: 80, width: 40, height: 80 },
                    { x: 0, y: 360, width: 40, height: 40 },
                    { x: -520, y: 800, width: 1560, height: 80 }
                ],
                growers: [],
                shrinkers: [],
                defaultSizeBlocks: [],
                start: { x: 80, y: 480 },
                finish: { x: 700, y: 470, width: 100, height: 50 }
            },
            {
                id: 'hard_level',
                name: 'Hard Level',
                difficulty: 'Hard',
                platforms: [
                    { x: 40, y: -200, width: 240, height: 30 },
                    { x: 40, y: -170, width: 80, height: 30 },
                    { x: 200, y: -170, width: 80, height: 30 },
                    { x: -280, y: -410, width: 60, height: 90 },
                    { x: -280, y: -260, width: 60, height: 20 },
                    { x: -280, y: -120, width: 40, height: 40 },
                    { x: -200, y: -40, width: 40, height: 40 },
                    { x: 560, y: -400, width: 240, height: 80 },
                    { x: 400, y: -640, width: 160, height: 80 },
                    { x: 560, y: -800, width: 80, height: 80 },
                    { x: 240, y: -1040, width: 160, height: 80 },
                    { x: -80, y: 0, width: 115, height: 40 },
                    { x: 340, y: 20, width: 180, height: 20 },
                    { x: 360, y: 0, width: 160, height: 20 },
                    { x: 40, y: 100, width: 100, height: 20 },
                    { x: 160, y: 140, width: 80, height: 20 },
                    { x: 260, y: 80, width: 60, height: 20 },
                    { x: 320, y: -80, width: 20, height: 80 },
                    { x: 520, y: -120, width: 160, height: 40 },
                    { x: 640, y: -80, width: 40, height: 120 },
                    { x: 520, y: 0, width: 120, height: 40 }
                ],
                hazards: [
                    { x: 40, y: -320, width: 80, height: 120 },
                    { x: -80, y: -200, width: 40, height: 200 },
                    { x: 240, y: -1120, width: 80, height: 80 },
                    { x: -360, y: 280, width: 1280, height: 40 },
                    { x: 920, y: -1280, width: 40, height: 1600 },
                    { x: -360, y: -1280, width: 1280, height: 40 },
                    { x: -400, y: -1280, width: 40, height: 1600 }
                ],
                growers: [
                    { x: 80, y: -640, width: 80, height: 80 }
                ],
                shrinkers: [
                    { x: 80, y: -1200, width: 80, height: 80 }
                ],
                defaultSizeBlocks: [
                    { x: 520, y: -80, width: 40, height: 80 }
                ],
                start: { x: 0, y: -80, width: 40, height: 40 },
                finish: { x: 600, y: -80, width: 40, height: 80 }
            }
        ];

        // Player class for rendering
        class Player {
            constructor(x, y, cosmetics) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.velocityX = 0;
                this.velocityY = 0;
                this.cosmetics = cosmetics || { skin: 'default_orange', trail: 'none', hat: 'none', effect: 'none' };
                this.trail = [];
                this.currentSize = 40;

                // Game feel variables
                this.coyoteTimer = 0;
                this.jumpBufferTimer = 0;
                this.wasGrounded = false;

                // Size transition variables (from level creator)
                this.targetSize = 40;
                this.sizeTransitioning = false;
                this.sizeTransitionProgress = 0;
            }

            getSkinColor() {
                const skin = cosmeticsCatalog.skins.find(s => s.id === this.cosmetics.skin);
                return skin ? skin.color : '#FF8C42';
            }

            updateTrail() {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 10) {
                    this.trail.shift();
                }
            }

            draw(ctx, cameraX, cameraY, showName, name, isLocalPlayer = false) {
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;

                // Draw trail
                if (this.cosmetics.trail !== 'none' && this.trail.length > 1) {
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const alpha = i / this.trail.length;
                        const trailX = this.trail[i].x - cameraX;
                        const trailY = this.trail[i].y - cameraY;

                        ctx.globalAlpha = alpha * 0.5;

                        if (this.cosmetics.trail === 'rainbow') {
                            ctx.fillStyle = `hsl(${(i * 36) % 360}, 100%, 50%)`;
                        } else if (this.cosmetics.trail === 'fire') {
                            ctx.fillStyle = i % 2 === 0 ? '#FF6600' : '#FF0000';
                        } else if (this.cosmetics.trail === 'ice') {
                            ctx.fillStyle = i % 2 === 0 ? '#00FFFF' : '#FFFFFF';
                        } else if (this.cosmetics.trail === 'star') {
                            ctx.fillStyle = '#FFFF00';
                        }

                        ctx.fillRect(trailX, trailY, this.width, this.height);
                    }
                    ctx.restore();
                }

                // Draw effect (behind player)
                if (this.cosmetics.effect === 'glow') {
                    ctx.save();
                    ctx.shadowColor = this.getSkinColor();
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = this.getSkinColor();
                    ctx.fillRect(screenX, screenY, this.width, this.height);
                    ctx.restore();
                } else if (this.cosmetics.effect === 'shadow_clone') {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = this.getSkinColor();
                    ctx.fillRect(screenX - 10, screenY + 5, this.width, this.height);
                    ctx.restore();
                }

                // Draw player
                ctx.fillStyle = this.getSkinColor();
                ctx.fillRect(screenX, screenY, this.width, this.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX, screenY, this.width, this.height);

                // Draw hat
                if (this.cosmetics.hat === 'crown') {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(screenX + this.width / 2, screenY - 15);
                    ctx.lineTo(screenX + 5, screenY - 5);
                    ctx.lineTo(screenX + this.width - 5, screenY - 5);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.cosmetics.hat === 'propeller') {
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(screenX + 10, screenY - 10);
                    ctx.lineTo(screenX + this.width - 10, screenY - 10);
                    ctx.stroke();
                } else if (this.cosmetics.hat === 'halo') {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, screenY - 10, 15, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw sparkles effect
                if (this.cosmetics.effect === 'sparkles') {
                    ctx.fillStyle = '#FFFF00';
                    for (let i = 0; i < 5; i++) {
                        const angle = (Date.now() / 100 + i * 72) % 360;
                        const rad = angle * Math.PI / 180;
                        const sparkX = screenX + this.width / 2 + Math.cos(rad) * 30;
                        const sparkY = screenY + this.height / 2 + Math.sin(rad) * 30;
                        ctx.fillRect(sparkX - 2, sparkY - 2, 4, 4);
                    }
                }

                // Draw equipped item (credits display)
                if (equippedItem === 'credits' && userCredits > 0) {
                    // Small yellow square in center of character (1/4 size)
                    const creditSize = this.width / 4;
                    const creditX = screenX + (this.width - creditSize) / 2;
                    const creditY = screenY + (this.height - creditSize) / 2;
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(creditX, creditY, creditSize, creditSize);
                    ctx.strokeStyle = '#FFA500';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(creditX, creditY, creditSize, creditSize);
                }

                // Draw name
                if (showName && name) {
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';

                    if (isLocalPlayer) {
                        // Local player: use skin color with black outline
                        const nameX = screenX + this.width / 2;
                        const nameY = screenY - 10;

                        // Draw black outline (stroke)
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 3;
                        ctx.strokeText(name, nameX, nameY);

                        // Draw colored text (fill)
                        ctx.fillStyle = this.getSkinColor();
                        ctx.fillText(name, nameX, nameY);
                    } else {
                        // Other players: black text
                        ctx.fillStyle = '#000000';
                        ctx.fillText(name, screenX + this.width / 2, screenY - 10);
                    }
                }
            }
        }

        // Initialize user data
        async function initUserData() {
            if (!currentUser) return;

            const userRef = database.ref('players/' + currentUser.uid);
            const snapshot = await userRef.once('value');
            const data = snapshot.val();

            if (data) {
                userCredits = data.credits || 0;
                backpackSize = data.backpackSize || 1;
                userCosmetics = data.cosmetics || { skins: ['default_orange'], trails: ['none'], hats: ['none'], effects: ['none'] };
                equippedCosmetics = data.equippedCosmetics || { skin: 'default_orange', trail: 'none', hat: 'none', effect: 'none' };
                equippedItem = data.equippedItem || 'none';
                userStats = data.stats || { racesWon: 0, racesPlayed: 0, totalCreditsEarned: 0 };

                // Cap credits to backpack size
                if (userCredits > backpackSize) {
                    userCredits = backpackSize;
                }

                // Calculate secure credits from BASE blocks (sum of all credits in blocks)
                const baseBlocks = data.baseBlocks || [];
                secureCredits = baseBlocks.reduce((sum, block) => sum + (block.credits || 1), 0);

                // Update Firebase to match actual BASE block count
                await userRef.update({
                    secureCredits: secureCredits,
                    credits: userCredits,
                    backpackSize: backpackSize
                });
            } else {
                // Initialize new user
                secureCredits = 0;
                backpackSize = 1;
                await userRef.set({
                    username: currentUsername,
                    credits: 0,
                    secureCredits: 0,
                    backpackSize: 1,
                    cosmetics: userCosmetics,
                    equippedCosmetics: equippedCosmetics,
                    stats: userStats
                });
            }
        }

        // Recalculate secure credits from base blocks (source of truth)
        function recalcSecureCredits() {
            secureCredits = baseBlocks.reduce((sum, block) => sum + (block.credits || 1), 0);
            return secureCredits;
        }

        // Remove credits from base by taking from the topmost/rightmost blocks
        async function removeCreditsFromBase(amount) {
            let creditsToRemove = amount;

            while (creditsToRemove > 0 && baseBlocks.length > 0) {
                // Find the topmost (lowest y value) block, or if tied, the rightmost (highest x value)
                let topmostBlock = baseBlocks[0];
                let topmostIndex = 0;

                for (let i = 1; i < baseBlocks.length; i++) {
                    const block = baseBlocks[i];
                    // Topmost = lowest Y value (negative Y is up)
                    // If tied on Y, rightmost = highest X value
                    if (block.y < topmostBlock.y || (block.y === topmostBlock.y && block.x > topmostBlock.x)) {
                        topmostBlock = block;
                        topmostIndex = i;
                    }
                }

                // Remove one credit from this block
                if (topmostBlock.credits > 1) {
                    // Block has multiple credits, reduce by 1
                    topmostBlock.credits--;
                } else {
                    // Block has only 1 credit, remove the entire block
                    baseBlocks.splice(topmostIndex, 1);
                }

                creditsToRemove--;
            }

            // Save updated base blocks to Firebase
            await database.ref('players/' + currentUser.uid + '/baseBlocks').set(baseBlocks);

            // Recalculate secure credits from blocks
            recalcSecureCredits();

            // Update Firebase with new secure credits
            await database.ref('players/' + currentUser.uid).update({
                secureCredits: secureCredits
            });
        }

        // Update credits in Firebase
        async function updateCredits(amount, type = 'onhand') {
            if (type === 'onhand') {
                userCredits += amount;
                // Cap credits to backpack size
                if (userCredits > backpackSize) {
                    userCredits = backpackSize;
                }
                // Don't allow negative credits
                if (userCredits < 0) {
                    userCredits = 0;
                }
            } else if (type === 'secure') {
                // SECURE credits are ONLY stored in base blocks, not as a separate value
                // This parameter is now ignored - secure credits come from blocks only
                console.warn('updateCredits called with type="secure" - secure credits are calculated from base blocks only');
                return;
            }

            if (amount > 0) {
                userStats.totalCreditsEarned += amount;
            }

            // Recalculate secure credits from blocks before saving
            recalcSecureCredits();

            await database.ref('players/' + currentUser.uid).update({
                credits: userCredits,
                secureCredits: secureCredits,
                stats: userStats
            });
        }

        async function transferCredits(amount, fromType, toType) {
            if (fromType === 'onhand' && userCredits >= amount) {
                // Transfer onhand → secure: Add blocks to base
                userCredits -= amount;
                // Don't modify secureCredits directly - it's calculated from blocks
                console.log(`Transfer ${amount} from onhand to secure - blocks should be added in base mode`);
            } else if (fromType === 'secure' && secureCredits >= amount) {
                // Transfer secure → onhand: Remove blocks from base
                // Don't modify secureCredits directly - it's calculated from blocks
                userCredits += amount;
                console.log(`Transfer ${amount} from secure to onhand - blocks should be removed in base mode`);
            } else {
                return false; // Insufficient funds
            }

            // Recalculate secure credits from blocks before saving
            recalcSecureCredits();

            await database.ref('players/' + currentUser.uid).update({
                credits: userCredits,
                secureCredits: secureCredits
            });
            return true;
        }

        // Main menu (interactive platformer)
        let menuPlayer = null;
        let menuKeys = {};
        let menuPlatforms = [];
        let menuCameraX = 0;
        let menuCameraY = 0;
        let menuLoopRunning = false;

        async function loadMiniLeaderboard() {
            try {
                // Fetch ALL players
                const playersSnapshot = await database.ref('players').once('value');
                const players = [];

                playersSnapshot.forEach(child => {
                    const data = child.val();
                    const secureCredits = data.secureCredits || 0;
                    const onhandCredits = data.credits || 0;
                    const totalCredits = secureCredits + onhandCredits;

                    players.push({
                        username: data.username || 'Unknown',
                        totalCredits: totalCredits,
                        secureCredits: secureCredits,
                        onhandCredits: onhandCredits
                    });
                });

                // Sort by total credits descending
                players.sort((a, b) => b.totalCredits - a.totalCredits);

                // Build leaderboard HTML
                let html = '';
                for (let i = 0; i < players.length; i++) {
                    const player = players[i];
                    const isCurrentUser = player.username === currentUsername;
                    html += `<div style="padding: 8px 4px; ${isCurrentUser ? 'background: rgba(79, 172, 254, 0.3); border-radius: 5px;' : ''} display: flex; justify-content: space-between; align-items: center;">
                        <div style="font-size: 16px; font-weight: bold;">${i + 1}. ${player.username}</div>
                        <div style="font-size: 16px; color: #FFD700; font-weight: bold;">${player.totalCredits}</div>
                    </div>`;
                }

                document.getElementById('leaderboardList').innerHTML = html;
            } catch (error) {
                console.error('Error loading leaderboard:', error);
                document.getElementById('leaderboardList').innerHTML = '<div style="font-size: 9px;">Error loading</div>';
            }
        }

        function initMainMenu() {
            try {
                console.log('initMainMenu: Starting initialization...');
                const canvas = document.getElementById('menuCanvas');
                const ctx = canvas.getContext('2d');

                if (!canvas) {
                    throw new Error('menuCanvas element not found!');
                }

                console.log('initMainMenu: Setting canvas display...');
                canvas.style.display = 'block';
                document.getElementById('menuHUD').style.display = 'block';

            // Portal platforms: 3 stacks (left: 3, middle: 4, right: 3) with 80px spacing
            // All platforms are 120px wide, 40px tall, stacked with 80px gap between them

            const leftX = 200;   // Left stack X position
            const middleX = 540; // Middle stack X position (centered at 600)
            const rightX = 880;  // Right stack X position
            const middleBottomY = 600; // Middle stack bottom (EARN MODE)
            const sideBottomY = middleBottomY - 40; // Side stacks 40px higher
            const spacing = 120; // 40px platform + 80px gap = 120px total spacing
            const groundY = middleBottomY + 120; // Ground 120px below EARN MODE

            menuPlatforms = [
                // Boundary walls - thick floor (80px), side walls (40px), ceiling (40px)
                { x: 0, y: 0, width: 40, height: 800, label: '', action: 'none' }, // Left wall (40px wide)
                { x: 1160, y: 0, width: 40, height: 800, label: '', action: 'none' }, // Right wall (40px wide)
                { x: 0, y: 0, width: 1200, height: 40, label: '', action: 'none' }, // Ceiling (40px thick)
                { x: 0, y: 720, width: 1200, height: 80, label: '', action: 'none' },  // Ground (80px thick - twice as thick)

                // LEFT STACK (3 portals) - 40px higher than middle
                { x: leftX, y: sideBottomY, width: 120, height: 40, label: 'BASE', action: 'base' },
                { x: leftX, y: sideBottomY - spacing, width: 120, height: 40, label: 'VIEW STATS', action: 'stats' },
                { x: leftX, y: sideBottomY - spacing * 2, width: 120, height: 40, label: 'SHOP', action: 'shop' },

                // MIDDLE STACK (4 portals)
                { x: middleX, y: middleBottomY, width: 120, height: 40, label: 'EARN MODE', action: 'practice' },
                { x: middleX, y: middleBottomY - spacing, width: 120, height: 40, label: 'LEVELS', action: 'practiceLevels' },
                { x: middleX, y: middleBottomY - spacing * 2, width: 120, height: 40, label: 'CREATE PARTY', action: 'createParty' },
                { x: middleX, y: middleBottomY - spacing * 3, width: 120, height: 40, label: 'JOIN PARTY', action: 'joinParty' },

                // RIGHT STACK (3 portals) - 40px higher than middle
                { x: rightX, y: sideBottomY, width: 120, height: 40, label: 'LEVEL CREATOR', action: 'creator' },
                { x: rightX, y: sideBottomY - spacing, width: 120, height: 40, label: 'LEADERBOARD', action: 'leaderboard' },
                { x: rightX, y: sideBottomY - spacing * 2, width: 120, height: 40, label: 'SETTINGS', action: 'settings' }
            ];

            // Spawn player on ground platform, centered
            const spawnX = 600 - 20; // Center X (600) - half player width (20)
            const spawnY = groundY - 40; // On top of ground platform
            menuPlayer = new Player(spawnX, spawnY, equippedCosmetics);

            // Center camera on player
            menuCameraX = spawnX + 20 - 600; // Player center - half canvas width
            menuCameraY = spawnY + 20 - 400; // Player center - half canvas height

            // Populate and show credit panel with player preview
            const skinData = cosmeticsCatalog.skins.find(s => s.id === equippedCosmetics.skin);
            const playerColor = skinData ? skinData.color : '#FF8C42';
            document.getElementById('creditPanel').innerHTML = `
                <div style="font-family: 'Inter', Arial, sans-serif; color: #fff; text-align: center; width: 100%;">
                    <div style="width: 100px; height: 100px; background: ${playerColor}; border: 4px solid #333; border-radius: 12px; margin: 0 auto 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); position: relative;">
                        ${equippedItem === 'credits' && userCredits > 0 ? `
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 25px; height: 25px; background: #FFD700; border: 2px solid #FFA500;"></div>
                        ` : ''}
                    </div>
                    <div style="font-weight: bold; font-size: 16px; margin-bottom: 20px;">${currentUsername}</div>
                    <div style="background: rgba(0,0,0,0.5); border-radius: 12px; padding: 15px; margin-bottom: 12px; border: 2px solid rgba(255, 215, 0, 0.3);">
                        <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; color: #4facfe;">Secure Credits</div>
                        <div style="font-size: 32px; font-weight: bold; color: #FFD700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);">${secureCredits.toLocaleString()}</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.5); border-radius: 12px; padding: 12px; border: 2px solid rgba(170, 170, 170, 0.2);">
                        <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; color: #4facfe;">On Hand</div>
                        <div style="font-size: 22px; font-weight: bold; color: #bbb; text-shadow: 0 0 8px rgba(187, 187, 187, 0.4);">${userCredits.toLocaleString()}</div>
                    </div>
                </div>
            `;
            document.getElementById('creditPanel').style.display = 'block';

            // Populate and show leaderboard panel
            loadMiniLeaderboard();
            document.getElementById('leaderboardPanel').style.display = 'block';

            // Auto-refresh leaderboard every 5 seconds
            const leaderboardRefreshInterval = setInterval(() => {
                if (canvas.style.display !== 'none') {
                    loadMiniLeaderboard();
                } else {
                    clearInterval(leaderboardRefreshInterval);
                }
            }, 5000);

            // Game loop with delta time
            let lastMenuFrameTime = performance.now();
            function menuLoop(currentTime) {
                if (canvas.style.display === 'none') {
                    menuLoopRunning = false;
                    return;
                }

                // Calculate delta time (normalize to 60fps baseline)
                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastMenuFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1; // Clamp deltaTime
                lastMenuFrameTime = currentTime;

                // Update player physics
                updateMenuPlayer(deltaTime);

                // Render
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw background 40x40px gridlines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;

                // Vertical lines
                const startX = Math.floor(menuCameraX / 40) * 40;
                for (let x = startX; x < menuCameraX + canvas.width; x += 40) {
                    const screenX = x - menuCameraX;
                    ctx.beginPath();
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, canvas.height);
                    ctx.stroke();
                }

                // Horizontal lines
                const startY = Math.floor(menuCameraY / 40) * 40;
                for (let y = startY; y < menuCameraY + canvas.height; y += 40) {
                    const screenY = y - menuCameraY;
                    ctx.beginPath();
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(canvas.width, screenY);
                    ctx.stroke();
                }

                // Draw platforms
                for (const platform of menuPlatforms) {
                    const screenX = platform.x - menuCameraX;
                    const screenY = platform.y - menuCameraY;

                    if (platform.label) {
                        // Gradient background for platform buttons
                        const gradient = ctx.createLinearGradient(screenX, screenY, screenX, screenY + platform.height);
                        gradient.addColorStop(0, 'rgba(79, 172, 254, 0.5)');
                        gradient.addColorStop(1, 'rgba(79, 172, 254, 0.2)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);

                        // Glowing border (inside edge)
                        ctx.shadowColor = '#4facfe';
                        ctx.shadowBlur = 15;
                        ctx.strokeStyle = '#4facfe';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(screenX + 2, screenY + 2, platform.width - 4, platform.height - 4);
                        ctx.shadowBlur = 0;

                        // Text with shadow
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = 'rgba(0,0,0,0.5)';
                        ctx.shadowBlur = 5;
                        ctx.fillText(platform.label, screenX + platform.width / 2, screenY + platform.height / 2 + 5);
                        ctx.shadowBlur = 0;
                    } else {
                        // Green platform - standardized
                        ctx.fillStyle = '#4CAF50';
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);

                        // Thicker dark border (inside edge)
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(screenX + 2, screenY + 2, platform.width - 4, platform.height - 4);

                        // Inner 40x40 grid lines
                        ctx.strokeStyle = '#388E3C';
                        ctx.lineWidth = 1;
                        for (let gx = 40; gx < platform.width; gx += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX + gx, screenY);
                            ctx.lineTo(screenX + gx, screenY + platform.height);
                            ctx.stroke();
                        }
                        for (let gy = 40; gy < platform.height; gy += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY + gy);
                            ctx.lineTo(screenX + platform.width, screenY + gy);
                            ctx.stroke();
                        }
                    }
                }

                // Draw particles
                updateAndDrawParticles(ctx, menuCameraX, menuCameraY, deltaTime);

                // Draw player
                menuPlayer.updateTrail();
                menuPlayer.draw(ctx, menuCameraX, menuCameraY, false);

                // Draw backpack hold progress circle above player
                if (backpackHoldProgress > 0) {
                    const playerScreenX = menuPlayer.x - menuCameraX;
                    const playerScreenY = menuPlayer.y - menuCameraY;
                    const circleX = playerScreenX + menuPlayer.width / 2;
                    const circleY = playerScreenY - 30; // Above player
                    const radius = 15;

                    // Background circle (empty)
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(circleX, circleY, radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Progress arc (fills clockwise from top)
                    ctx.strokeStyle = '#4facfe';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(circleX, circleY, radius, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * backpackHoldProgress));
                    ctx.stroke();

                    // Backpack icon in center
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('🎒', circleX, circleY);
                }

                requestAnimationFrame(menuLoop);
            }

            console.log('initMainMenu: Starting menu loop...');
            if (!menuLoopRunning) {
                menuLoopRunning = true;
                menuLoop();
            }
            console.log('initMainMenu: Initialization complete!');
            } catch (error) {
                console.error('ERROR in initMainMenu:', error);
                console.error('Error stack:', error.stack);
                alert('Error initializing main menu: ' + error.message);
            }
        }

        function updateMenuPlayer(deltaTime = 1) {
            // Check current grounded state BEFORE applying physics
            // Check if player is standing on a platform (touching from above)
            let isGrounded = false;
            let standingOnPlatform = null;
            for (const platform of menuPlatforms) {
                // Check if player is directly above platform
                const onTop = menuPlayer.y + menuPlayer.height >= platform.y &&
                              menuPlayer.y + menuPlayer.height <= platform.y + 5;
                const horizontalOverlap = menuPlayer.x + menuPlayer.width > platform.x &&
                                         menuPlayer.x < platform.x + platform.width;

                if (onTop && horizontalOverlap) {
                    isGrounded = true;
                    standingOnPlatform = platform;
                    break;
                }
            }

            menuPlayer.wasGrounded = isGrounded;

            // Check for platform interaction when standing on action platform
            if (standingOnPlatform && standingOnPlatform.action && standingOnPlatform.action !== 'none') {
                if (menuKeys[' ']) {
                    executePlatformAction(standingOnPlatform.action);
                }
            }

            // Backpack hold mechanic (E or H key)
            if (menuKeys['e'] || menuKeys['h']) {
                backpackHoldProgress += deltaTime * 0.02; // Takes ~50 frames (0.8 seconds) to fill
                if (backpackHoldProgress >= 1) {
                    backpackHoldProgress = 0;
                    menuKeys['e'] = false;
                    menuKeys['h'] = false;
                    openBackpack();
                }
            } else {
                backpackHoldProgress = Math.max(0, backpackHoldProgress - deltaTime * 0.05); // Decay faster when not holding
            }

            // Apply gravity with fast fall (scaled by size)
            const sizeScale = menuPlayer.currentSize / 40;
            if ((menuKeys['s'] || menuKeys['ArrowDown']) && !isGrounded) {
                menuPlayer.velocityY += GRAVITY * sizeScale * FAST_FALL_MULTIPLIER * deltaTime;
            } else {
                menuPlayer.velocityY += GRAVITY * sizeScale * deltaTime;
            }

            // Handle input (movement scaled by size)
            const scaledMoveSpeed = MOVE_SPEED * sizeScale;
            if (menuKeys['a'] || menuKeys['ArrowLeft']) {
                menuPlayer.velocityX -= scaledMoveSpeed * deltaTime;
            }
            if (menuKeys['d'] || menuKeys['ArrowRight']) {
                menuPlayer.velocityX += scaledMoveSpeed * deltaTime;
            }

            // Old action-based particle system
            // Track movement state for movement start particles
            const wasMovingLeft = menuPlayer.prevVelocityX !== undefined && menuPlayer.prevVelocityX < -0.5;
            const wasMovingRight = menuPlayer.prevVelocityX !== undefined && menuPlayer.prevVelocityX > 0.5;
            const isMovingLeft = menuPlayer.velocityX < -0.5;
            const isMovingRight = menuPlayer.velocityX > 0.5;

            // White particles on movement START (when starting to move from stopped/opposite direction)
            if (isMovingLeft && !wasMovingLeft && Math.random() < 0.3) {
                spawnParticles(menuPlayer.x + menuPlayer.width / 2, menuPlayer.y + menuPlayer.height / 2, 2, 'rgb(255, 255, 255)', menuPlayer.currentSize);
            }
            if (isMovingRight && !wasMovingRight && Math.random() < 0.3) {
                spawnParticles(menuPlayer.x + menuPlayer.width / 2, menuPlayer.y + menuPlayer.height / 2, 2, 'rgb(255, 255, 255)', menuPlayer.currentSize);
            }

            // Orange speed-based particles (when moving fast horizontally)
            const speed = Math.abs(menuPlayer.velocityX);
            if (speed > 0.5) {
                const particleChance = Math.min(speed / 10, 0.8);
                if (Math.random() < particleChance) {
                    const particleCount = Math.floor(speed / 2);
                    spawnParticles(menuPlayer.x + menuPlayer.width / 2, menuPlayer.y + menuPlayer.height / 2, particleCount, 'rgb(255, 140, 66)', menuPlayer.currentSize);
                }
            }

            // Store current velocity for next frame
            menuPlayer.prevVelocityX = menuPlayer.velocityX;

            // Jump with variable height based on hold time (W or Up Arrow only, NOT space)
            if ((menuKeys['w'] || menuKeys['ArrowUp']) && isGrounded && !menuIsJumping) {
                // Start jump immediately with strong initial velocity
                const sizeScale = menuPlayer.currentSize / 40;
                menuPlayer.velocityY = -1.5 * sizeScale; // Strong initial jump
                menuIsJumping = true;
                menuPlayer.jumpHoldTime = 0;
                // White jump particles
                spawnParticles(menuPlayer.x + menuPlayer.width / 2, menuPlayer.y + menuPlayer.height, 12, 'rgb(255, 255, 255)', menuPlayer.currentSize);
            }

            // Continue adding upward velocity while holding button (extends jump height)
            if (menuIsJumping && (menuKeys['w'] || menuKeys['ArrowUp']) && menuPlayer.velocityY < 0 && menuPlayer.jumpHoldTime < MAX_JUMP_HOLD_TIME) {
                const sizeScale = menuPlayer.currentSize / 40;
                menuPlayer.jumpHoldTime += deltaTime;

                // Add upward acceleration while holding (max height = 4x playerSize + 1px)
                const maxJumpVelocity = JUMP_POWER * sizeScale;
                if (Math.abs(menuPlayer.velocityY) < maxJumpVelocity && menuPlayer.jumpHoldTime < MAX_JUMP_HOLD_TIME) {
                    menuPlayer.velocityY -= JUMP_CHARGE_RATE * sizeScale * deltaTime;
                }
            }

            // Stop adding velocity when button released
            if (menuIsJumping && (!menuKeys['w'] && !menuKeys['ArrowUp'])) {
                menuIsJumping = false;
            }

            // Stop jump when time limit exceeded
            if (menuIsJumping && menuPlayer.jumpHoldTime >= MAX_JUMP_HOLD_TIME) {
                menuIsJumping = false;
            }

            // Reset jump state when grounded
            if (isGrounded && menuPlayer.velocityY >= 0) {
                menuIsJumping = false;
            }

            // Fast-fall particles (white) - spawn when holding down/S in air
            if ((menuKeys['s'] || menuKeys['ArrowDown']) && !isGrounded && menuPlayer.velocityY > 0) {
                // Spawn particles continuously during fast fall
                if (Math.random() < 0.3) { // 30% chance each frame for smooth particle trail
                    spawnParticles(menuPlayer.x + menuPlayer.width / 2, menuPlayer.y, 3, 'rgb(255, 255, 255)', menuPlayer.currentSize);
                }
            }

            // Apply friction using exponential decay
            if (isGrounded) {
                menuPlayer.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                menuPlayer.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Cap vertical velocity to prevent tunneling (scaled by size)
            const maxFallSpeed = 8 * sizeScale;
            menuPlayer.velocityY = Math.min(menuPlayer.velocityY, maxFallSpeed);

            // Limit horizontal speed (scaled by size)
            const scaledMaxSpeed = GROUND_MAX_SPEED * sizeScale;
            menuPlayer.velocityX = Math.max(-scaledMaxSpeed, Math.min(scaledMaxSpeed, menuPlayer.velocityX));

            // Update position HORIZONTALLY first, then check X collisions
            menuPlayer.x += menuPlayer.velocityX * deltaTime;

            // Check horizontal collisions
            for (const platform of menuPlatforms) {
                if (checkCollision(menuPlayer, platform)) {
                    if (menuPlayer.velocityX > 0) {
                        // Moving right, hit left side of platform
                        menuPlayer.x = platform.x - menuPlayer.width;
                    } else if (menuPlayer.velocityX < 0) {
                        // Moving left, hit right side of platform
                        menuPlayer.x = platform.x + platform.width;
                    }
                    menuPlayer.velocityX = 0;
                }
            }

            // Update position VERTICALLY, then check Y collisions
            menuPlayer.y += menuPlayer.velocityY * deltaTime;

            // Check vertical collisions
            for (const platform of menuPlatforms) {
                if (checkCollision(menuPlayer, platform)) {
                    if (menuPlayer.velocityY > 0) {
                        // Moving down, hit top of platform
                        // Cyan landing particles if falling with significant velocity
                        if (menuPlayer.velocityY > 2) {
                            spawnParticles(menuPlayer.x + menuPlayer.width / 2, menuPlayer.y + menuPlayer.height, 8, 'rgb(255, 255, 255)', menuPlayer.currentSize);
                        }
                        menuPlayer.y = platform.y - menuPlayer.height;
                        menuPlayer.velocityY = 0;
                    } else if (menuPlayer.velocityY < 0) {
                        // Moving up, hit bottom of platform
                        menuPlayer.y = platform.y + platform.height;
                        menuPlayer.velocityY = 0;
                        menuIsJumping = false;
                    }
                }
            }

            // Keep player in bounds (but allow vertical movement)
            if (menuPlayer.x < 0) menuPlayer.x = 0;
            if (menuPlayer.x > 1200 - menuPlayer.width) menuPlayer.x = 1200 - menuPlayer.width;

            // Respawn if fall too far
            if (menuPlayer.y > 1500) {
                menuPlayer.x = 600 - 20;
                menuPlayer.y = 720 - 40;
                menuPlayer.velocityX = 0;
                menuPlayer.velocityY = 0;
            }

            // Keep camera fixed (do not follow player on home page)
            menuCameraX = 0;
            menuCameraY = 0;
        }

        function checkCollision(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

        function executePlatformAction(action) {
            document.getElementById('menuCanvas').style.display = 'none';
            document.getElementById('menuHUD').style.display = 'none';
            document.getElementById('creditPanel').style.display = 'none';
            document.getElementById('leaderboardPanel').style.display = 'none';

            switch(action) {
                case 'practice':
                    startPracticeMode();
                    break;
                case 'practiceLevels':
                    showPracticeLevels();
                    break;
                case 'createParty':
                    createParty();
                    break;
                case 'joinParty':
                    showScreen('joinPartyScreen');
                    break;
                case 'shop':
                    showShop();
                    break;
                case 'stats':
                    showStats();
                    break;
                case 'creator':
                    window.location.href = 'creator.html';
                    break;
                case 'base':
                    showBase();
                    break;
                case 'leaderboard':
                    showLeaderboard();
                    break;
                case 'settings':
                    showSettings();
                    break;
            }
        }

        // Level selection variables
        let levelSelectActive = false;
        let levelSelectPlayer = null;
        let levelSelectPlatforms = [];
        let levelSelectKeys = {};
        let availableLevels = [];
        let playerBestTimes = {};
        let levelSelectIsJumping = false;

        // Shop hub variables
        let shopHubActive = false;
        let shopHubPlayer = null;
        let shopHubPlatforms = [];
        let shopHubKeys = {};
        let shopHubIsJumping = false;

        async function showPracticeLevels() {
            try {
                showScreen('practiceLevelsScreen');
                levelSelectActive = true;

                const canvas = document.getElementById('levelSelectCanvas');
                const ctx = canvas.getContext('2d');

                // Load all levels from Firebase
                const levelsSnapshot = await database.ref('levels').once('value');
                const levelsData = levelsSnapshot.val();

            availableLevels = [];
            if (levelsData) {
                Object.entries(levelsData).forEach(([levelId, levelInfo]) => {
                    availableLevels.push({
                        id: levelId,
                        name: levelInfo.name || levelId,
                        createdAt: levelInfo.createdAt || 0
                    });
                });
                // Sort by creation date (oldest first)
                availableLevels.sort((a, b) => a.createdAt - b.createdAt);
            }

            // Load player's best times
            const timesSnapshot = await database.ref('times_history/' + currentUser.uid).once('value');
            playerBestTimes = {};
            timesSnapshot.forEach((levelSnapshot) => {
                const levelId = levelSnapshot.key;
                let bestTime = Infinity;
                levelSnapshot.forEach((timeSnapshot) => {
                    const timeData = timeSnapshot.val();
                    if (timeData.time < bestTime) {
                        bestTime = timeData.time;
                    }
                });
                if (bestTime !== Infinity) {
                    playerBestTimes[levelId] = bestTime;
                }
            });

            // Create platformer-style layout like main menu
            // Portal platforms: 120px wide, 40px tall, stacked with 80px gap (120px total spacing)
            const spacing = 120; // 40px platform + 80px gap
            const portalWidth = 120;
            const portalHeight = 40;

            // Calculate how many levels per column (max 4)
            const levelsPerColumn = 4;
            const numColumns = Math.ceil(availableLevels.length / levelsPerColumn);

            // Center the columns perfectly
            const columnSpacing = 200; // Horizontal space between columns
            const totalWidth = (numColumns - 1) * columnSpacing + portalWidth;
            const startX = (1200 - totalWidth) / 2; // Perfectly centered

            const groundY = 720;
            const bottomPortalY = groundY - 120; // 120px above ground

            levelSelectPlatforms = [
                // Boundary walls - thick floor (80px), side walls (40px), ceiling (40px)
                { x: 0, y: 0, width: 40, height: 800 }, // Left wall (40px wide)
                { x: 1160, y: 0, width: 40, height: 800 }, // Right wall (40px wide)
                { x: 0, y: 0, width: 1200, height: 40 }, // Ceiling (40px thick)
                { x: 0, y: 720, width: 1200, height: 80 }, // Ground (80px thick - twice as thick)
            ];

            // Add "Back to Menu" portal (dark blue) on the left
            levelSelectPlatforms.push({
                x: 100,
                y: bottomPortalY,
                width: portalWidth,
                height: portalHeight,
                action: 'back',
                label: 'BACK TO MENU'
            });

            // Create portal platforms for each level
            availableLevels.forEach((level, index) => {
                const columnIndex = Math.floor(index / levelsPerColumn);
                const rowIndex = index % levelsPerColumn;

                const x = startX + columnIndex * columnSpacing;
                const y = bottomPortalY - (rowIndex * spacing);

                levelSelectPlatforms.push({
                    x: x,
                    y: y,
                    width: portalWidth,
                    height: portalHeight,
                    levelId: level.id,
                    levelName: level.name
                });
            });

            // Create player on ground
            const spawnX = 600 - 20; // Center
            const spawnY = groundY - 40; // On top of ground
            levelSelectPlayer = new Player(spawnX, spawnY, equippedCosmetics);

            // Start render loop
            let lastFrameTime = performance.now();
            function levelSelectLoop(currentTime) {
                if (!levelSelectActive) return;

                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                lastFrameTime = currentTime;

                updateLevelSelect(deltaTime);
                renderLevelSelect(ctx, deltaTime);

                requestAnimationFrame(levelSelectLoop);
            }
            levelSelectLoop();
            } catch (error) {
                console.error('Error loading practice levels:', error);
                alert('Error loading practice levels. Please try again.');
                backToMainMenu();
            }
        }

        function updateLevelSelect(deltaTime) {
            if (!levelSelectPlayer) return;

            // STEP 1: Calculate grounded state BEFORE physics (matches main menu)
            let isGrounded = false;
            let standingOnPlatform = null;

            for (const platform of levelSelectPlatforms) {
                const onTop = levelSelectPlayer.y + levelSelectPlayer.height >= platform.y &&
                              levelSelectPlayer.y + levelSelectPlayer.height <= platform.y + 5;
                const horizontalOverlap = levelSelectPlayer.x + levelSelectPlayer.width > platform.x &&
                                         levelSelectPlayer.x < platform.x + platform.width;

                if (onTop && horizontalOverlap) {
                    isGrounded = true;
                    standingOnPlatform = platform;
                    break;
                }
            }

            // STEP 2: Apply gravity with fast fall (scaled by size) - MATCHES MAIN MENU
            const sizeScale = levelSelectPlayer.currentSize / 40;
            if ((levelSelectKeys['s'] || levelSelectKeys['ArrowDown']) && !isGrounded) {
                levelSelectPlayer.velocityY += GRAVITY * sizeScale * FAST_FALL_MULTIPLIER * deltaTime;
            } else {
                levelSelectPlayer.velocityY += GRAVITY * sizeScale * deltaTime;
            }

            // STEP 3: Handle input (movement scaled by size)
            const scaledMoveSpeed = MOVE_SPEED * sizeScale;
            if (levelSelectKeys['a'] || levelSelectKeys['ArrowLeft']) {
                levelSelectPlayer.velocityX -= scaledMoveSpeed * deltaTime;
            }
            if (levelSelectKeys['d'] || levelSelectKeys['ArrowRight']) {
                levelSelectPlayer.velocityX += scaledMoveSpeed * deltaTime;
            }

            // Old action-based particle system
            // Track movement state for movement start particles
            const wasMovingLeft = levelSelectPlayer.prevVelocityX !== undefined && levelSelectPlayer.prevVelocityX < -0.5;
            const wasMovingRight = levelSelectPlayer.prevVelocityX !== undefined && levelSelectPlayer.prevVelocityX > 0.5;
            const isMovingLeft = levelSelectPlayer.velocityX < -0.5;
            const isMovingRight = levelSelectPlayer.velocityX > 0.5;

            // White particles on movement START (when starting to move from stopped/opposite direction)
            if (isMovingLeft && !wasMovingLeft && Math.random() < 0.3) {
                spawnParticles(levelSelectPlayer.x + levelSelectPlayer.width / 2, levelSelectPlayer.y + levelSelectPlayer.height / 2, 2, 'rgb(255, 255, 255)', levelSelectPlayer.currentSize);
            }
            if (isMovingRight && !wasMovingRight && Math.random() < 0.3) {
                spawnParticles(levelSelectPlayer.x + levelSelectPlayer.width / 2, levelSelectPlayer.y + levelSelectPlayer.height / 2, 2, 'rgb(255, 255, 255)', levelSelectPlayer.currentSize);
            }

            // Orange speed-based particles (when moving fast horizontally)
            const speed = Math.abs(levelSelectPlayer.velocityX);
            if (speed > 0.5) {
                const particleChance = Math.min(speed / 10, 0.8);
                if (Math.random() < particleChance) {
                    const particleCount = Math.floor(speed / 2);
                    spawnParticles(levelSelectPlayer.x + levelSelectPlayer.width / 2, levelSelectPlayer.y + levelSelectPlayer.height / 2, particleCount, 'rgb(255, 140, 66)', levelSelectPlayer.currentSize);
                }
            }

            // Store current velocity for next frame
            levelSelectPlayer.prevVelocityX = levelSelectPlayer.velocityX;

            // Check if player pressed space on a platform
            if (standingOnPlatform && (levelSelectKeys[' '] || levelSelectKeys['Space'])) {
                if (standingOnPlatform.action === 'back') {
                    // Back to menu portal
                    levelSelectActive = false;
                    backToMainMenu();
                } else if (standingOnPlatform.levelId) {
                    // Level portal
                    levelSelectActive = false;
                    playLevel(standingOnPlatform.levelId);
                }
                levelSelectKeys[' '] = false;
                levelSelectKeys['Space'] = false;
            }

            // STEP 4: Jump with variable height based on hold time (W or Up only, NOT space)
            if ((levelSelectKeys['w'] || levelSelectKeys['ArrowUp']) && isGrounded && !levelSelectIsJumping) {
                // Start jump immediately with strong initial velocity
                levelSelectPlayer.velocityY = -1.5 * sizeScale; // Strong initial jump
                levelSelectIsJumping = true;
                levelSelectPlayer.jumpHoldTime = 0;
                // White jump particles
                spawnParticles(levelSelectPlayer.x + levelSelectPlayer.width / 2, levelSelectPlayer.y + levelSelectPlayer.height, 12, 'rgb(255, 255, 255)', levelSelectPlayer.currentSize);
            }

            // Continue adding upward velocity while holding button (extends jump height)
            if (levelSelectIsJumping && (levelSelectKeys['w'] || levelSelectKeys['ArrowUp']) && levelSelectPlayer.velocityY < 0 && levelSelectPlayer.jumpHoldTime < MAX_JUMP_HOLD_TIME) {
                levelSelectPlayer.jumpHoldTime += deltaTime;

                // Add upward acceleration while holding (max height = 4x playerSize + 1px)
                const maxJumpVelocity = JUMP_POWER * sizeScale;
                if (Math.abs(levelSelectPlayer.velocityY) < maxJumpVelocity && levelSelectPlayer.jumpHoldTime < MAX_JUMP_HOLD_TIME) {
                    levelSelectPlayer.velocityY -= JUMP_CHARGE_RATE * sizeScale * deltaTime;
                }
            }

            // Stop adding velocity when button released
            if (levelSelectIsJumping && (!levelSelectKeys['w'] && !levelSelectKeys['ArrowUp'])) {
                levelSelectIsJumping = false;
            }

            // Stop jump when time limit exceeded
            if (levelSelectIsJumping && levelSelectPlayer.jumpHoldTime >= MAX_JUMP_HOLD_TIME) {
                levelSelectIsJumping = false;
            }

            // Reset jump state when grounded
            if (isGrounded && levelSelectPlayer.velocityY >= 0) {
                levelSelectIsJumping = false;
            }

            // Fast-fall particles (white) - spawn when holding down/S in air
            if ((levelSelectKeys['s'] || levelSelectKeys['ArrowDown']) && !isGrounded && levelSelectPlayer.velocityY > 0) {
                // Spawn particles continuously during fast fall
                if (Math.random() < 0.3) { // 30% chance each frame for smooth particle trail
                    spawnParticles(levelSelectPlayer.x + levelSelectPlayer.width / 2, levelSelectPlayer.y, 3, 'rgb(255, 255, 255)', levelSelectPlayer.currentSize);
                }
            }

            // STEP 5: Apply friction using exponential decay
            if (isGrounded) {
                levelSelectPlayer.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                levelSelectPlayer.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // STEP 6: Cap vertical velocity to prevent tunneling (scaled by size)
            const maxFallSpeed = 8 * sizeScale;
            levelSelectPlayer.velocityY = Math.min(levelSelectPlayer.velocityY, maxFallSpeed);

            // Limit horizontal speed (scaled by size)
            const scaledMaxSpeed = GROUND_MAX_SPEED * sizeScale;
            levelSelectPlayer.velocityX = Math.max(-scaledMaxSpeed, Math.min(scaledMaxSpeed, levelSelectPlayer.velocityX));

            // STEP 7: Update position HORIZONTALLY first, then check X collisions
            levelSelectPlayer.x += levelSelectPlayer.velocityX * deltaTime;

            // Check horizontal collisions
            for (const platform of levelSelectPlatforms) {
                if (checkCollision(levelSelectPlayer, platform)) {
                    if (levelSelectPlayer.velocityX > 0) {
                        // Moving right, hit left side of platform
                        levelSelectPlayer.x = platform.x - levelSelectPlayer.width;
                    } else if (levelSelectPlayer.velocityX < 0) {
                        // Moving left, hit right side of platform
                        levelSelectPlayer.x = platform.x + platform.width;
                    }
                    levelSelectPlayer.velocityX = 0;
                }
            }

            // Update position VERTICALLY, then check Y collisions
            levelSelectPlayer.y += levelSelectPlayer.velocityY * deltaTime;

            // Check vertical collisions
            for (const platform of levelSelectPlatforms) {
                if (checkCollision(levelSelectPlayer, platform)) {
                    if (levelSelectPlayer.velocityY > 0) {
                        // Moving down, hit top of platform
                        // White landing particles if falling with significant velocity
                        if (levelSelectPlayer.velocityY > 2) {
                            spawnParticles(levelSelectPlayer.x + levelSelectPlayer.width / 2, levelSelectPlayer.y + levelSelectPlayer.height, 8, 'rgb(255, 255, 255)', levelSelectPlayer.currentSize);
                        }
                        levelSelectPlayer.y = platform.y - levelSelectPlayer.height;
                        levelSelectPlayer.velocityY = 0;
                    } else if (levelSelectPlayer.velocityY < 0) {
                        // Moving up, hit bottom of platform
                        levelSelectPlayer.y = platform.y + platform.height;
                        levelSelectPlayer.velocityY = 0;
                        levelSelectIsJumping = false;
                    }
                }
            }

            // Keep player in bounds (horizontal only)
            if (levelSelectPlayer.x < 0) levelSelectPlayer.x = 0;
            if (levelSelectPlayer.x > 1200 - levelSelectPlayer.width) levelSelectPlayer.x = 1200 - levelSelectPlayer.width;
        }

        function renderLevelSelect(ctx, deltaTime = 1) {
            // Clear with sky blue background
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, 1200, 800);

            // Draw background gridlines (40x40px)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;

            // Vertical lines
            for (let x = 0; x < 1200; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 800);
                ctx.stroke();
            }

            // Horizontal lines
            for (let y = 0; y < 800; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(1200, y);
                ctx.stroke();
            }

            // Draw platforms with clean styling matching main menu
            for (const platform of levelSelectPlatforms) {
                if (platform.action === 'back') {
                    // Back to menu portal - dark blue with glow
                    const gradient = ctx.createLinearGradient(platform.x, platform.y, platform.x, platform.y + platform.height);
                    gradient.addColorStop(0, 'rgba(25, 82, 154, 0.7)');
                    gradient.addColorStop(1, 'rgba(25, 82, 154, 0.4)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                    // Glowing border - darker blue (inside edge)
                    ctx.shadowColor = '#19529a';
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = '#19529a';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(platform.x + 2, platform.y + 2, platform.width - 4, platform.height - 4);
                    ctx.shadowBlur = 0;

                    // Label with shadow - matching main menu style exactly
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    ctx.shadowBlur = 5;
                    ctx.fillText(platform.label, platform.x + platform.width / 2, platform.y + platform.height / 2 + 5);
                    ctx.shadowBlur = 0;
                } else if (platform.levelId) {
                    // Level portal platform - light blue with glow (same as main menu)
                    const gradient = ctx.createLinearGradient(platform.x, platform.y, platform.x, platform.y + platform.height);
                    gradient.addColorStop(0, 'rgba(79, 172, 254, 0.5)');
                    gradient.addColorStop(1, 'rgba(79, 172, 254, 0.2)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                    // Glowing border (inside edge)
                    ctx.shadowColor = '#4facfe';
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = '#4facfe';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(platform.x + 2, platform.y + 2, platform.width - 4, platform.height - 4);
                    ctx.shadowBlur = 0;

                    // Text with shadow - matching main menu style exactly
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    ctx.shadowBlur = 5;
                    ctx.fillText(platform.levelName, platform.x + platform.width / 2, platform.y + platform.height / 2 + 5);
                    ctx.shadowBlur = 0;
                } else {
                    // Boundary platforms - standardized
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                    // Thicker dark border (inside edge)
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(platform.x + 2, platform.y + 2, platform.width - 4, platform.height - 4);

                    // Inner 40x40 grid lines
                    ctx.strokeStyle = '#388E3C';
                    ctx.lineWidth = 1;
                    for (let gx = 40; gx < platform.width; gx += 40) {
                        ctx.beginPath();
                        ctx.moveTo(platform.x + gx, platform.y);
                        ctx.lineTo(platform.x + gx, platform.y + platform.height);
                        ctx.stroke();
                    }
                    for (let gy = 40; gy < platform.height; gy += 40) {
                        ctx.beginPath();
                        ctx.moveTo(platform.x, platform.y + gy);
                        ctx.lineTo(platform.x + platform.width, platform.y + gy);
                        ctx.stroke();
                    }
                }
            }

            // Update and draw particles
            updateAndDrawParticles(ctx, 0, 0, deltaTime);

            // Draw player
            levelSelectPlayer.draw(ctx, 0, 0);

            // Draw clean title and instructions with shadow
            ctx.textAlign = 'center';

            // Title
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#000000';
            ctx.fillText('LEVELS', 600, 32);
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText('LEVELS', 600, 30);

            // Instructions
            ctx.font = 'bold 14px Arial';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillText('Jump to a portal and press SPACE to start', 600, 57);
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText('Jump to a portal and press SPACE to start', 600, 55);

            // Controls hint
            ctx.font = '11px Arial';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillText('WASD/Arrows to move • ESC to return', 600, 77);
            ctx.fillStyle = '#CCCCCC';
            ctx.fillText('WASD/Arrows to move • ESC to return', 600, 75);
        }

        function formatTime(ms) {
            if (!ms || ms < 0) return '0:00.000';
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const milliseconds = Math.floor(ms % 1000);
            return `${minutes}:${seconds.toString().padStart(2, '0')}.${Math.floor(milliseconds).toString().padStart(3, '0')}`;
        }

        async function playLevel(levelId) {
            try {
                // Load level from Firebase
                const levelSnapshot = await database.ref('levels/' + levelId).once('value');
                const levelInfo = levelSnapshot.val();

                if (!levelInfo || !levelInfo.data) {
                    alert('Error: Level data not found!');
                    return;
                }

                const levelData = levelInfo.data;

                // Hide practice levels screen
                document.getElementById('practiceLevelsScreen').classList.remove('active');

                // Show practice canvas
                const canvas = document.getElementById('practiceCanvas');
                canvas.style.display = 'block';
                document.getElementById('hud').style.display = 'block';
                document.getElementById('practiceBackBtn').style.display = 'block';

                // Initialize practice mode with level data
                practiceMode.active = true;
                practiceMode.isLevelMode = true; // Flag to indicate we're playing a level, not infinite mode
                practiceMode.levelData = levelData;
                practiceMode.levelId = levelId;
                practiceMode.levelName = levelInfo.name;
                practiceMode.startTime = null; // Will be set when player moves
                practiceMode.finishTime = null;
                practiceMode.finished = false;
                practiceMode.leaderboardPosition = null;
                practiceMode.totalPlayers = 0;
                practiceMode.leaderboardData = [];

                // Load leaderboard to find player's position and display leaderboard
                try {
                    const timesSnapshot = await database.ref('times_history').once('value');
                    const timesData = timesSnapshot.val();

                    if (timesData) {
                        // Get player data for usernames
                        const playersSnapshot = await database.ref('players').once('value');
                        const playersData = playersSnapshot.val();

                        const leaderboard = [];

                        // Process each user's times for this level
                        for (const [uid, userTimes] of Object.entries(timesData)) {
                            if (userTimes[levelId]) {
                                // Find best time for this user
                                let bestTime = Infinity;
                                Object.values(userTimes[levelId]).forEach(timeEntry => {
                                    if (timeEntry.time < bestTime) {
                                        bestTime = timeEntry.time;
                                    }
                                });

                                if (bestTime < Infinity) {
                                    leaderboard.push({
                                        uid: uid,
                                        username: playersData?.[uid]?.username || 'Unknown',
                                        time: bestTime
                                    });
                                }
                            }
                        }

                        // Sort by time
                        leaderboard.sort((a, b) => a.time - b.time);

                        practiceMode.leaderboardData = leaderboard.slice(0, 10); // Top 10
                        practiceMode.totalPlayers = leaderboard.length;
                        const playerIndex = leaderboard.findIndex(s => s.uid === currentUser.uid);
                        if (playerIndex !== -1) {
                            practiceMode.leaderboardPosition = playerIndex + 1;
                        }
                    }
                } catch (err) {
                    console.error('Error loading leaderboard:', err);
                }

                // Find the leftmost platform to spawn player
                let startX = 100;
                let startY = -50;
                if (levelData.platforms && levelData.platforms.length > 0) {
                    const leftmostPlatform = levelData.platforms.reduce((prev, curr) =>
                        curr.x < prev.x ? curr : prev
                    );
                    startX = leftmostPlatform.x + 40;  // Spawn 40px from left edge
                    startY = leftmostPlatform.y - 40;   // Spawn at same Y height (player is 40px tall)
                }
                practiceMode.player = new Player(startX, startY, equippedCosmetics);

                // Load platforms from level
                practiceMode.platforms = levelData.platforms || [];

                // Load other level elements
                practiceMode.hazards = levelData.hazards || [];
                practiceMode.growers = levelData.growers || [];
                practiceMode.shrinkers = levelData.shrinkers || [];
                practiceMode.defaultSizeBlocks = levelData.defaultSizeBlocks || [];

                // Reset other properties
                practiceMode.credits = [];
                practiceMode.creditsCollected = 0;
                practiceMode.cameraX = 0;
                practiceMode.cameraY = 0;

                // Start the practice loop
                let lastPracticeFrameTime = performance.now();
                function practiceLoop(currentTime) {
                    if (!practiceMode.active) return;

                    // Calculate delta time
                    if (!currentTime) currentTime = performance.now();
                    let deltaTime = (currentTime - lastPracticeFrameTime) / 16.67;
                    if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                    lastPracticeFrameTime = currentTime;

                    // Start timer when player first moves
                    if (!practiceMode.startTime && !practiceMode.finished) {
                        const isMoving = practiceMode.keys['a'] || practiceMode.keys['d'] ||
                                       practiceMode.keys['w'] || practiceMode.keys['s'] ||
                                       practiceMode.keys['ArrowLeft'] || practiceMode.keys['ArrowRight'] ||
                                       practiceMode.keys['ArrowUp'] || practiceMode.keys['ArrowDown'];
                        if (isMoving) {
                            practiceMode.startTime = Date.now();
                        }
                    }

                    // Update player
                    updatePracticePlayer(deltaTime);

                    // Check finish zone
                    if (levelData.finish && !practiceMode.finished) {
                        const finish = levelData.finish;
                        if (practiceMode.player.x + practiceMode.player.width > finish.x &&
                            practiceMode.player.x < finish.x + finish.width &&
                            practiceMode.player.y + practiceMode.player.height > finish.y &&
                            practiceMode.player.y < finish.y + finish.height) {
                            practiceMode.finished = true;
                            practiceMode.finishTime = Date.now() - practiceMode.startTime;

                            // Save time to Firebase (no await needed in game loop)
                            database.ref('times_history/' + currentUser.uid + '/' + levelId).push({
                                time: practiceMode.finishTime,
                                timestamp: firebase.database.ServerValue.TIMESTAMP
                            }).catch(err => console.error('Error saving time:', err));
                        }
                    }

                    // Update HUD with timer
                    let timerText = '';
                    if (practiceMode.finished) {
                        const totalMs = practiceMode.finishTime;
                        const minutes = Math.floor(totalMs / 60000);
                        const seconds = Math.floor((totalMs % 60000) / 1000);
                        const ms = totalMs % 1000;
                        timerText = `<div style="font-size: 20px; color: #00FF00; margin-top: 5px;">FINISHED: ${minutes}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}</div>`;
                    } else if (practiceMode.startTime) {
                        const elapsed = Date.now() - practiceMode.startTime;
                        const minutes = Math.floor(elapsed / 60000);
                        const seconds = Math.floor((elapsed % 60000) / 1000);
                        const ms = elapsed % 1000;
                        timerText = `<div style="font-size: 20px; color: #FFD700; margin-top: 5px;">Time: ${minutes}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}</div>`;
                    } else {
                        timerText = `<div style="font-size: 16px; color: #aaa; margin-top: 5px;">Move to start timer!</div>`;
                    }

                    // Add leaderboard position display
                    let rankText = '';
                    if (practiceMode.leaderboardPosition !== null) {
                        rankText = `<div style="font-size: 16px; color: #4facfe; margin-top: 5px;">Your Best: #${practiceMode.leaderboardPosition} of ${practiceMode.totalPlayers}</div>`;
                    } else if (practiceMode.totalPlayers > 0) {
                        rankText = `<div style="font-size: 16px; color: #aaa; margin-top: 5px;">Not ranked yet (${practiceMode.totalPlayers} players)</div>`;
                    }

                    document.getElementById('hud').innerHTML = `
                        <div style="font-size: 24px; font-weight: bold;">${levelInfo.name}</div>
                        <div style="font-size: 14px; margin-top: 3px; color: #aaa;">By ${levelInfo.creator}</div>
                        ${rankText}
                        ${timerText}
                    `;

                    // Render
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Camera follows player
                    practiceMode.cameraX = practiceMode.player.x - canvas.width / 2 + practiceMode.player.width / 2;
                    practiceMode.cameraY = practiceMode.player.y - canvas.height / 2 + practiceMode.player.height / 2;

                    // Draw platforms - standardized
                    for (const platform of practiceMode.platforms) {
                        const screenX = platform.x - practiceMode.cameraX;
                        const screenY = platform.y - practiceMode.cameraY;

                        ctx.fillStyle = '#4CAF50';
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);

                        // Thicker dark border (inside edge)
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(screenX + 2, screenY + 2, platform.width - 4, platform.height - 4);

                        // Inner 40x40 grid lines
                        ctx.strokeStyle = '#388E3C';
                        ctx.lineWidth = 1;
                        for (let gx = 40; gx < platform.width; gx += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX + gx, screenY);
                            ctx.lineTo(screenX + gx, screenY + platform.height);
                            ctx.stroke();
                        }
                        for (let gy = 40; gy < platform.height; gy += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY + gy);
                            ctx.lineTo(screenX + platform.width, screenY + gy);
                            ctx.stroke();
                        }
                    }

                    // Draw hazards (exact colors from level creator)
                    ctx.fillStyle = '#FF3333';
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 4;
                    for (const hazard of practiceMode.hazards) {
                        const screenX = hazard.x - practiceMode.cameraX;
                        const screenY = hazard.y - practiceMode.cameraY;
                        ctx.fillRect(screenX, screenY, hazard.width, hazard.height);
                        ctx.strokeRect(screenX + 2, screenY + 2, hazard.width - 4, hazard.height - 4);
                    }

                    // Draw growers (exact colors from level creator)
                    ctx.fillStyle = '#00FF88';
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 4;
                    for (const grower of practiceMode.growers) {
                        const screenX = grower.x - practiceMode.cameraX;
                        const screenY = grower.y - practiceMode.cameraY;
                        ctx.fillRect(screenX, screenY, grower.width, grower.height);
                        ctx.strokeRect(screenX + 2, screenY + 2, grower.width - 4, grower.height - 4);
                    }

                    // Draw shrinkers (exact colors from level creator)
                    ctx.fillStyle = '#BB66FF';
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 4;
                    for (const shrinker of practiceMode.shrinkers) {
                        const screenX = shrinker.x - practiceMode.cameraX;
                        const screenY = shrinker.y - practiceMode.cameraY;
                        ctx.fillRect(screenX, screenY, shrinker.width, shrinker.height);
                        ctx.strokeRect(screenX + 2, screenY + 2, shrinker.width - 4, shrinker.height - 4);
                    }

                    // Draw default size blocks (exact colors from level creator)
                    ctx.fillStyle = '#FFB84D';
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 4;
                    for (const block of practiceMode.defaultSizeBlocks) {
                        const screenX = block.x - practiceMode.cameraX;
                        const screenY = block.y - practiceMode.cameraY;
                        ctx.fillRect(screenX, screenY, block.width, block.height);
                        ctx.strokeRect(screenX + 2, screenY + 2, block.width - 4, block.height - 4);
                    }

                    // Draw finish zone
                    if (levelData.finish) {
                        const finish = levelData.finish;
                        const finishScreenX = finish.x - practiceMode.cameraX;
                        const finishScreenY = finish.y - practiceMode.cameraY;
                        ctx.fillStyle = practiceMode.finished ? '#00FF00' : '#FFD700';
                        ctx.fillRect(finishScreenX, finishScreenY, finish.width, finish.height);
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(finishScreenX, finishScreenY, finish.width, finish.height);

                        // Draw "FINISH" text
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('FINISH', finishScreenX + finish.width / 2, finishScreenY + finish.height / 2 + 6);
                    }

                    // Draw particles
                    updateAndDrawParticles(ctx, practiceMode.cameraX, practiceMode.cameraY, deltaTime);

                    // Draw player
                    const screenX = practiceMode.player.x - practiceMode.cameraX;
                    const screenY = practiceMode.player.y - practiceMode.cameraY;

                    // Draw player with cosmetics
                    ctx.fillStyle = practiceMode.player.getSkinColor();
                    ctx.fillRect(screenX, screenY, practiceMode.player.width, practiceMode.player.height);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, screenY, practiceMode.player.width, practiceMode.player.height);

                    // Draw equipped item (credits display) even in practice mode
                    if (equippedItem === 'credits' && userCredits > 0) {
                        const creditSize = practiceMode.player.width / 4;
                        const creditX = screenX + (practiceMode.player.width - creditSize) / 2;
                        const creditY = screenY + (practiceMode.player.height - creditSize) / 2;
                        ctx.fillStyle = '#FFD700';
                        ctx.fillRect(creditX, creditY, creditSize, creditSize);
                        ctx.strokeStyle = '#FFA500';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(creditX, creditY, creditSize, creditSize);
                    }

                    // Draw leaderboard panel on right side
                    if (practiceMode.leaderboardData && practiceMode.leaderboardData.length > 0) {
                        const panelWidth = 250;
                        const panelX = canvas.width - panelWidth - 10;
                        const panelY = 10;
                        const headerHeight = 40;
                        const rowHeight = 30;
                        const panelHeight = headerHeight + (practiceMode.leaderboardData.length * rowHeight) + 10;

                        // Semi-transparent background
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

                        // Border
                        ctx.strokeStyle = '#4facfe';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

                        // Header
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold 18px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('LEADERBOARD', panelX + panelWidth / 2, panelY + 25);

                        // Leaderboard entries
                        ctx.font = '14px Arial';
                        ctx.textAlign = 'left';
                        practiceMode.leaderboardData.forEach((entry, index) => {
                            const y = panelY + headerHeight + (index * rowHeight) + 20;
                            const isCurrentUser = entry.uid === currentUser.uid;

                            // Highlight current user
                            if (isCurrentUser) {
                                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                                ctx.fillRect(panelX + 5, panelY + headerHeight + (index * rowHeight) + 5, panelWidth - 10, rowHeight - 5);
                            }

                            // Rank
                            ctx.fillStyle = index < 3 ? '#FFD700' : '#FFFFFF';
                            ctx.fillText(`${index + 1}.`, panelX + 10, y);

                            // Username (truncate if too long)
                            ctx.fillStyle = isCurrentUser ? '#FFD700' : '#FFFFFF';
                            let displayName = entry.username;
                            if (displayName.length > 15) {
                                displayName = displayName.substring(0, 12) + '...';
                            }
                            ctx.fillText(displayName, panelX + 35, y);

                            // Time
                            const minutes = Math.floor(entry.time / 60000);
                            const seconds = Math.floor((entry.time % 60000) / 1000);
                            const ms = entry.time % 1000;
                            const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
                            ctx.textAlign = 'right';
                            ctx.fillText(timeStr, panelX + panelWidth - 10, y);
                            ctx.textAlign = 'left';
                        });
                    }

                    requestAnimationFrame(practiceLoop);
                }

                practiceLoop();

            } catch (error) {
                console.error('Error loading level:', error);
                alert('Error loading level: ' + error.message);
            }
        }

        // Admin function to add levels to Firebase
        async function addLevelToDatabase(levelName, creatorName, levelData) {
            try {
                const levelId = 'level_' + Date.now();
                await database.ref('levels/' + levelId).set({
                    name: levelName,
                    creator: creatorName,
                    data: levelData,
                    createdAt: firebase.database.ServerValue.TIMESTAMP
                });
                console.log('Level added successfully with ID:', levelId);
                return levelId;
            } catch (error) {
                console.error('Error adding level:', error);
                throw error;
            }
        }

        // Add default levels if they don't exist
        async function initializeDefaultLevels() {
            const levelsSnapshot = await database.ref('levels').once('value');
            const levels = levelsSnapshot.val();

            // Check which default levels exist
            const existingLevelNames = levels ? Object.values(levels).map(l => l.name) : [];

            // Delete all levels except "The Curve"
            const levelsToRemove = ['Vertical Challenge', 'Speed Runner', 'Precision Parkour', 'The Maze', 'Size Shifter', 'Hazard Hell', 'Stairway to Heaven', 'The Gauntlet'];

            if (levels) {
                for (const levelName of levelsToRemove) {
                    if (existingLevelNames.includes(levelName)) {
                        const levelEntry = Object.entries(levels).find(([id, level]) => level.name === levelName);
                        if (levelEntry) {
                            const [levelId] = levelEntry;
                            await database.ref(`levels/${levelId}`).remove();
                            console.log(`Removed level: ${levelName}`);
                        }
                    }
                }
            }

            // Add The Curve if it doesn't exist
            if (!existingLevelNames.includes('The Curve')) {
                const theCurveData = {
                            "platforms": [
                                {"x": 0, "y": 0, "width": 240, "height": 40},
                                {"x": 280, "y": -40, "width": 200, "height": 40},
                                {"x": 520, "y": -80, "width": 160, "height": 40},
                                {"x": 720, "y": -120, "width": 120, "height": 40},
                                {"x": 880, "y": -160, "width": 80, "height": 40},
                                {"x": 1000, "y": -200, "width": 40, "height": 40},
                                {"x": 1040, "y": -320, "width": 40, "height": 80},
                                {"x": 1080, "y": -480, "width": 40, "height": 120},
                                {"x": 1120, "y": -680, "width": 40, "height": 160},
                                {"x": 1160, "y": -920, "width": 40, "height": 200},
                                {"x": 1200, "y": -1200, "width": 40, "height": 240},
                                {"x": -320, "y": 40, "width": 280, "height": 40},
                                {"x": -680, "y": 80, "width": 320, "height": 40},
                                {"x": -1120, "y": 120, "width": 400, "height": 40},
                                {"x": 1240, "y": -1520, "width": 40, "height": 280},
                                {"x": 1280, "y": -1880, "width": 40, "height": 320},
                                {"x": 1320, "y": -2280, "width": 40, "height": 360},
                                {"x": 1360, "y": -2720, "width": 40, "height": 400},
                                {"x": 1030, "y": -250, "width": 10, "height": 10},
                                {"x": 1070, "y": -400, "width": 10, "height": 10},
                                {"x": 1110, "y": -560, "width": 10, "height": 10},
                                {"x": 1110, "y": -640, "width": 10, "height": 10},
                                {"x": 1150, "y": -760, "width": 10, "height": 10},
                                {"x": 1150, "y": -840, "width": 10, "height": 10},
                                {"x": 1180, "y": -1080, "width": 20, "height": 20},
                                {"x": 1220, "y": -1360, "width": 20, "height": 20},
                                {"x": 1260, "y": -1640, "width": 20, "height": 20},
                                {"x": 1260, "y": -1760, "width": 20, "height": 20},
                                {"x": 1300, "y": -2040, "width": 20, "height": 20},
                                {"x": 1300, "y": -2180, "width": 20, "height": 20},
                                {"x": 1340, "y": -2400, "width": 20, "height": 20},
                                {"x": 1340, "y": -2520, "width": 20, "height": 20},
                                {"x": 1340, "y": -2640, "width": 20, "height": 20},
                                {"x": 1400, "y": -3200, "width": 40, "height": 440},
                                {"x": 1440, "y": -3680, "width": 40, "height": 440},
                                {"x": 1360, "y": -3040, "width": 40, "height": 40},
                                {"x": -1600, "y": 160, "width": 440, "height": 40},
                                {"x": -2120, "y": 200, "width": 480, "height": 40},
                                {"x": 1400, "y": -3480, "width": 40, "height": 40},
                                {"x": 1400, "y": -3720, "width": 120, "height": 40},
                                {"x": 1360, "y": -3960, "width": 200, "height": 40}
                            ],
                            "hazards": [],
                            "growers": [
                                {"x": 1360, "y": -2760, "width": 40, "height": 40},
                                {"x": -2120, "y": 120, "width": 40, "height": 80},
                                {"x": -2080, "y": 120, "width": 40, "height": 40},
                                {"x": -2040, "y": 120, "width": 40, "height": 80}
                            ],
                            "shrinkers": [
                                {"x": 280, "y": -280, "width": 20, "height": 240}
                            ],
                            "defaultSizeBlocks": [
                                {"x": -680, "y": -280, "width": 20, "height": 360},
                                {"x": 1360, "y": -4080, "width": 40, "height": 120},
                                {"x": 1400, "y": -4080, "width": 120, "height": 40},
                                {"x": 1520, "y": -4080, "width": 40, "height": 120},
                                {"x": 1180, "y": -940, "width": 20, "height": 20}
                            ],
                            "backgroundBlocks": [],
                            "foregroundBlocks": [],
                            "triggers": [],
                            "comments": [],
                            "start": {"x": -2080, "y": 160, "width": 40, "height": 40},
                            "finish": {"x": 1440, "y": -4000, "width": 40, "height": 40},
                            "physics": {
                                "gravity": 0.042,
                                "moveSpeed": 0.28,
                                "jumpPower": 3.7,
                                "maxSpeed": 3.5,
                                "friction": 0.94,
                                "airRes": 0.88,
                                "fastFallMultiplier": 2
                            }
                        };

                await addLevelToDatabase('The Curve', 'System', theCurveData);
                console.log('Default level "The Curve" added to database');
            }

            // Simple Map - Basic platforming level
            if (!existingLevelNames.includes('Simple Map')) {
                const simpleMapData = {
                    "platforms": [
                        {"x": -80, "y": 0, "width": 520, "height": 40},
                        {"x": -80, "y": -240, "width": 520, "height": 40},
                        {"x": 400, "y": -200, "width": 40, "height": 200},
                        {"x": 40, "y": -120, "width": 40, "height": 120},
                        {"x": 120, "y": -200, "width": 40, "height": 120},
                        {"x": 200, "y": -120, "width": 40, "height": 120},
                        {"x": 280, "y": -200, "width": 40, "height": 160},
                        {"x": -80, "y": -200, "width": 40, "height": 200}
                    ],
                    "hazards": [],
                    "growers": [],
                    "shrinkers": [],
                    "defaultSizeBlocks": [],
                    "backgroundBlocks": [],
                    "foregroundBlocks": [],
                    "triggers": [],
                    "comments": [],
                    "start": {"x": -40, "y": -40, "width": 40, "height": 40},
                    "finish": {"x": 360, "y": -40, "width": 40, "height": 40},
                    "physics": {
                        "gravity": 0.132,
                        "moveSpeed": 0.45,
                        "jumpPower": 5.13,
                        "maxSpeed": 5.625,
                        "friction": 0.94,
                        "airRes": 0.88,
                        "fastFallMultiplier": 3.5
                    }
                };
                await addLevelToDatabase('Simple Map', 'System', simpleMapData);
                console.log('Default level "Simple Map" added to database');
            }

            // Simple Red - Level with hazard obstacles
            if (!existingLevelNames.includes('Simple Red')) {
                const simpleRedData = {
                    "platforms": [
                        {"x": -80, "y": 0, "width": 520, "height": 40},
                        {"x": -80, "y": -240, "width": 520, "height": 40},
                        {"x": 400, "y": -200, "width": 40, "height": 200},
                        {"x": -80, "y": -200, "width": 40, "height": 200}
                    ],
                    "hazards": [
                        {"x": 40, "y": -40, "width": 40, "height": 40},
                        {"x": 120, "y": -200, "width": 40, "height": 40},
                        {"x": 200, "y": -40, "width": 40, "height": 40},
                        {"x": 280, "y": -200, "width": 40, "height": 40},
                        {"x": 40, "y": -60, "width": 40, "height": 20},
                        {"x": 120, "y": -160, "width": 40, "height": 20},
                        {"x": 200, "y": -60, "width": 40, "height": 20},
                        {"x": 280, "y": -160, "width": 40, "height": 20},
                        {"x": 50, "y": -70, "width": 20, "height": 10},
                        {"x": 130, "y": -140, "width": 20, "height": 10},
                        {"x": 210, "y": -70, "width": 20, "height": 10},
                        {"x": 290, "y": -140, "width": 20, "height": 10}
                    ],
                    "growers": [],
                    "shrinkers": [],
                    "defaultSizeBlocks": [],
                    "backgroundBlocks": [],
                    "foregroundBlocks": [],
                    "triggers": [],
                    "comments": [],
                    "start": {"x": -40, "y": -40, "width": 40, "height": 40},
                    "finish": {"x": 360, "y": -40, "width": 40, "height": 40},
                    "physics": {
                        "gravity": 0.132,
                        "moveSpeed": 0.45,
                        "jumpPower": 5.13,
                        "maxSpeed": 5.625,
                        "friction": 0.94,
                        "airRes": 0.88,
                        "fastFallMultiplier": 3.5
                    }
                };
                await addLevelToDatabase('Simple Red', 'System', simpleRedData);
                console.log('Default level "Simple Red" added to database');
            }

            // Sky Climb - Vertical climbing challenge
            if (!existingLevelNames.includes('Sky Climb')) {
                const skyClimbData = {
                    "platforms": [
                        {"x": -40, "y": 0, "width": 120, "height": 40},
                        {"x": -40, "y": -120, "width": 120, "height": 40},
                        {"x": -40, "y": -240, "width": 120, "height": 40},
                        {"x": -40, "y": -360, "width": 120, "height": 40}
                    ],
                    "hazards": [
                        {"x": -120, "y": 80, "width": 280, "height": 40},
                        {"x": -120, "y": -480, "width": 280, "height": 40},
                        {"x": 160, "y": -480, "width": 40, "height": 600},
                        {"x": -160, "y": -480, "width": 40, "height": 600}
                    ],
                    "growers": [],
                    "shrinkers": [],
                    "defaultSizeBlocks": [],
                    "backgroundBlocks": [],
                    "foregroundBlocks": [],
                    "triggers": [],
                    "comments": [],
                    "start": {"x": 0, "y": -40, "width": 40, "height": 40},
                    "finish": {"x": 0, "y": -400, "width": 40, "height": 40},
                    "physics": {
                        "gravity": 0.132,
                        "moveSpeed": 0.45,
                        "jumpPower": 5.13,
                        "maxSpeed": 5.625,
                        "friction": 0.94,
                        "airRes": 0.88,
                        "fastFallMultiplier": 3.5
                    }
                };
                await addLevelToDatabase('Sky Climb', 'System', skyClimbData);
                console.log('Default level "Sky Climb" added to database');
            }

            // Size Puzzle - Level with size-changing mechanics
            if (!existingLevelNames.includes('Size Puzzle')) {
                const sizePuzzleData = {
                    "platforms": [
                        {"x": -40, "y": 0, "width": 120, "height": 40},
                        {"x": -40, "y": -160, "width": 120, "height": 40},
                        {"x": 120, "y": 0, "width": 80, "height": 40},
                        {"x": 160, "y": 40, "width": 40, "height": 120},
                        {"x": -160, "y": 0, "width": 80, "height": 40},
                        {"x": -160, "y": 40, "width": 40, "height": 120},
                        {"x": -160, "y": 320, "width": 360, "height": 40},
                        {"x": -160, "y": 160, "width": 80, "height": 40},
                        {"x": 120, "y": 160, "width": 80, "height": 40},
                        {"x": -50, "y": 0, "width": 10, "height": 40},
                        {"x": 80, "y": 0, "width": 10, "height": 40}
                    ],
                    "hazards": [],
                    "growers": [
                        {"x": -120, "y": 120, "width": 280, "height": 40}
                    ],
                    "shrinkers": [
                        {"x": 0, "y": -200, "width": 40, "height": 40}
                    ],
                    "defaultSizeBlocks": [],
                    "backgroundBlocks": [],
                    "foregroundBlocks": [],
                    "triggers": [],
                    "comments": [],
                    "start": {"x": 0, "y": -40, "width": 40, "height": 40},
                    "finish": {"x": 0, "y": -400, "width": 40, "height": 40},
                    "physics": {
                        "gravity": 0.132,
                        "moveSpeed": 0.45,
                        "jumpPower": 5.13,
                        "maxSpeed": 5.625,
                        "friction": 0.94,
                        "airRes": 0.88,
                        "fastFallMultiplier": 3.5
                    }
                };
                await addLevelToDatabase('Size Puzzle', 'System', sizePuzzleData);
                console.log('Default level "Size Puzzle" added to database');
            }

            // The Labyrinth - Large complex level with multiple size changes
            if (!existingLevelNames.includes('The Labyrinth')) {
                const labyrinthData = {
                    "platforms": [
                        {"x": -40, "y": 0, "width": 120, "height": 40},
                        {"x": -200, "y": 120, "width": 320, "height": 40},
                        {"x": 200, "y": 120, "width": 40, "height": 40},
                        {"x": 240, "y": 120, "width": 40, "height": 480},
                        {"x": -240, "y": 120, "width": 40, "height": 480},
                        {"x": -200, "y": 200, "width": 40, "height": 40},
                        {"x": -80, "y": 200, "width": 320, "height": 40},
                        {"x": -200, "y": 280, "width": 80, "height": 40},
                        {"x": -40, "y": 280, "width": 280, "height": 40},
                        {"x": -200, "y": 360, "width": 280, "height": 40},
                        {"x": 160, "y": 360, "width": 80, "height": 40},
                        {"x": -200, "y": 440, "width": 120, "height": 40},
                        {"x": 0, "y": 440, "width": 240, "height": 40},
                        {"x": -200, "y": 520, "width": 240, "height": 40},
                        {"x": 120, "y": 520, "width": 120, "height": 40},
                        {"x": 280, "y": 560, "width": 80, "height": 40},
                        {"x": -320, "y": 560, "width": 80, "height": 40},
                        {"x": -320, "y": 760, "width": 680, "height": 40},
                        {"x": 280, "y": 240, "width": 40, "height": 40},
                        {"x": -280, "y": 240, "width": 40, "height": 40}
                    ],
                    "hazards": [
                        {"x": 560, "y": -480, "width": 40, "height": 1360},
                        {"x": -560, "y": -480, "width": 40, "height": 1360},
                        {"x": -520, "y": -480, "width": 1080, "height": 40},
                        {"x": -520, "y": 840, "width": 1080, "height": 40}
                    ],
                    "growers": [
                        {"x": -40, "y": 680, "width": 120, "height": 80}
                    ],
                    "shrinkers": [
                        {"x": -320, "y": 400, "width": 80, "height": 40},
                        {"x": 280, "y": 400, "width": 80, "height": 40},
                        {"x": 80, "y": -160, "width": 200, "height": 40},
                        {"x": -240, "y": -160, "width": 200, "height": 40}
                    ],
                    "defaultSizeBlocks": [],
                    "backgroundBlocks": [],
                    "foregroundBlocks": [],
                    "triggers": [],
                    "comments": [],
                    "start": {"x": 0, "y": -40, "width": 40, "height": 40},
                    "finish": {"x": -40, "y": -400, "width": 120, "height": 80},
                    "physics": {
                        "gravity": 0.132,
                        "moveSpeed": 0.45,
                        "jumpPower": 5.13,
                        "maxSpeed": 5.625,
                        "friction": 0.94,
                        "airRes": 0.88,
                        "fastFallMultiplier": 3.5
                    }
                };
                await addLevelToDatabase('The Labyrinth', 'System', labyrinthData);
                console.log('Default level "The Labyrinth" added to database');
            }

        }

        // Practice mode (infinite runner with credit earning)
        let practiceMode = {
            active: false,
            player: null,
            platforms: [],
            credits: [], // Physical credit coins to collect
            platformsPassed: 0,
            creditsCollected: 0,
            lastPlatformX: 0,
            cameraX: 0,
            cameraY: 0,
            keys: {},
            respawnCountdown: 0, // Countdown timer before respawn
            isDead: false, // Whether player is in death state
            startCountdown: 0, // Countdown at level start (3 seconds)
            isStarting: false // Whether level is starting
        };

        function startPracticeMode() {
            try {
                console.log('Starting practice mode...');

                const canvas = document.getElementById('practiceCanvas');
                const ctx = canvas.getContext('2d');

                if (!canvas || !ctx) {
                    console.error('Canvas or context not found!');
                    alert('Error: Practice canvas not found. Please refresh the page.');
                    return;
                }

                canvas.style.display = 'block';
                document.getElementById('hud').style.display = 'block';
                document.getElementById('practiceBackBtn').style.display = 'block';

                practiceMode.active = true;
                practiceMode.player = new Player(100, 300, equippedCosmetics);
                practiceMode.platforms = [];
                practiceMode.credits = [];
                practiceMode.platformsPassed = 0;
                practiceMode.creditsCollected = 0;
                practiceMode.lastPlatformX = -200; // Start from negative to generate from beginning
                practiceMode.startCountdown = 180; // 3 seconds at 60fps (3 * 60)
                practiceMode.isStarting = true;
                practiceMode.isDead = false;

                console.log('Player created:', practiceMode.player);

                // Generate initial platforms
                for (let i = 0; i < 20; i++) {
                    generatePracticePlatform();
                }

                console.log('Generated platforms:', practiceMode.platforms.length);
                console.log('Generated credits:', practiceMode.credits.length);

            let lastPracticeFrameTime = performance.now();
            function practiceLoop(currentTime) {
                if (!practiceMode.active) return;

                // Calculate delta time
                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastPracticeFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                lastPracticeFrameTime = currentTime;

                // Update
                updatePracticePlayer(deltaTime);

                // Generate new platforms
                while (practiceMode.lastPlatformX < practiceMode.cameraX + 1500) {
                    generatePracticePlatform();
                }

                // Remove old platforms and credits
                practiceMode.platforms = practiceMode.platforms.filter(p => p.x > practiceMode.cameraX - 200);
                practiceMode.credits = practiceMode.credits.filter(c => c.x > practiceMode.cameraX - 200);

                // Update HUD
                let hudContent = '';
                if (practiceMode.isStarting) {
                    const countdownNum = Math.ceil(practiceMode.startCountdown / 60);
                    hudContent = `
                        <div style="font-size: 72px; font-weight: bold; color: #FFD700; text-align: center; margin-top: 200px; text-shadow: 3px 3px 6px rgba(0,0,0,0.5);">${countdownNum}</div>
                        <div style="font-size: 24px; font-weight: bold; text-align: center; margin-top: 20px;">GET READY!</div>
                    `;
                } else {
                    hudContent = `
                        <div style="font-size: 24px; font-weight: bold;">EARN MODE</div>
                        <div style="font-size: 18px; margin-top: 5px;">Collected This Run: ${practiceMode.creditsCollected}</div>
                        <div style="font-size: 16px; margin-top: 3px;">Credits: ${secureCredits} <span style="font-size: 12px; color: #aaa;">(${userCredits} on hand)</span></div>
                        <div style="font-size: 14px; margin-top: 3px; color: #aaa;">Active Credits: ${practiceMode.credits.filter(c => !c.collected).length}</div>
                        <div style="font-size: 16px; color: #FFD700; margin-top: 5px;">Collect coins!</div>
                    `;
                }
                document.getElementById('hud').innerHTML = hudContent;

                // Render
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw background 40x40px gridlines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;

                // Vertical lines
                const startX = Math.floor(practiceMode.cameraX / 40) * 40;
                for (let x = startX; x < practiceMode.cameraX + canvas.width; x += 40) {
                    const screenX = x - practiceMode.cameraX;
                    ctx.beginPath();
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, canvas.height);
                    ctx.stroke();
                }

                // Horizontal lines
                const startY = Math.floor(practiceMode.cameraY / 40) * 40;
                for (let y = startY; y < practiceMode.cameraY + canvas.height; y += 40) {
                    const screenY = y - practiceMode.cameraY;
                    ctx.beginPath();
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(canvas.width, screenY);
                    ctx.stroke();
                }

                // Draw death zone at bottom (red warning blocks)
                ctx.fillStyle = '#FF0000';
                const deathZoneY = 900 - practiceMode.cameraY;
                ctx.fillRect(0, deathZoneY, canvas.width, canvas.height - deathZoneY);

                // Draw skull icons on death zone
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 30px Arial';
                for (let x = 0; x < canvas.width; x += 60) {
                    ctx.fillText('☠', x, deathZoneY + 40);
                }

                // Draw platforms
                for (const platform of practiceMode.platforms) {
                    const screenX = platform.x - practiceMode.cameraX;
                    const screenY = platform.y - practiceMode.cameraY;

                    if (platform.isHazard) {
                        ctx.fillStyle = '#FF0000';
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);
                    } else {
                        // Green platform - standardized
                        ctx.fillStyle = '#4CAF50';
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);

                        // Thicker dark border (inside edge)
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(screenX + 2, screenY + 2, platform.width - 4, platform.height - 4);

                        // Inner 40x40 grid lines
                        ctx.strokeStyle = '#388E3C';
                        ctx.lineWidth = 1;
                        for (let gx = 40; gx < platform.width; gx += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX + gx, screenY);
                            ctx.lineTo(screenX + gx, screenY + platform.height);
                            ctx.stroke();
                        }
                        for (let gy = 40; gy < platform.height; gy += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY + gy);
                            ctx.lineTo(screenX + platform.width, screenY + gy);
                            ctx.stroke();
                        }
                    }
                }

                // Draw credit coins
                for (const credit of practiceMode.credits) {
                    if (!credit.collected) {
                        const screenX = credit.x - practiceMode.cameraX;
                        const screenY = credit.y - practiceMode.cameraY;

                        // Draw golden coin with glow
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 15;

                        // Outer golden circle
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(screenX + 15, screenY + 15, 15, 0, Math.PI * 2);
                        ctx.fill();

                        // Inner darker circle for depth
                        ctx.fillStyle = '#FFA500';
                        ctx.beginPath();
                        ctx.arc(screenX + 15, screenY + 15, 10, 0, Math.PI * 2);
                        ctx.fill();

                        // Dollar sign
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('$', screenX + 15, screenY + 20);
                    }
                }

                // Update and draw particles
                particles = particles.filter(p => p.life > 0);
                for (const particle of particles) {
                    particle.update(deltaTime);
                    particle.draw(ctx, practiceMode.cameraX, practiceMode.cameraY);
                }

                // Draw player with squash/stretch
                practiceMode.player.updateTrail();
                practiceMode.player.draw(ctx, practiceMode.cameraX, practiceMode.cameraY, false);

                // Draw credits earned counter at top of screen
                if (!practiceMode.isStarting) {
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.fillRect(canvas.width / 2 - 150, 10, 300, 50);

                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Credits Earned: ${practiceMode.creditsCollected}`, canvas.width / 2, 40);
                }

                requestAnimationFrame(practiceLoop);
            }

            console.log('Starting practice loop...');
            practiceLoop();

            } catch (error) {
                console.error('Error starting practice mode:', error);
                alert('Error starting earn mode: ' + error.message);
            }
        }

        function generatePracticePlatform() {
            const lastPlatform = practiceMode.platforms[practiceMode.platforms.length - 1];

            // First platform should be at player spawn location (100, 340 = just below player at 300)
            const baseX = lastPlatform ? lastPlatform.x + lastPlatform.width + Math.random() * 150 + 50 : 0;
            const baseY = lastPlatform ? lastPlatform.y + (Math.random() - 0.5) * 100 : 340;

            // Width must be multiples of 40 (40x40 blocks only)
            const numBlocks = Math.floor(Math.random() * 4) + 2; // 2-5 blocks wide
            const width = numBlocks * 40;
            const platformY = Math.max(200, Math.min(600, Math.round(baseY / 40) * 40)); // Snap Y to 40px grid

            practiceMode.platforms.push({
                x: baseX,
                y: platformY,
                width: width,
                height: 40,
                isHazard: false
            });

            // Spawn credit coin above platform (70% chance per platform)
            if (Math.random() < 0.7) {
                practiceMode.credits.push({
                    x: baseX + width / 2 - 15, // Center above platform
                    y: platformY - 60, // Float above platform
                    width: 30,
                    height: 30,
                    collected: false
                });
            }

            practiceMode.lastPlatformX = baseX;
        }

        function updatePracticePlayer(deltaTime = 1) {
            const player = practiceMode.player;
            const sizeScale = player.currentSize / 40;

            // Handle start countdown
            if (practiceMode.isStarting) {
                practiceMode.startCountdown -= deltaTime;
                if (practiceMode.startCountdown <= 0) {
                    practiceMode.isStarting = false;
                }
                // Freeze player during countdown
                return;
            }

            // Handle death
            if (practiceMode.isDead) {
                if (practiceMode.isLevelMode) {
                    // Practice level mode - respawn at start immediately
                    // Reset player to start position
                    player.x = practiceMode.levelData.start.x;
                    player.y = practiceMode.levelData.start.y;
                    player.velocityX = 0;
                    player.velocityY = 0;
                    player.currentSize = 40;
                    player.width = 40;
                    player.height = 40;

                    // Reset timer
                    practiceMode.startTime = null;
                    practiceMode.finished = false;

                    // Clear death flag
                    practiceMode.isDead = false;
                    return;
                } else {
                    // Earn mode (infinite runner) - show death summary and exit
                    const creditsEarned = practiceMode.creditsCollected;

                    if (creditsEarned > 0) {
                        alert(`You died!\n\nCredits earned this run: ${creditsEarned}\nThese credits have been added to your backpack!`);
                    } else {
                        alert(`You died!\n\nNo credits earned this run.`);
                    }

                    exitPracticeMode();
                    return;
                }
            }

            // Check hazard collision (before position update)
            if (practiceMode.hazards) {
                for (const hazard of practiceMode.hazards) {
                    if (checkCollision(player, hazard)) {
                        // Kill player and exit to main menu
                        practiceMode.isDead = true;
                        // Spawn death particles
                        spawnParticles(player.x + player.width / 2, player.y + player.height / 2, 30, 'rgb(255, 255, 255)');
                        // Skip physics this frame
                        return;
                    }
                }
            }

            // Check if player is grounded (calculate BEFORE physics)
            let isGrounded = false;
            for (const platform of practiceMode.platforms) {
                const onTop = player.y + player.height >= platform.y &&
                              player.y + player.height <= platform.y + 5;
                const horizontalOverlap = player.x + player.width > platform.x &&
                                         player.x < platform.x + platform.width;
                if (onTop && horizontalOverlap) {
                    isGrounded = true;
                    break;
                }
            }

            // STEP 1: Apply gravity with fast fall (scaled by size) - MATCHES MAIN MENU
            if ((practiceMode.keys['s'] || practiceMode.keys['ArrowDown']) && !isGrounded) {
                player.velocityY += GRAVITY * sizeScale * FAST_FALL_MULTIPLIER * deltaTime;
            } else {
                player.velocityY += GRAVITY * sizeScale * deltaTime;
            }

            // STEP 2: Handle input (movement scaled by size) - freeze movement during transition
            if (!player.sizeTransitioning) {
                const scaledMoveSpeed = MOVE_SPEED * sizeScale;
                if (practiceMode.keys['a'] || practiceMode.keys['ArrowLeft']) {
                    player.velocityX -= scaledMoveSpeed * deltaTime;
                }
                if (practiceMode.keys['d'] || practiceMode.keys['ArrowRight']) {
                    player.velocityX += scaledMoveSpeed * deltaTime;
                }
            }

            // Old action-based particle system
            // Track movement state for movement start particles
            const wasMovingLeft = player.prevVelocityX !== undefined && player.prevVelocityX < -0.5;
            const wasMovingRight = player.prevVelocityX !== undefined && player.prevVelocityX > 0.5;
            const isMovingLeft = player.velocityX < -0.5;
            const isMovingRight = player.velocityX > 0.5;

            // White particles on movement START
            if (isMovingLeft && !wasMovingLeft && Math.random() < 0.3) {
                spawnParticles(player.x + player.width / 2, player.y + player.height / 2, 2, 'rgb(255, 255, 255)', player.currentSize);
            }
            if (isMovingRight && !wasMovingRight && Math.random() < 0.3) {
                spawnParticles(player.x + player.width / 2, player.y + player.height / 2, 2, 'rgb(255, 255, 255)', player.currentSize);
            }

            // Orange speed-based particles
            const speed = Math.abs(player.velocityX);
            if (speed > 0.5) {
                const particleChance = Math.min(speed / 10, 0.8);
                if (Math.random() < particleChance) {
                    const particleCount = Math.floor(speed / 2);
                    spawnParticles(player.x + player.width / 2, player.y + player.height / 2, particleCount, 'rgb(255, 140, 66)', player.currentSize);
                }
            }

            // Store current velocity for next frame
            player.prevVelocityX = player.velocityX;

            // STEP 3: Jump with variable height based on hold time - MATCHES MAIN MENU
            if ((practiceMode.keys['w'] || practiceMode.keys['ArrowUp'] || practiceMode.keys[' '] || practiceMode.keys['Space']) && isGrounded && !practiceIsJumping) {
                player.velocityY = -1.5 * sizeScale; // Strong initial jump
                practiceIsJumping = true;
                player.jumpHoldTime = 0;
                // White jump particles
                spawnParticles(player.x + player.width / 2, player.y + player.height, 12, 'rgb(255, 255, 255)', player.currentSize);
            }

            // Continue adding upward velocity while holding button (extends jump height)
            if (practiceIsJumping && (practiceMode.keys['w'] || practiceMode.keys['ArrowUp'] || practiceMode.keys[' '] || practiceMode.keys['Space']) && player.velocityY < 0 && player.jumpHoldTime < MAX_JUMP_HOLD_TIME) {
                player.jumpHoldTime += deltaTime;
                const maxJumpVelocity = JUMP_POWER * sizeScale;
                if (Math.abs(player.velocityY) < maxJumpVelocity && player.jumpHoldTime < MAX_JUMP_HOLD_TIME) {
                    player.velocityY -= JUMP_CHARGE_RATE * sizeScale * deltaTime;
                }
            }

            // Stop adding velocity when button released
            if (practiceIsJumping && (!practiceMode.keys['w'] && !practiceMode.keys['ArrowUp'] && !practiceMode.keys[' '] && !practiceMode.keys['Space'])) {
                practiceIsJumping = false;
            }

            // Stop jump when time limit exceeded
            if (practiceIsJumping && player.jumpHoldTime >= MAX_JUMP_HOLD_TIME) {
                practiceIsJumping = false;
            }

            // Fast-fall particles (white) - spawn when holding down/S in air - MATCHES MAIN MENU
            if ((practiceMode.keys['s'] || practiceMode.keys['ArrowDown']) && !isGrounded && player.velocityY > 0) {
                if (Math.random() < 0.3) { // 30% chance each frame for smooth particle trail
                    spawnParticles(player.x + player.width / 2, player.y, 3, 'rgb(255, 255, 255)', player.currentSize);
                }
            }

            // STEP 4: Apply friction - MATCHES MAIN MENU
            if (isGrounded) {
                player.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                player.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Cap vertical velocity to prevent tunneling
            const maxFallSpeed = 8 * sizeScale;
            player.velocityY = Math.min(player.velocityY, maxFallSpeed);

            // Limit horizontal speed (scaled by size)
            const scaledMaxSpeed = GROUND_MAX_SPEED * sizeScale;
            player.velocityX = Math.max(-scaledMaxSpeed, Math.min(scaledMaxSpeed, player.velocityX));

            // Update position
            player.x += player.velocityX * deltaTime;
            player.y += player.velocityY * deltaTime;

            // Collision detection - matches level creator
            let newIsGrounded = false;
            for (const platform of practiceMode.platforms) {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {

                    const overlapLeft = (player.x + player.width) - platform.x;
                    const overlapRight = (platform.x + platform.width) - player.x;
                    const overlapTop = (player.y + player.height) - platform.y;
                    const overlapBottom = (platform.y + platform.height) - player.y;

                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    // Floor collision (landing on top)
                    if ((minOverlap === overlapTop && player.velocityY >= 0) ||
                        (player.velocityY > 0 && overlapTop < overlapBottom &&
                         overlapTop < overlapLeft * 0.5 && overlapTop < overlapRight * 0.5)) {
                        // Cyan landing particles if falling with significant velocity
                        if (player.velocityY > 2) {
                            spawnParticles(player.x + player.width / 2, player.y + player.height, 8, 'rgb(255, 255, 255)', player.currentSize);
                        }
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        newIsGrounded = true;
                    }
                    // Ceiling collision (hitting from below)
                    else if (minOverlap === overlapBottom && player.velocityY < 0) {
                        player.y = platform.y + platform.height;
                        player.velocityY = 0;
                    }
                    // Left wall collision
                    else if (minOverlap === overlapLeft) {
                        player.x = platform.x - player.width;
                        player.velocityX = 0;
                    }
                    // Right wall collision
                    else if (minOverlap === overlapRight) {
                        player.x = platform.x + platform.width;
                        player.velocityX = 0;
                    }
                }
            }

            // Update grounded state
            player.wasGrounded = newIsGrounded;

            // Reset jump state when grounded
            if (newIsGrounded && player.velocityY >= 0) {
                practiceIsJumping = false;
            }

            // Check credit collection
            for (const credit of practiceMode.credits) {
                if (!credit.collected && checkCollision(player, credit)) {
                    credit.collected = true;
                    practiceMode.creditsCollected++;
                    updateCredits(1);
                }
            }

            // Check grower collision (double size) - smooth transition like level creator
            if (practiceMode.growers) {
                for (const grower of practiceMode.growers) {
                    if (checkCollision(player, grower)) {
                        if (player.currentSize !== 80 && !player.sizeTransitioning) {
                            player.sizeTransitioning = true;
                            player.targetSize = 80;
                            player.sizeTransitionProgress = 0;
                        }
                    }
                }
            }

            // Check shrinker collision (half size) - smooth transition like level creator
            if (practiceMode.shrinkers) {
                for (const shrinker of practiceMode.shrinkers) {
                    if (checkCollision(player, shrinker)) {
                        if (player.currentSize !== 20 && !player.sizeTransitioning) {
                            player.sizeTransitioning = true;
                            player.targetSize = 20;
                            player.sizeTransitionProgress = 0;
                        }
                    }
                }
            }

            // Check default size block collision (reset to normal) - smooth transition like level creator
            if (practiceMode.defaultSizeBlocks) {
                for (const block of practiceMode.defaultSizeBlocks) {
                    if (checkCollision(player, block)) {
                        if (player.currentSize !== 40 && !player.sizeTransitioning) {
                            player.sizeTransitioning = true;
                            player.targetSize = 40;
                            player.sizeTransitionProgress = 0;
                        }
                    }
                }
            }

            // Update size transition (from level creator)
            if (player.sizeTransitioning) {
                player.sizeTransitionProgress += deltaTime * 0.1;  // Transition speed

                if (player.sizeTransitionProgress >= 1) {
                    // Transition complete
                    player.sizeTransitioning = false;
                    player.currentSize = player.targetSize;
                    player.width = player.targetSize;
                    player.height = player.targetSize;

                    // Check for wall collisions after size change and push player out
                    // This prevents phasing through walls when growing
                    for (const platform of practiceMode.platforms) {
                        if (player.x + player.width > platform.x &&
                            player.x < platform.x + platform.width &&
                            player.y + player.height > platform.y &&
                            player.y < platform.y + platform.height) {

                            const overlapLeft = (player.x + player.width) - platform.x;
                            const overlapRight = (platform.x + platform.width) - player.x;
                            const overlapTop = (player.y + player.height) - platform.y;
                            const overlapBottom = (platform.y + platform.height) - player.y;

                            const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                            // Push player out in direction of least overlap
                            if (minOverlap === overlapTop) {
                                player.y = platform.y - player.height;
                                player.velocityY = 0;
                            } else if (minOverlap === overlapBottom) {
                                player.y = platform.y + platform.height;
                                player.velocityY = 0;
                            } else if (minOverlap === overlapLeft) {
                                player.x = platform.x - player.width;
                                player.velocityX = 0;
                            } else if (minOverlap === overlapRight) {
                                player.x = platform.x + platform.width;
                                player.velocityX = 0;
                            }
                        }
                    }
                } else {
                    // Interpolate size from center
                    const startSize = player.currentSize;
                    const t = player.sizeTransitionProgress;
                    const newSize = startSize + (player.targetSize - startSize) * t;

                    // Calculate center point before resize
                    const centerX = player.x + player.width / 2;
                    const centerY = player.y + player.height / 2;

                    // Update size
                    player.width = newSize;
                    player.height = newSize;

                    // Reposition from center
                    player.x = centerX - player.width / 2;
                    player.y = centerY - player.height / 2;
                }
            }

            // Die if fall off - exit to main menu
            if (player.y > 900) {
                // Death particles
                spawnParticles(player.x + player.width / 2, player.y + player.height / 2, 30, 'rgb(255, 255, 255)');

                // Kill player and exit to main menu
                practiceMode.isDead = true;
            }

            // Update camera
            practiceMode.cameraX = player.x - 300;
            practiceMode.cameraY = 0;
        }

        // Party system
        async function createParty() {
            // Generate 4-letter party code
            const partyId = Array.from({length: 4}, () =>
                'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[Math.floor(Math.random() * 26)]
            ).join('');
            currentPartyId = partyId;

            await database.ref('parties/' + partyId).set({
                leaderId: currentUser.uid,
                mapId: maps[0].id,  // Default map
                raceStarted: false,
                members: {
                    [currentUser.uid]: {
                        username: currentUsername,
                        ready: false,
                        betting: false,
                        betAmount: 1
                    }
                },
                invitations: {},
                createdAt: firebase.database.ServerValue.TIMESTAMP
            });

            listenToParty(partyId);
            showScreen('partyScreen');
        }

        function listenToParty(partyId) {
            database.ref('parties/' + partyId).on('value', (snapshot) => {
                const party = snapshot.val();
                if (!party) {
                    // Party was deleted
                    currentPartyId = null;
                    backToMainMenu();
                    return;
                }

                currentParty = party;

                // Check if race started
                if (party.raceStarted && !raceState.active) {
                    startMultiplayerRace();
                } else {
                    updatePartyUI();
                }
            });

            // Listen for invitations
            database.ref('parties/' + partyId + '/invitations/' + currentUser.uid).on('value', (snapshot) => {
                const invite = snapshot.val();
                if (invite && invite.status === 'pending') {
                    // Show invitation
                }
            });
        }

        function updatePartyUI() {
            if (!currentParty) return;

            const isLeader = currentParty.leaderId === currentUser.uid;

            // Check betting status
            const allPlayers = Object.values(currentParty.members || {});
            const allBetting = allPlayers.every(p => p.betting === true);
            const noBetting = allPlayers.every(p => p.betting === false);
            const bettingMismatch = !allBetting && !noBetting;
            const allBets = allPlayers.filter(p => p.betting).map(p => p.betAmount);
            const allBetsMatch = allBets.length === 0 || allBets.every(bet => bet === allBets[0]);

            const myBetting = currentParty.members[currentUser.uid].betting;

            // Map options
            let mapOptions = '';
            for (const map of maps) {
                mapOptions += `<option value="${map.id}" ${currentParty.mapId === map.id ? 'selected' : ''}>${map.name}</option>`;
            }

            document.getElementById('partyInfo').innerHTML = `
                <div style="font-size: 20px; color: #4facfe; margin-bottom: 10px;">
                    Party ID: <span style="color: #FFC107;">${currentPartyId}</span>
                </div>
                <div>Share this ID with friends to invite them!</div>
                <div style="margin-top: 15px;">
                    <label>Map:</label>
                    <select id="partyMapSelect" onchange="updatePartyMap()" ${isLeader ? '' : 'disabled'}>
                        ${mapOptions}
                    </select>
                </div>
                <div style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                    <div style="margin-bottom: 10px;">
                        <label>
                            <input type="checkbox" id="partyBettingToggle" ${myBetting ? 'checked' : ''} onchange="togglePartyBetting()" style="width: auto; margin-right: 8px;">
                            Enable Betting
                        </label>
                    </div>
                    <div style="${myBetting ? '' : 'opacity: 0.5; pointer-events: none;'}">
                        <label>Bet Amount (credits):</label>
                        <input type="number" id="partyBetAmount" value="${currentParty.members[currentUser.uid].betAmount}" min="1" max="1000" onchange="updatePartyBet()">
                    </div>
                    <div style="font-size: 14px; margin-top: 10px;">
                        ${noBetting ? '<span style="color: #4CAF50;">✓ No betting - Just for fun!</span>' : ''}
                        ${allBetting && allBetsMatch ? `<span style="color: #4CAF50;">✓ All players betting ${allBets[0]} credit(s)</span>` : ''}
                        ${allBetting && !allBetsMatch ? '<span style="color: #ff4444;">⚠ All betting but amounts don\'t match!</span>' : ''}
                        ${bettingMismatch ? '<span style="color: #ff4444;">⚠ Some betting, some not - all must agree!</span>' : ''}
                    </div>
                </div>
            `;

            let membersHTML = '<h3>Members:</h3>';
            for (const [uid, member] of Object.entries(currentParty.members || {})) {
                const readyBadge = member.ready ? ' ✓' : '';
                const leaderBadge = uid === currentParty.leaderId ? ' [LEADER]' : '';
                const betInfo = member.betting ? `[Betting: ${member.betAmount}]` : '[No Betting]';
                const betColor = member.betting ? '#FFD700' : '#888';
                const isMe = uid === currentUser.uid ? ' (You)' : '';
                membersHTML += `<div class="party-member ${member.ready ? 'ready' : ''}">${member.username}${isMe}${leaderBadge} <span style="color: ${betColor};">${betInfo}</span>${readyBadge}</div>`;
            }
            document.getElementById('partyMembers').innerHTML = membersHTML;

            // Party controls
            const memberCount = Object.keys(currentParty.members || {}).length;
            const allReady = Object.values(currentParty.members).every(m => m.ready);
            const canStart = memberCount >= 2 && allReady && !bettingMismatch && allBetsMatch;

            let startHint = '';
            if (!canStart && allReady && memberCount >= 2) {
                if (bettingMismatch) {
                    startHint = '<div style="color: #ff4444; font-size: 12px; margin-top: 5px;">All players must agree on betting!</div>';
                } else if (!allBetsMatch) {
                    startHint = '<div style="color: #ff4444; font-size: 12px; margin-top: 5px;">All bet amounts must match!</div>';
                }
            }

            if (isLeader) {
                document.getElementById('partyControls').innerHTML = `
                    <button onclick="toggleReady()">Toggle Ready</button>
                    <button onclick="startPartyRace()" ${canStart ? '' : 'disabled'}>Start Race</button>
                    ${startHint}
                `;
            } else {
                document.getElementById('partyControls').innerHTML = `
                    <button onclick="toggleReady()">Toggle Ready</button>
                `;
            }
        }

        async function sendInvite() {
            const username = document.getElementById('inviteUsername').value.trim();
            if (!username) return;

            // Find user by username
            const usersSnapshot = await database.ref('users').orderByChild('username').equalTo(username).once('value');
            const users = usersSnapshot.val();

            if (!users) {
                alert('User not found');
                return;
            }

            const userId = Object.keys(users)[0];

            await database.ref('parties/' + currentPartyId + '/invitations/' + userId).set({
                username: username,
                status: 'pending',
                from: currentUsername
            });

            document.getElementById('inviteUsername').value = '';
            alert('Invite sent!');
        }

        async function joinPartyById() {
            const partyId = document.getElementById('partyIdInput').value.trim();
            if (!partyId) return;

            const partySnapshot = await database.ref('parties/' + partyId).once('value');
            if (!partySnapshot.exists()) {
                alert('Party not found');
                return;
            }

            currentPartyId = partyId;
            await database.ref('parties/' + partyId + '/members/' + currentUser.uid).set({
                username: currentUsername,
                ready: false,
                betting: false,
                betAmount: 1
            });

            listenToParty(partyId);
            showScreen('partyScreen');
        }

        async function togglePartyBetting() {
            const betting = document.getElementById('partyBettingToggle').checked;
            await database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid + '/betting').set(betting);
        }

        async function updatePartyBet() {
            const betAmount = Math.max(1, parseInt(document.getElementById('partyBetAmount').value) || 1);
            await database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid + '/betAmount').set(betAmount);
        }

        async function updatePartyMap() {
            const mapId = document.getElementById('partyMapSelect').value;
            await database.ref('parties/' + currentPartyId + '/mapId').set(mapId);
        }

        async function toggleReady() {
            if (!currentPartyId) return;
            const currentReady = currentParty.members[currentUser.uid].ready;
            await database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid + '/ready').set(!currentReady);
        }

        async function startPartyRace() {
            // Deduct credits if betting enabled
            const myMember = currentParty.members[currentUser.uid];
            if (myMember.betting) {
                await updateCredits(-myMember.betAmount, 'onhand');
            }

            // Mark race as started
            await database.ref('parties/' + currentPartyId).update({
                raceStarted: true,
                raceStartTime: firebase.database.ServerValue.TIMESTAMP
            });
        }

        async function leaveParty() {
            if (!currentPartyId) return;

            await database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid).remove();

            // If leader, delete party
            if (currentParty.leaderId === currentUser.uid) {
                await database.ref('parties/' + currentPartyId).remove();
            }

            database.ref('parties/' + currentPartyId).off();
            currentPartyId = null;
            backToMainMenu();
        }

        // Lobby system
        async function startRaceLobby() {
            const lobbyId = 'lobby_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            currentLobbyId = lobbyId;

            // Move all party members to lobby
            const lobbyPlayers = {};
            for (const [uid, member] of Object.entries(currentParty.members)) {
                lobbyPlayers[uid] = {
                    username: member.username,
                    ready: false,
                    betting: false, // Betting enabled/disabled
                    betAmount: 1, // Each player sets their own bet
                    credits: 0 // Will be fetched
                };
            }

            await database.ref('lobbies/' + lobbyId).set({
                mapId: maps[0].id,
                players: lobbyPlayers,
                raceStarted: false,
                leaderId: currentParty.leaderId
            });

            // Notify all party members to join lobby
            for (const uid of Object.keys(currentParty.members)) {
                await database.ref('parties/' + currentPartyId + '/lobbyId').set(lobbyId);
            }

            listenToLobby(lobbyId);
            showScreen('lobbyScreen');
        }

        function listenToLobby(lobbyId) {
            database.ref('lobbies/' + lobbyId).on('value', (snapshot) => {
                const lobby = snapshot.val();
                if (!lobby) {
                    currentLobbyId = null;
                    backToMainMenu();
                    return;
                }

                currentLobby = lobby;

                if (lobby.raceStarted && lobby.raceStartTime) {
                    startMultiplayerRace();
                } else {
                    updateLobbyUI();
                }
            });
        }

        function updateLobbyUI() {
            if (!currentLobby) return;

            const isLeader = currentLobby.leaderId === currentUser.uid;

            // Map selection
            let mapOptions = '';
            for (const map of maps) {
                mapOptions += `<option value="${map.id}" ${currentLobby.mapId === map.id ? 'selected' : ''}>${map.name}</option>`;
            }

            // Check betting status
            const allPlayers = Object.values(currentLobby.players || {});
            const allBetting = allPlayers.every(p => p.betting === true);
            const noBetting = allPlayers.every(p => p.betting === false);
            const bettingMismatch = !allBetting && !noBetting;

            // Check if all bets match (only matters if betting)
            const allBets = allPlayers.filter(p => p.betting).map(p => p.betAmount);
            const allBetsMatch = allBets.length === 0 || allBets.every(bet => bet === allBets[0]);
            const agreedBet = allBetsMatch && allBets.length > 0 ? allBets[0] : null;

            const myBetting = currentLobby.players[currentUser.uid].betting;

            document.getElementById('lobbyInfo').innerHTML = `
                <div>
                    <label>Map:</label>
                    <select id="lobbyMapSelect" onchange="updateLobbyMap()" ${isLeader ? '' : 'disabled'}>
                        ${mapOptions}
                    </select>
                </div>
                <div style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                    <div style="margin-bottom: 10px;">
                        <label>
                            <input type="checkbox" id="bettingToggle" ${myBetting ? 'checked' : ''} onchange="toggleBetting()" style="width: auto; margin-right: 8px;">
                            Enable Betting
                        </label>
                    </div>
                    <div id="betAmountSection" style="${myBetting ? '' : 'opacity: 0.5; pointer-events: none;'}">
                        <label>Bet Amount (credits):</label>
                        <input type="number" id="lobbyBetAmount" value="${currentLobby.players[currentUser.uid].betAmount}" min="1" max="1000" onchange="updateLobbyBet()">
                    </div>
                    <div style="font-size: 14px; margin-top: 10px;">
                        ${noBetting ? '<span style="color: #4CAF50;">✓ No betting - Just for fun!</span>' : ''}
                        ${allBetting && allBetsMatch ? `<span style="color: #4CAF50;">✓ All players betting ${agreedBet} credit(s)</span>` : ''}
                        ${allBetting && !allBetsMatch ? '<span style="color: #ff4444;">⚠ All betting but amounts don\'t match!</span>' : ''}
                        ${bettingMismatch ? '<span style="color: #ff4444;">⚠ Some betting, some not - all must agree!</span>' : ''}
                    </div>
                </div>
            `;

            // Players with their bet amounts and betting status
            let playersHTML = '<h3>Players:</h3>';
            for (const [uid, player] of Object.entries(currentLobby.players || {})) {
                const readyBadge = player.ready ? ' ✓' : '';
                const betInfo = player.betting ? `[Betting: ${player.betAmount}]` : '[No Betting]';
                const isMe = uid === currentUser.uid ? ' (You)' : '';
                const betColor = player.betting ? '#FFD700' : '#888';
                playersHTML += `<div class="party-member ${player.ready ? 'ready' : ''}">${player.username}${isMe} <span style="color: ${betColor};">${betInfo}</span>${readyBadge}</div>`;
            }
            document.getElementById('lobbyPlayers').innerHTML = playersHTML;

            // Controls
            const allReady = Object.values(currentLobby.players).every(p => p.ready);
            const canStart = allReady && !bettingMismatch && allBetsMatch;

            let startHint = '';
            if (!canStart && allReady) {
                if (bettingMismatch) {
                    startHint = '<div style="color: #ff4444; font-size: 12px; margin-top: 5px;">All players must agree on betting!</div>';
                } else if (!allBetsMatch) {
                    startHint = '<div style="color: #ff4444; font-size: 12px; margin-top: 5px;">All bet amounts must match!</div>';
                }
            }

            if (isLeader) {
                document.getElementById('lobbyControls').innerHTML = `
                    <button onclick="toggleLobbyReady()">Toggle Ready</button>
                    <button onclick="startRace()" ${canStart ? '' : 'disabled'}>Start Race</button>
                    ${startHint}
                `;
            } else {
                document.getElementById('lobbyControls').innerHTML = `
                    <button onclick="toggleLobbyReady()">Toggle Ready</button>
                `;
            }
        }

        async function updateLobbyMap() {
            const mapId = document.getElementById('lobbyMapSelect').value;
            await database.ref('lobbies/' + currentLobbyId + '/mapId').set(mapId);
        }

        async function toggleBetting() {
            const betting = document.getElementById('bettingToggle').checked;
            await database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid + '/betting').set(betting);
        }

        async function updateLobbyBet() {
            const betAmount = Math.max(1, parseInt(document.getElementById('lobbyBetAmount').value) || 1);
            await database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid + '/betAmount').set(betAmount);
        }

        async function toggleLobbyReady() {
            if (!currentLobbyId) return;
            const currentReady = currentLobby.players[currentUser.uid].ready;
            await database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid + '/ready').set(!currentReady);
        }

        async function startRace() {
            // Deduct bet from player's credits only if betting is enabled
            const myPlayer = currentLobby.players[currentUser.uid];
            if (myPlayer.betting) {
                await updateCredits(-myPlayer.betAmount, 'onhand');
            }

            await database.ref('lobbies/' + currentLobbyId).update({
                raceStarted: true,
                raceStartTime: firebase.database.ServerValue.TIMESTAMP
            });
        }

        async function leaveLobby() {
            if (!currentLobbyId) return;
            database.ref('lobbies/' + currentLobbyId).off();
            await database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid).remove();
            currentLobbyId = null;
            backToMainMenu();
        }

        // Multiplayer racing
        let raceState = {
            active: false,
            player: null,
            opponents: {},
            map: null,
            startTime: 0,
            finishTime: 0,
            finished: false,
            cameraX: 0,
            cameraY: 0,
            keys: {},
            platforms: [],
            hazards: [],
            respawnCountdown: 0, // Countdown timer before respawn
            isDead: false // Whether player is in death state
        };

        async function startMultiplayerRace() {
            const canvas = document.getElementById('raceCanvas');
            const ctx = canvas.getContext('2d');
            canvas.style.display = 'block';
            document.getElementById('timer').style.display = 'block';
            document.getElementById('racePositions').style.display = 'block';

            // Hide party screen
            document.getElementById('partyScreen').classList.remove('active');

            // Get map from party (not lobby)
            raceState.map = maps.find(m => m.id === currentParty.mapId);
            raceState.platforms = raceState.map.platforms;
            raceState.hazards = raceState.map.hazards;

            // Create player at start position
            raceState.player = new Player(raceState.map.start.x, raceState.map.start.y, equippedCosmetics);
            raceState.active = true;
            raceState.finished = false;
            raceState.startTime = Date.now();

            // Countdown
            await showCountdown();

            // Listen for opponent positions (use party members, not lobby players)
            // With smooth interpolation for lagless movement
            database.ref('parties/' + currentPartyId + '/members').on('value', (snapshot) => {
                const members = snapshot.val();
                if (!members) return;

                for (const [uid, member] of Object.entries(members)) {
                    if (uid !== currentUser.uid && member.position) {
                        if (!raceState.opponents[uid]) {
                            // New opponent - create player
                            raceState.opponents[uid] = {
                                username: member.username,
                                player: new Player(member.position.x, member.position.y, member.equippedCosmetics || {}),
                                finished: member.finished || false,
                                targetX: member.position.x,
                                targetY: member.position.y
                            };
                        } else {
                            // Existing opponent - update target position for interpolation
                            raceState.opponents[uid].targetX = member.position.x;
                            raceState.opponents[uid].targetY = member.position.y;
                            raceState.opponents[uid].finished = member.finished || false;
                            if (member.size) {
                                raceState.opponents[uid].player.currentSize = member.size;
                                raceState.opponents[uid].player.width = member.size;
                                raceState.opponents[uid].player.height = member.size;
                            }
                        }
                    }
                }

                // Remove opponents who left
                for (const uid in raceState.opponents) {
                    if (!members[uid]) {
                        delete raceState.opponents[uid];
                    }
                }
            });

            // Start position sync (use party path, not lobby path)
            // Update every 16ms (~60fps) for ultra-smooth multiplayer movement
            const positionSyncInterval = setInterval(() => {
                if (!raceState.active || raceState.finished) {
                    clearInterval(positionSyncInterval);
                    return;
                }

                database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid).update({
                    position: { x: raceState.player.x, y: raceState.player.y },
                    velocity: { x: raceState.player.velocityX, y: raceState.player.velocityY },
                    equippedCosmetics: equippedCosmetics,
                    size: raceState.player.currentSize
                });
            }, 16);

            let lastRaceFrameTime = performance.now();
            function raceLoop(currentTime) {
                if (!raceState.active) return;

                // Calculate delta time
                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastRaceFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                lastRaceFrameTime = currentTime;

                // Update
                updateRacePlayer(deltaTime);

                // Check finish
                if (!raceState.finished && checkCollision(raceState.player, raceState.map.finish)) {
                    finishRace();
                }

                // Update timer
                const elapsed = (Date.now() - raceState.startTime) / 1000;
                document.getElementById('timer').textContent = elapsed.toFixed(2);

                // Update positions
                updateRacePositions();

                // Render
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw background 40x40px gridlines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;

                // Vertical lines
                const startX = Math.floor(raceState.cameraX / 40) * 40;
                for (let x = startX; x < raceState.cameraX + canvas.width; x += 40) {
                    const screenX = x - raceState.cameraX;
                    ctx.beginPath();
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, canvas.height);
                    ctx.stroke();
                }

                // Horizontal lines
                const startY = Math.floor(raceState.cameraY / 40) * 40;
                for (let y = startY; y < raceState.cameraY + canvas.height; y += 40) {
                    const screenY = y - raceState.cameraY;
                    ctx.beginPath();
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(canvas.width, screenY);
                    ctx.stroke();
                }

                // Draw platforms - standardized
                for (const platform of raceState.platforms) {
                    const screenX = platform.x - raceState.cameraX;
                    const screenY = platform.y - raceState.cameraY;

                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(screenX, screenY, platform.width, platform.height);

                    // Thicker dark border (inside edge)
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(screenX + 2, screenY + 2, platform.width - 4, platform.height - 4);

                    // Inner 40x40 grid lines
                    ctx.strokeStyle = '#388E3C';
                    ctx.lineWidth = 1;
                    for (let gx = 40; gx < platform.width; gx += 40) {
                        ctx.beginPath();
                        ctx.moveTo(screenX + gx, screenY);
                        ctx.lineTo(screenX + gx, screenY + platform.height);
                        ctx.stroke();
                    }
                    for (let gy = 40; gy < platform.height; gy += 40) {
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY + gy);
                        ctx.lineTo(screenX + platform.width, screenY + gy);
                        ctx.stroke();
                    }
                }

                // Draw hazards (red with inner borders)
                ctx.fillStyle = '#FF3333';
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 4;
                for (const hazard of raceState.hazards) {
                    const screenX = hazard.x - raceState.cameraX;
                    const screenY = hazard.y - raceState.cameraY;
                    ctx.fillRect(screenX, screenY, hazard.width, hazard.height);
                    ctx.strokeRect(screenX + 2, screenY + 2, hazard.width - 4, hazard.height - 4);
                }

                // Draw finish line
                const finishScreenX = raceState.map.finish.x - raceState.cameraX;
                const finishScreenY = raceState.map.finish.y - raceState.cameraY;
                ctx.fillStyle = '#00FF00';
                ctx.fillRect(finishScreenX, finishScreenY, raceState.map.finish.width, raceState.map.finish.height);

                // Interpolate and draw opponents for smooth movement
                for (const opponent of Object.values(raceState.opponents)) {
                    // Smooth interpolation towards target position (reduces jitter)
                    const interpolationSpeed = 0.3; // 30% lerp each frame = smooth but responsive
                    if (opponent.targetX !== undefined) {
                        opponent.player.x += (opponent.targetX - opponent.player.x) * interpolationSpeed;
                        opponent.player.y += (opponent.targetY - opponent.player.y) * interpolationSpeed;
                    }

                    opponent.player.updateTrail();
                    opponent.player.draw(ctx, raceState.cameraX, raceState.cameraY, true, opponent.username, false);
                }

                // Draw local player
                raceState.player.updateTrail();
                raceState.player.draw(ctx, raceState.cameraX, raceState.cameraY, true, currentUsername, true);

                requestAnimationFrame(raceLoop);
            }

            raceLoop();
        }

        function updateRacePlayer(deltaTime = 1) {
            const player = raceState.player;
            const sizeScale = player.currentSize / 40;

            // Handle respawn countdown
            if (raceState.isDead) {
                raceState.respawnCountdown -= deltaTime;
                if (raceState.respawnCountdown <= 0) {
                    // Respawn player
                    player.x = raceState.map.start.x;
                    player.y = raceState.map.start.y;
                    player.velocityX = 0;
                    player.velocityY = 0;
                    raceIsJumping = false;
                    raceState.isDead = false;
                }
                // Skip physics while dead
                return;
            }

            // Check hazards first (before position update)
            for (const hazard of raceState.hazards) {
                if (checkCollision(player, hazard)) {
                    // Kill player and start countdown
                    raceState.isDead = true;
                    raceState.respawnCountdown = 180; // 3 seconds at 60fps
                    // Spawn death particles
                    spawnParticles(player.x + player.width / 2, player.y + player.height / 2, 30, 'rgb(255, 255, 255)');
                    // Skip physics this frame
                    return;
                }
            }

            // STEP 1: Calculate grounded state BEFORE physics (matches main menu)
            let isGrounded = false;
            for (const platform of raceState.platforms) {
                const onTop = player.y + player.height >= platform.y &&
                              player.y + player.height <= platform.y + 5;
                const horizontalOverlap = player.x + player.width > platform.x &&
                                         player.x < platform.x + platform.width;

                if (onTop && horizontalOverlap) {
                    isGrounded = true;
                    break;
                }
            }

            // STEP 2: Apply gravity with fast fall (scaled by size) - MATCHES MAIN MENU
            if ((raceState.keys['s'] || raceState.keys['ArrowDown']) && !isGrounded) {
                player.velocityY += GRAVITY * sizeScale * FAST_FALL_MULTIPLIER * deltaTime;
            } else {
                player.velocityY += GRAVITY * sizeScale * deltaTime;
            }

            // STEP 3: Handle input (movement scaled by size)
            const scaledMoveSpeed = MOVE_SPEED * sizeScale;
            if (raceState.keys['a'] || raceState.keys['ArrowLeft']) {
                player.velocityX -= scaledMoveSpeed * deltaTime;
            }
            if (raceState.keys['d'] || raceState.keys['ArrowRight']) {
                player.velocityX += scaledMoveSpeed * deltaTime;
            }

            // Old action-based particle system
            // Track movement state for movement start particles
            const wasMovingLeft = player.prevVelocityX !== undefined && player.prevVelocityX < -0.5;
            const wasMovingRight = player.prevVelocityX !== undefined && player.prevVelocityX > 0.5;
            const isMovingLeft = player.velocityX < -0.5;
            const isMovingRight = player.velocityX > 0.5;

            // White particles on movement START (when starting to move from stopped/opposite direction)
            if (isMovingLeft && !wasMovingLeft && Math.random() < 0.3) {
                spawnParticles(player.x + player.width / 2, player.y + player.height / 2, 2, 'rgb(255, 255, 255)', player.currentSize);
            }
            if (isMovingRight && !wasMovingRight && Math.random() < 0.3) {
                spawnParticles(player.x + player.width / 2, player.y + player.height / 2, 2, 'rgb(255, 255, 255)', player.currentSize);
            }

            // Orange speed-based particles (when moving fast horizontally)
            const speed = Math.abs(player.velocityX);
            if (speed > 0.5) {
                const particleChance = Math.min(speed / 10, 0.8);
                if (Math.random() < particleChance) {
                    const particleCount = Math.floor(speed / 2);
                    spawnParticles(player.x + player.width / 2, player.y + player.height / 2, particleCount, 'rgb(255, 140, 66)', player.currentSize);
                }
            }

            // Store current velocity for next frame
            player.prevVelocityX = player.velocityX;

            // Jump with variable height based on hold time (W or Up only, NOT space)
            if ((raceState.keys['w'] || raceState.keys['ArrowUp']) && isGrounded && !raceIsJumping) {
                // Start jump immediately with strong initial velocity
                player.velocityY = -1.5 * sizeScale; // Strong initial jump
                raceIsJumping = true;
                player.jumpHoldTime = 0;
                // White jump particles
                spawnParticles(player.x + player.width / 2, player.y + player.height, 12, 'rgb(255, 255, 255)', player.currentSize);
            }

            // Continue adding upward velocity while holding button (extends jump height)
            if (raceIsJumping && (raceState.keys['w'] || raceState.keys['ArrowUp']) && player.velocityY < 0 && player.jumpHoldTime < MAX_JUMP_HOLD_TIME) {
                player.jumpHoldTime += deltaTime;

                // Add upward acceleration while holding (max height = 4x playerSize + 1px)
                const maxJumpVelocity = JUMP_POWER * sizeScale;
                if (Math.abs(player.velocityY) < maxJumpVelocity && player.jumpHoldTime < MAX_JUMP_HOLD_TIME) {
                    player.velocityY -= JUMP_CHARGE_RATE * sizeScale * deltaTime;
                }
            }

            // Stop adding velocity when button released
            if (raceIsJumping && (!raceState.keys['w'] && !raceState.keys['ArrowUp'])) {
                raceIsJumping = false;
            }

            // Stop jump when time limit exceeded
            if (raceIsJumping && player.jumpHoldTime >= MAX_JUMP_HOLD_TIME) {
                raceIsJumping = false;
            }

            // Reset jump state when grounded
            if (isGrounded && player.velocityY >= 0) {
                raceIsJumping = false;
            }

            // Fast-fall particles (white) - spawn when holding down/S in air
            if ((raceState.keys['s'] || raceState.keys['ArrowDown']) && !isGrounded && player.velocityY > 0) {
                // Spawn particles continuously during fast fall
                if (Math.random() < 0.3) { // 30% chance each frame for smooth particle trail
                    spawnParticles(player.x + player.width / 2, player.y, 3, 'rgb(255, 255, 255)', player.currentSize);
                }
            }

            // STEP 4: Apply friction using exponential decay
            if (isGrounded) {
                player.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                player.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // STEP 5: Cap vertical velocity to prevent tunneling (scaled by size)
            const maxFallSpeed = 8 * sizeScale;
            player.velocityY = Math.min(player.velocityY, maxFallSpeed);

            // Limit horizontal speed (scaled by size)
            const scaledMaxSpeed = GROUND_MAX_SPEED * sizeScale;
            player.velocityX = Math.max(-scaledMaxSpeed, Math.min(scaledMaxSpeed, player.velocityX));

            // STEP 6: Update position HORIZONTALLY first, then check X collisions
            player.x += player.velocityX * deltaTime;

            // Check horizontal collisions
            for (const platform of raceState.platforms) {
                if (checkCollision(player, platform)) {
                    if (player.velocityX > 0) {
                        // Moving right, hit left side of platform
                        player.x = platform.x - player.width;
                    } else if (player.velocityX < 0) {
                        // Moving left, hit right side of platform
                        player.x = platform.x + platform.width;
                    }
                    player.velocityX = 0;
                }
            }

            // Update position VERTICALLY, then check Y collisions
            player.y += player.velocityY * deltaTime;

            // Check vertical collisions
            for (const platform of raceState.platforms) {
                if (checkCollision(player, platform)) {
                    if (player.velocityY > 0) {
                        // Moving down, hit top of platform
                        // White landing particles if falling with significant velocity
                        if (player.velocityY > 2) {
                            spawnParticles(player.x + player.width / 2, player.y + player.height, 8, 'rgb(255, 255, 255)', player.currentSize);
                        }
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                    } else if (player.velocityY < 0) {
                        // Moving up, hit bottom of platform
                        player.y = platform.y + platform.height;
                        player.velocityY = 0;
                        raceIsJumping = false;
                    }
                }
            }

            // Update camera
            raceState.cameraX = player.x - 400;
            raceState.cameraY = player.y - 300;
        }

        function updateRacePositions() {
            // Calculate positions based on distance to finish
            const finishX = raceState.map.finish.x;

            const positions = [
                { uid: currentUser.uid, username: currentUsername, distance: Math.abs(raceState.player.x - finishX), finished: raceState.finished }
            ];

            for (const [uid, opponent] of Object.entries(raceState.opponents)) {
                positions.push({
                    uid: uid,
                    username: opponent.username,
                    distance: Math.abs(opponent.player.x - finishX),
                    finished: opponent.finished
                });
            }

            positions.sort((a, b) => {
                if (a.finished && !b.finished) return -1;
                if (!a.finished && b.finished) return 1;
                return a.distance - b.distance;
            });

            let html = '<h3>Positions</h3>';
            for (let i = 0; i < positions.length; i++) {
                html += `<div>${i + 1}. ${positions[i].username}${positions[i].finished ? ' [FINISHED]' : ''}</div>`;
            }
            document.getElementById('racePositions').innerHTML = html;
        }

        async function finishRace() {
            raceState.finished = true;
            raceState.finishTime = Date.now() - raceState.startTime;

            await database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid).update({
                finished: true,
                finishTime: raceState.finishTime
            });

            // Check if all finished
            setTimeout(checkRaceComplete, 2000);
        }

        async function checkRaceComplete() {
            const snapshot = await database.ref('parties/' + currentPartyId + '/members').once('value');
            const members = snapshot.val();

            const allFinished = Object.values(members).every(m => m.finished);

            if (allFinished) {
                // Calculate results
                const results = [];
                for (const [uid, member] of Object.entries(members)) {
                    results.push({
                        uid: uid,
                        username: member.username,
                        time: member.finishTime
                    });
                }

                results.sort((a, b) => a.time - b.time);

                // Check if betting was enabled
                const bettingEnabled = Object.values(members).some(m => m.betting);
                const pot = bettingEnabled ? Object.values(members).filter(m => m.betting).reduce((sum, m) => sum + (m.betAmount || 0), 0) : 0;

                // Award credits to winner only if betting was enabled
                if (bettingEnabled && results[0].uid === currentUser.uid) {
                    await updateCredits(pot, 'onhand');
                    userStats.racesWon++;
                } else if (bettingEnabled) {
                    // Lost - already deducted at race start
                }

                userStats.racesPlayed++;
                await database.ref('players/' + currentUser.uid + '/stats').set(userStats);

                // Show results
                showRaceResults(results, pot, bettingEnabled);
            }
        }

        function showRaceResults(results, pot, bettingEnabled) {
            let html = '';
            for (let i = 0; i < results.length; i++) {
                const isMe = results[i].uid === currentUser.uid;
                const isWinner = i === 0;
                html += `<div class="result-entry ${isWinner ? 'winner' : ''}" style="${isMe ? 'font-weight: bold; color: #4facfe;' : ''}">
                    ${i + 1}. ${results[i].username} - ${(results[i].time / 1000).toFixed(2)}s
                </div>`;
            }

            if (bettingEnabled) {
                if (results[0].uid === currentUser.uid) {
                    html = `<div style="color: #FFD700; font-size: 24px; margin-bottom: 20px;">YOU WIN! +${pot} credits</div>` + html;
                } else {
                    const myBet = currentParty.members[currentUser.uid].betAmount;
                    html = `<div style="color: #ff4444; font-size: 18px; margin-bottom: 20px;">You lost ${myBet} credits</div>` + html;
                }
            } else {
                if (results[0].uid === currentUser.uid) {
                    html = `<div style="color: #FFD700; font-size: 24px; margin-bottom: 20px;">YOU WIN!</div>` + html;
                } else {
                    html = `<div style="color: #888; font-size: 18px; margin-bottom: 20px;">No betting - Just for fun!</div>` + html;
                }
            }

            document.getElementById('resultsContent').innerHTML = html;
            document.getElementById('raceResults').style.display = 'block';
        }

        async function returnToParty() {
            document.getElementById('raceResults').style.display = 'none';
            document.getElementById('raceCanvas').style.display = 'none';
            document.getElementById('timer').style.display = 'none';
            document.getElementById('racePositions').style.display = 'none';

            raceState.active = false;
            database.ref('lobbies/' + currentLobbyId + '/players').off();
            if (currentPartyId) {
                database.ref('parties/' + currentPartyId + '/members').off();
            }

            await database.ref('lobbies/' + currentLobbyId).remove();

            showScreen('partyScreen');
        }

        async function showCountdown() {
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';

            for (let i = 3; i > 0; i--) {
                countdownEl.textContent = i;
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            countdownEl.textContent = 'GO!';
            await new Promise(resolve => setTimeout(resolve, 500));
            countdownEl.style.display = 'none';
        }

        // Shop hub (portal selection screen)
        function showShop() {
            showScreen('shopHubScreen');
            shopHubActive = true;

            const canvas = document.getElementById('shopHubCanvas');
            const ctx = canvas.getContext('2d');

            const portalWidth = 120;
            const portalHeight = 40;
            const groundY = 720;

            shopHubPlatforms = [
                // Boundary walls - thick floor (80px), side walls (40px), ceiling (40px)
                { x: 0, y: 0, width: 40, height: 800 }, // Left wall
                { x: 1160, y: 0, width: 40, height: 800 }, // Right wall
                { x: 0, y: 0, width: 1200, height: 40 }, // Ceiling
                { x: 0, y: 720, width: 1200, height: 80 }, // Ground

                // Exit portal (left side)
                {
                    x: 150,
                    y: groundY - 120,
                    width: portalWidth,
                    height: portalHeight,
                    action: 'exit',
                    label: 'EXIT'
                },

                // Cosmetics portal (center-left)
                {
                    x: 450,
                    y: groundY - 120,
                    width: portalWidth,
                    height: portalHeight,
                    action: 'cosmetics',
                    label: 'COSMETICS'
                },

                // Backpack portal (center-right)
                {
                    x: 630,
                    y: groundY - 120,
                    width: portalWidth,
                    height: portalHeight,
                    action: 'backpack',
                    label: 'BACKPACK'
                }
            ];

            // Create player on ground
            const spawnX = 600 - 20; // Center
            const spawnY = groundY - 40; // On top of ground
            shopHubPlayer = new Player(spawnX, spawnY, equippedCosmetics);

            // Start render loop
            let lastFrameTime = performance.now();
            function shopHubLoop(currentTime) {
                if (!shopHubActive) return;

                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                lastFrameTime = currentTime;

                updateShopHub(deltaTime);
                renderShopHub(ctx, deltaTime);

                requestAnimationFrame(shopHubLoop);
            }
            shopHubLoop();
        }

        function updateShopHub(deltaTime) {
            if (!shopHubPlayer) return;

            // Check current grounded state BEFORE applying physics (MATCHES MAIN MENU)
            let isGrounded = false;
            let standingOnPlatform = null;
            for (const platform of shopHubPlatforms) {
                const onTop = shopHubPlayer.y + shopHubPlayer.height >= platform.y &&
                              shopHubPlayer.y + shopHubPlayer.height <= platform.y + 5;
                const horizontalOverlap = shopHubPlayer.x + shopHubPlayer.width > platform.x &&
                                         shopHubPlayer.x < platform.x + platform.width;

                if (onTop && horizontalOverlap) {
                    isGrounded = true;
                    standingOnPlatform = platform;
                    break;
                }
            }

            shopHubPlayer.wasGrounded = isGrounded;

            // Check for platform interaction when standing on action platform
            if (standingOnPlatform && standingOnPlatform.action) {
                if (shopHubKeys[' ']) {
                    if (standingOnPlatform.action === 'exit') {
                        shopHubActive = false;
                        backToMainMenu();
                    } else if (standingOnPlatform.action === 'cosmetics') {
                        shopHubActive = false;
                        showCosmeticsShop();
                    } else if (standingOnPlatform.action === 'backpack') {
                        shopHubActive = false;
                        showBackpackShop();
                    }
                }
            }

            // Apply gravity with fast fall (MATCHES MAIN MENU)
            const sizeScale = shopHubPlayer.currentSize / 40;
            if ((shopHubKeys['s'] || shopHubKeys['ArrowDown']) && !isGrounded) {
                shopHubPlayer.velocityY += GRAVITY * sizeScale * FAST_FALL_MULTIPLIER * deltaTime;
            } else {
                shopHubPlayer.velocityY += GRAVITY * sizeScale * deltaTime;
            }

            // Handle input (movement scaled by size) (MATCHES MAIN MENU)
            const scaledMoveSpeed = MOVE_SPEED * sizeScale;
            if (shopHubKeys['a'] || shopHubKeys['ArrowLeft']) {
                shopHubPlayer.velocityX -= scaledMoveSpeed * deltaTime;
            }
            if (shopHubKeys['d'] || shopHubKeys['ArrowRight']) {
                shopHubPlayer.velocityX += scaledMoveSpeed * deltaTime;
            }

            // Old action-based particle system (MATCHES MAIN MENU)
            // Track movement state for movement start particles
            const wasMovingLeft = shopHubPlayer.prevVelocityX !== undefined && shopHubPlayer.prevVelocityX < -0.5;
            const wasMovingRight = shopHubPlayer.prevVelocityX !== undefined && shopHubPlayer.prevVelocityX > 0.5;
            const isMovingLeft = shopHubPlayer.velocityX < -0.5;
            const isMovingRight = shopHubPlayer.velocityX > 0.5;

            // White particles on movement START (when starting to move from stopped/opposite direction)
            if (isMovingLeft && !wasMovingLeft && Math.random() < 0.3) {
                spawnParticles(shopHubPlayer.x + shopHubPlayer.width / 2, shopHubPlayer.y + shopHubPlayer.height / 2, 2, 'rgb(255, 255, 255)', shopHubPlayer.currentSize);
            }
            if (isMovingRight && !wasMovingRight && Math.random() < 0.3) {
                spawnParticles(shopHubPlayer.x + shopHubPlayer.width / 2, shopHubPlayer.y + shopHubPlayer.height / 2, 2, 'rgb(255, 255, 255)', shopHubPlayer.currentSize);
            }

            // Orange speed-based particles (when moving fast horizontally)
            const speed = Math.abs(shopHubPlayer.velocityX);
            if (speed > 0.5) {
                const particleChance = Math.min(speed / 10, 0.8);
                if (Math.random() < particleChance) {
                    const particleCount = Math.floor(speed / 2);
                    spawnParticles(shopHubPlayer.x + shopHubPlayer.width / 2, shopHubPlayer.y + shopHubPlayer.height / 2, particleCount, 'rgb(255, 140, 66)', shopHubPlayer.currentSize);
                }
            }

            // Store current velocity for next frame
            shopHubPlayer.prevVelocityX = shopHubPlayer.velocityX;

            // Jump with variable height based on hold time (W or Up Arrow only, NOT space) (MATCHES MAIN MENU)
            if ((shopHubKeys['w'] || shopHubKeys['ArrowUp']) && isGrounded && !shopHubIsJumping) {
                // Start jump immediately with strong initial velocity
                const sizeScale = shopHubPlayer.currentSize / 40;
                shopHubPlayer.velocityY = -1.5 * sizeScale; // Strong initial jump
                shopHubIsJumping = true;
                shopHubPlayer.jumpHoldTime = 0;
                // White jump particles
                spawnParticles(shopHubPlayer.x + shopHubPlayer.width / 2, shopHubPlayer.y + shopHubPlayer.height, 12, 'rgb(255, 255, 255)', shopHubPlayer.currentSize);
            }

            // Continue adding upward velocity while holding button (extends jump height)
            if (shopHubIsJumping && (shopHubKeys['w'] || shopHubKeys['ArrowUp']) && shopHubPlayer.velocityY < 0 && shopHubPlayer.jumpHoldTime < MAX_JUMP_HOLD_TIME) {
                const sizeScale = shopHubPlayer.currentSize / 40;
                shopHubPlayer.jumpHoldTime += deltaTime;

                // Add upward acceleration while holding (max height = 4x playerSize + 1px)
                const maxJumpVelocity = JUMP_POWER * sizeScale;
                if (Math.abs(shopHubPlayer.velocityY) < maxJumpVelocity && shopHubPlayer.jumpHoldTime < MAX_JUMP_HOLD_TIME) {
                    shopHubPlayer.velocityY -= JUMP_CHARGE_RATE * sizeScale * deltaTime;
                }
            }

            // Stop adding velocity when button released
            if (shopHubIsJumping && (!shopHubKeys['w'] && !shopHubKeys['ArrowUp'])) {
                shopHubIsJumping = false;
            }

            // Stop jump when time limit exceeded
            if (shopHubIsJumping && shopHubPlayer.jumpHoldTime >= MAX_JUMP_HOLD_TIME) {
                shopHubIsJumping = false;
            }

            // Reset jump state when grounded
            if (isGrounded && shopHubPlayer.velocityY >= 0) {
                shopHubIsJumping = false;
            }

            // Fast-fall particles (white) - spawn when holding down/S in air (MATCHES MAIN MENU)
            if ((shopHubKeys['s'] || shopHubKeys['ArrowDown']) && !isGrounded && shopHubPlayer.velocityY > 0) {
                // Spawn particles continuously during fast fall
                if (Math.random() < 0.3) { // 30% chance each frame for smooth particle trail
                    spawnParticles(shopHubPlayer.x + shopHubPlayer.width / 2, shopHubPlayer.y, 3, 'rgb(255, 255, 255)', shopHubPlayer.currentSize);
                }
            }

            // Apply friction using exponential decay (MATCHES MAIN MENU)
            if (isGrounded) {
                shopHubPlayer.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                shopHubPlayer.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Cap vertical velocity to prevent tunneling (scaled by size) (MATCHES MAIN MENU)
            const maxFallSpeed = 8 * sizeScale;
            shopHubPlayer.velocityY = Math.min(shopHubPlayer.velocityY, maxFallSpeed);

            // Limit horizontal speed (scaled by size) (MATCHES MAIN MENU)
            const scaledMaxSpeed = GROUND_MAX_SPEED * sizeScale;
            shopHubPlayer.velocityX = Math.max(-scaledMaxSpeed, Math.min(scaledMaxSpeed, shopHubPlayer.velocityX));

            // Update position HORIZONTALLY first, then check X collisions (MATCHES MAIN MENU)
            shopHubPlayer.x += shopHubPlayer.velocityX * deltaTime;

            // Check horizontal collisions
            for (const platform of shopHubPlatforms) {
                if (checkCollision(shopHubPlayer, platform)) {
                    if (shopHubPlayer.velocityX > 0) {
                        // Moving right, hit left side of platform
                        shopHubPlayer.x = platform.x - shopHubPlayer.width;
                    } else if (shopHubPlayer.velocityX < 0) {
                        // Moving left, hit right side of platform
                        shopHubPlayer.x = platform.x + platform.width;
                    }
                    shopHubPlayer.velocityX = 0;
                }
            }

            // Update position VERTICALLY, then check Y collisions (MATCHES MAIN MENU)
            shopHubPlayer.y += shopHubPlayer.velocityY * deltaTime;

            // Check vertical collisions
            for (const platform of shopHubPlatforms) {
                if (checkCollision(shopHubPlayer, platform)) {
                    if (shopHubPlayer.velocityY > 0) {
                        // Moving down, hit top of platform
                        // White landing particles if falling with significant velocity
                        if (shopHubPlayer.velocityY > 2) {
                            spawnParticles(shopHubPlayer.x + shopHubPlayer.width / 2, shopHubPlayer.y + shopHubPlayer.height, 8, 'rgb(255, 255, 255)', shopHubPlayer.currentSize);
                        }
                        shopHubPlayer.y = platform.y - shopHubPlayer.height;
                        shopHubPlayer.velocityY = 0;
                    } else if (shopHubPlayer.velocityY < 0) {
                        // Moving up, hit bottom of platform
                        shopHubPlayer.y = platform.y + platform.height;
                        shopHubPlayer.velocityY = 0;
                        shopHubIsJumping = false;
                    }
                }
            }

            // Keep player in bounds (but allow vertical movement) (MATCHES MAIN MENU)
            if (shopHubPlayer.x < 0) shopHubPlayer.x = 0;
            if (shopHubPlayer.x > 1200 - shopHubPlayer.width) shopHubPlayer.x = 1200 - shopHubPlayer.width;

            // Respawn if fall too far
            if (shopHubPlayer.y > 1500) {
                shopHubPlayer.x = 600 - 20;
                shopHubPlayer.y = 720 - 40;
                shopHubPlayer.velocityX = 0;
                shopHubPlayer.velocityY = 0;
            }
        }

        function renderShopHub(ctx, deltaTime = 1) {
            ctx.clearRect(0, 0, 1200, 800);

            // Sky background
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, 1200, 800);

            // Draw background gridlines (40x40px)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;

            // Vertical lines
            for (let x = 0; x < 1200; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 800);
                ctx.stroke();
            }

            // Horizontal lines
            for (let y = 0; y < 800; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(1200, y);
                ctx.stroke();
            }

            // Draw platforms with clean styling matching main menu
            for (const platform of shopHubPlatforms) {
                if (platform.action === 'exit') {
                    // Exit portal - dark blue with glow (same as "back" portal)
                    const gradient = ctx.createLinearGradient(platform.x, platform.y, platform.x, platform.y + platform.height);
                    gradient.addColorStop(0, 'rgba(25, 82, 154, 0.7)');
                    gradient.addColorStop(1, 'rgba(25, 82, 154, 0.4)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                    // Glowing border - darker blue (inside edge)
                    ctx.shadowColor = '#19529a';
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = '#19529a';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(platform.x + 2, platform.y + 2, platform.width - 4, platform.height - 4);
                    ctx.shadowBlur = 0;

                    // Label with shadow - matching main menu style exactly
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    ctx.shadowBlur = 5;
                    ctx.fillText(platform.label, platform.x + platform.width / 2, platform.y + platform.height / 2 + 5);
                    ctx.shadowBlur = 0;
                } else if (platform.action === 'cosmetics' || platform.action === 'backpack') {
                    // Shop portals - light blue with glow (same as level portals)
                    const gradient = ctx.createLinearGradient(platform.x, platform.y, platform.x, platform.y + platform.height);
                    gradient.addColorStop(0, 'rgba(79, 172, 254, 0.5)');
                    gradient.addColorStop(1, 'rgba(79, 172, 254, 0.2)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                    // Glowing border (inside edge)
                    ctx.shadowColor = '#4facfe';
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = '#4facfe';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(platform.x + 2, platform.y + 2, platform.width - 4, platform.height - 4);
                    ctx.shadowBlur = 0;

                    // Text with shadow - matching main menu style exactly
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    ctx.shadowBlur = 5;
                    ctx.fillText(platform.label, platform.x + platform.width / 2, platform.y + platform.height / 2 + 5);
                    ctx.shadowBlur = 0;
                } else {
                    // Boundary platforms - green platform - standardized (MATCHES MAIN MENU)
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                    // Thicker dark border (inside edge)
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(platform.x + 2, platform.y + 2, platform.width - 4, platform.height - 4);

                    // Inner 40x40 grid lines
                    ctx.strokeStyle = '#388E3C';
                    ctx.lineWidth = 1;
                    for (let gx = 40; gx < platform.width; gx += 40) {
                        ctx.beginPath();
                        ctx.moveTo(platform.x + gx, platform.y);
                        ctx.lineTo(platform.x + gx, platform.y + platform.height);
                        ctx.stroke();
                    }
                    for (let gy = 40; gy < platform.height; gy += 40) {
                        ctx.beginPath();
                        ctx.moveTo(platform.x, platform.y + gy);
                        ctx.lineTo(platform.x + platform.width, platform.y + gy);
                        ctx.stroke();
                    }
                }
            }

            // Draw particles (MATCHES MAIN MENU - using camera coords and deltaTime)
            updateAndDrawParticles(ctx, 0, 0, deltaTime);

            // Draw player (MATCHES MAIN MENU)
            if (shopHubPlayer) {
                shopHubPlayer.updateTrail();
                shopHubPlayer.draw(ctx, 0, 0, false);
            }

            // Draw title
            ctx.fillStyle = '#FFC107';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 10;
            ctx.fillText('SHOP', 600, 60);
            ctx.shadowBlur = 0;
        }

        function backToShopHub() {
            showShop();
        }

        function showCosmeticsShop() {
            showScreen('cosmeticsShopScreen');
            updateCosmeticsShopUI();
        }

        function showBackpackShop() {
            showScreen('backpackShopScreen');
            updateBackpackShopUI();
        }

        function updateCosmeticsShopUI() {
            document.getElementById('cosmeticsShopCredits').textContent = `BASE Credits: ${secureCredits}`;

            let html = '';

            // Equippable Items Section
            html += `<div class="shop-category">
                <h2>EQUIPPABLE ITEMS</h2>
                <div class="cosmetics-grid">
                    <div class="cosmetic-item ${equippedItem === 'credits' ? 'equipped' : ''}">
                        <div style="font-weight: bold;">Credit Display</div>
                        <div style="color: #aaa; font-size: 12px;">Show credits on character</div>
                        ${equippedItem === 'credits'
                            ? '<div style="color: #0f0;">✓ EQUIPPED</div><button onclick="unequipItem()" style="margin-top: 5px;">Unequip</button>'
                            : '<button onclick="equipItem(\'credits\')" style="margin-top: 5px;">Equip</button>'
                        }
                    </div>
                </div>
            </div>`;

            for (const [category, items] of Object.entries(cosmeticsCatalog)) {
                html += `<div class="shop-category">
                    <h2>${category.toUpperCase()}</h2>
                    <div class="cosmetics-grid">`;

                for (const item of items) {
                    const owned = userCosmetics[category].includes(item.id);
                    const equipped = equippedCosmetics[category === 'skins' ? 'skin' : category.slice(0, -1)] === item.id;

                    html += `<div class="cosmetic-item ${owned ? 'owned' : ''} ${equipped ? 'equipped' : ''}">
                        <canvas id="preview_${category}_${item.id}" width="80" height="80" style="border: 2px solid #444; border-radius: 5px; margin-bottom: 10px; background: #87CEEB;"></canvas>
                        <div style="font-weight: bold;">${item.name}</div>
                        <div style="color: #FFC107;">${item.price} credits</div>`;

                    if (equipped) {
                        html += `<div style="display: flex; flex-direction: column; gap: 5px; margin-top: 5px;">
                            <div style="color: #0f0;">✓ EQUIPPED</div>
                            <button onclick="unequipCosmetic('${category}')">Unequip</button>
                        </div>`;
                    } else if (owned) {
                        html += `<button onclick="equipCosmetic('${category}', '${item.id}')" style="margin-top: 5px;">Equip</button>`;
                    } else {
                        html += `<button onclick="buyCosmetic('${category}', '${item.id}', ${item.price})" ${secureCredits >= item.price ? '' : 'disabled'} style="margin-top: 5px;">Buy</button>`;
                    }

                    html += `</div>`;
                }

                html += `</div></div>`;
            }

            document.getElementById('cosmeticsShopContent').innerHTML = html;

            // Draw previews for all cosmetics
            setTimeout(() => drawCosmeticPreviews(), 0);
        }

        function updateBackpackShopUI() {
            document.getElementById('backpackShopCredits').textContent = `BASE Credits: ${secureCredits}`;

            let html = '';

            // Backpack Upgrades Section (price = size * 3)
            const backpackUpgrades = [
                { size: 1, price: 3, name: '1x1 Backpack' },
                { size: 4, price: 12, name: '2x2 Backpack' },
                { size: 9, price: 27, name: '3x3 Backpack' },
                { size: 16, price: 48, name: '4x4 Backpack' },
                { size: 25, price: 75, name: '5x5 Backpack' },
                { size: 36, price: 108, name: '6x6 Backpack' },
                { size: 49, price: 147, name: '7x7 Backpack' },
                { size: 64, price: 192, name: '8x8 Backpack' },
                { size: 81, price: 243, name: '9x9 Backpack' },
                { size: 100, price: 300, name: '10x10 Backpack' }
            ];

            html += `<div class="shop-category">
                <h2>BACKPACK UPGRADES</h2>
                <div style="color: #aaa; font-size: 14px; margin-bottom: 15px;">Increase your backpack storage to carry more credits</div>
                <div class="cosmetics-grid">`;

            for (const upgrade of backpackUpgrades) {
                const owned = backpackSize >= upgrade.size;
                const gridSize = Math.sqrt(upgrade.size);

                html += `<div class="cosmetic-item ${owned ? 'owned' : ''}">
                    <div style="font-weight: bold;">${upgrade.name}</div>
                    <div style="color: #FFD700; margin: 5px 0;">Holds ${upgrade.size} credits</div>
                    <div style="color: #FFC107; margin-bottom: 10px;">${upgrade.price} credits</div>`;

                if (owned) {
                    if (backpackSize === upgrade.size) {
                        html += `<div style="color: #0f0;">✓ CURRENT</div>`;
                    } else {
                        html += `<div style="color: #0f0;">✓ OWNED</div>`;
                    }
                } else {
                    html += `<button onclick="buyBackpack(${upgrade.size}, ${upgrade.price})" ${secureCredits >= upgrade.price ? '' : 'disabled'}>Buy</button>`;
                }

                html += `</div>`;
            }

            html += `</div></div>`;

            document.getElementById('backpackShopContent').innerHTML = html;
        }

        function drawCosmeticPreviews() {
            for (const [category, items] of Object.entries(cosmeticsCatalog)) {
                for (const item of items) {
                    const canvas = document.getElementById(`preview_${category}_${item.id}`);
                    if (!canvas) continue;

                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 80, 80);

                    // Draw player square (centered)
                    const playerSize = 30;
                    const playerX = 25;
                    const playerY = 45;

                    // Apply cosmetic based on category
                    if (category === 'skins') {
                        // Draw player with skin color
                        ctx.fillStyle = item.color || '#FF8C42';
                        ctx.fillRect(playerX, playerY, playerSize, playerSize);
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(playerX + 1, playerY + 1, playerSize - 2, playerSize - 2);
                    } else if (category === 'trails') {
                        // Draw default player
                        ctx.fillStyle = '#FF8C42';
                        ctx.fillRect(playerX, playerY, playerSize, playerSize);

                        // Draw trail behind player
                        if (item.id === 'rainbow') {
                            const colors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#8B00FF'];
                            for (let i = 0; i < 6; i++) {
                                ctx.fillStyle = colors[i];
                                ctx.globalAlpha = 0.6 - i * 0.1;
                                ctx.fillRect(playerX - 8 - i * 3, playerY + 5, 8, 20);
                            }
                            ctx.globalAlpha = 1;
                        } else if (item.id === 'fire') {
                            ctx.fillStyle = '#FF4500';
                            ctx.globalAlpha = 0.7;
                            ctx.fillRect(playerX - 10, playerY + 5, 8, 20);
                            ctx.fillStyle = '#FFA500';
                            ctx.fillRect(playerX - 6, playerY + 10, 6, 15);
                            ctx.globalAlpha = 1;
                        } else if (item.id === 'ice') {
                            ctx.fillStyle = '#00CED1';
                            ctx.globalAlpha = 0.7;
                            ctx.fillRect(playerX - 10, playerY + 5, 8, 20);
                            ctx.fillStyle = '#B0E0E6';
                            ctx.fillRect(playerX - 6, playerY + 10, 6, 15);
                            ctx.globalAlpha = 1;
                        } else if (item.id === 'star') {
                            // Draw stars
                            for (let i = 0; i < 3; i++) {
                                ctx.fillStyle = '#FFD700';
                                ctx.globalAlpha = 0.8 - i * 0.2;
                                ctx.beginPath();
                                const x = playerX - 5 - i * 8;
                                const y = playerY + 15;
                                ctx.moveTo(x, y - 3);
                                ctx.lineTo(x + 2, y + 1);
                                ctx.lineTo(x + 6, y + 1);
                                ctx.lineTo(x + 3, y + 3);
                                ctx.lineTo(x + 4, y + 7);
                                ctx.lineTo(x, y + 4);
                                ctx.lineTo(x - 4, y + 7);
                                ctx.lineTo(x - 3, y + 3);
                                ctx.lineTo(x - 6, y + 1);
                                ctx.lineTo(x - 2, y + 1);
                                ctx.closePath();
                                ctx.fill();
                            }
                            ctx.globalAlpha = 1;
                        }
                    } else if (category === 'hats') {
                        // Draw default player
                        ctx.fillStyle = '#FF8C42';
                        ctx.fillRect(playerX, playerY, playerSize, playerSize);

                        // Draw hat on top
                        if (item.id === 'crown') {
                            ctx.fillStyle = '#FFD700';
                            ctx.fillRect(playerX + 5, playerY - 8, 20, 6);
                            ctx.fillRect(playerX + 7, playerY - 12, 4, 4);
                            ctx.fillRect(playerX + 13, playerY - 14, 4, 6);
                            ctx.fillRect(playerX + 19, playerY - 12, 4, 4);
                        } else if (item.id === 'propeller') {
                            ctx.fillStyle = '#666';
                            ctx.fillRect(playerX + 13, playerY - 10, 4, 10);
                            ctx.fillStyle = '#444';
                            ctx.fillRect(playerX + 5, playerY - 14, 20, 4);
                        } else if (item.id === 'halo') {
                            ctx.strokeStyle = '#FFD700';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(playerX + 15, playerY - 8, 12, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    } else if (category === 'effects') {
                        // Draw default player
                        ctx.fillStyle = '#FF8C42';
                        ctx.fillRect(playerX, playerY, playerSize, playerSize);

                        // Draw effect
                        if (item.id === 'sparkles') {
                            ctx.fillStyle = '#FFD700';
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                const dist = 20;
                                const x = playerX + 15 + Math.cos(angle) * dist;
                                const y = playerY + 15 + Math.sin(angle) * dist;
                                ctx.fillRect(x - 2, y - 2, 4, 4);
                            }
                        } else if (item.id === 'glow') {
                            ctx.shadowColor = '#FFD700';
                            ctx.shadowBlur = 15;
                            ctx.fillStyle = '#FF8C42';
                            ctx.fillRect(playerX, playerY, playerSize, playerSize);
                            ctx.shadowBlur = 0;
                        } else if (item.id === 'shadow_clone') {
                            // Draw shadow clone behind
                            ctx.globalAlpha = 0.4;
                            ctx.fillStyle = '#000';
                            ctx.fillRect(playerX - 10, playerY, playerSize, playerSize);
                            ctx.globalAlpha = 1;
                            ctx.fillStyle = '#FF8C42';
                            ctx.fillRect(playerX, playerY, playerSize, playerSize);
                        }
                    }

                    // Draw border on player
                    if (category !== 'effects' || item.id !== 'glow') {
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(playerX + 1, playerY + 1, playerSize - 2, playerSize - 2);
                    }
                }
            }
        }

        async function buyCosmetic(category, itemId, price) {
            if (secureCredits < price) {
                showNotification(`Not enough BASE credits! Need ${price}, have ${secureCredits}. Build your base to earn more.`, 'error');
                return;
            }

            // Remove credits from base blocks
            await removeCreditsFromBase(price);

            userCosmetics[category].push(itemId);
            await database.ref('players/' + currentUser.uid + '/cosmetics').set(userCosmetics);

            showNotification('Cosmetic purchased!', 'success');
            updateCosmeticsShopUI();
        }

        async function buyBackpack(size, price) {
            if (secureCredits < price) {
                showNotification(`Not enough BASE credits! Need ${price}, have ${secureCredits}. Build your base to earn more.`, 'error');
                return;
            }

            if (backpackSize >= size) {
                showNotification('You already have this backpack or better!', 'warning');
                return;
            }

            // Remove credits from base blocks
            await removeCreditsFromBase(price);

            backpackSize = size;
            await database.ref('players/' + currentUser.uid + '/backpackSize').set(backpackSize);

            showNotification(`Backpack upgraded to ${backpackSize} slots!`, 'success');
            updateBackpackShopUI();
        }

        async function equipCosmetic(category, itemId) {
            const slot = category === 'skins' ? 'skin' : category.slice(0, -1);
            equippedCosmetics[slot] = itemId;
            await database.ref('players/' + currentUser.uid + '/equippedCosmetics').set(equippedCosmetics);

            // Update menu player cosmetics immediately
            if (menuPlayer) {
                menuPlayer.cosmetics = equippedCosmetics;
            }

            updateCosmeticsShopUI();
        }

        async function unequipCosmetic(category) {
            const slot = category === 'skins' ? 'skin' : category.slice(0, -1);
            const defaultValue = slot === 'skin' ? 'default_orange' : 'none';
            equippedCosmetics[slot] = defaultValue;
            await database.ref('players/' + currentUser.uid + '/equippedCosmetics').set(equippedCosmetics);

            // Update menu player cosmetics immediately
            if (menuPlayer) {
                menuPlayer.cosmetics = equippedCosmetics;
            }

            updateCosmeticsShopUI();
        }

        async function equipItem(itemId) {
            equippedItem = itemId;
            await database.ref('players/' + currentUser.uid + '/equippedItem').set(equippedItem);
            updateCosmeticsShopUI();
        }

        async function unequipItem() {
            equippedItem = 'none';
            await database.ref('players/' + currentUser.uid + '/equippedItem').set(equippedItem);
            updateCosmeticsShopUI();
        }

        // Stats screen
        function showStats() {
            showScreen('statsScreen');
            document.getElementById('statsContent').innerHTML = `
                <div style="margin: 20px 0;">Races Won: ${userStats.racesWon}</div>
                <div style="margin: 20px 0;">Races Played: ${userStats.racesPlayed}</div>
                <div style="margin: 20px 0;">Win Rate: ${userStats.racesPlayed > 0 ? ((userStats.racesWon / userStats.racesPlayed) * 100).toFixed(1) : 0}%</div>
                <div style="margin: 20px 0;">Total Credits Earned: ${userStats.totalCreditsEarned}</div>
            `;
        }

        // Zoom variables for all modes
        let baseZoom = 1;
        let practiceZoom = 1;
        let menuZoom = 1;

        // Base screen (build with credits)
        let baseBlocks = []; // Each block: { x, y, credits } where credits can be 1-3
        let baseCanvas, baseCtx;
        let basePlayer = null;
        let baseKeys = {};
        let baseIsJumping = false;
        let basePlatforms = [];
        let lastPlacedBlock = null; // Track last placed block for continuous placement

        async function showBase() {
            showScreen('baseScreen');
            document.getElementById('baseCredits').textContent = `Credits: ${secureCredits} (${userCredits} on hand)`;

            baseCanvas = document.getElementById('baseCanvas');
            baseCtx = baseCanvas.getContext('2d');

            // Load base blocks from Firebase
            const baseSnapshot = await database.ref('players/' + currentUser.uid + '/baseBlocks').once('value');
            baseBlocks = baseSnapshot.val() || [];

            // Create base platforms (100x100 blocks = 4000x4000px area)
            basePlatforms = [
                // Ground
                { x: 0, y: 4000, width: 4000, height: 80 },
                // Left wall (100 blocks high)
                { x: -40, y: 0, width: 40, height: 4080 },
                // Right wall
                { x: 4000, y: 0, width: 40, height: 4080 }
            ];

            // Initialize player next to one of the blocks in base
            let spawnX = 2000;
            let spawnY = 3960; // Default spawn on ground
            if (baseBlocks.length > 0) {
                // Pick the first block and spawn next to it (to the right)
                const firstBlock = baseBlocks[0];
                spawnX = firstBlock.x + 20; // Spawn to the right of the block (20x20 blocks)
                spawnY = firstBlock.y; // Same height as the block
            }
            basePlayer = new Player(spawnX, spawnY, equippedCosmetics);

            renderBase();

            // Track mouse state for continuous placement/removal
            let isMouseDown = false;
            let isRightMouseDown = false;

            // Add mouse handlers for continuous placement/removal
            baseCanvas.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // Left click
                    isMouseDown = true;
                    handleBaseClick(e);
                } else if (e.button === 2) { // Right click
                    isRightMouseDown = true;
                    handleBaseRightClick(e);
                }
            });

            baseCanvas.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    isMouseDown = false;
                    lastPlacedBlock = null;
                } else if (e.button === 2) {
                    isRightMouseDown = false;
                    lastPlacedBlock = null;
                }
            });

            baseCanvas.addEventListener('mouseleave', () => {
                isMouseDown = false;
                isRightMouseDown = false;
                lastPlacedBlock = null;
            });

            baseCanvas.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    handleBaseClick(e);
                } else if (isRightMouseDown) {
                    handleBaseRightClick(e);
                }
            });

            baseCanvas.oncontextmenu = (e) => {
                e.preventDefault();
                return false;
            };

            // Add zoom with mouse wheel
            baseCanvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY < 0) {
                    // Zoom in
                    baseZoom = Math.min(baseZoom * 1.1, 3); // Max 3x zoom
                } else {
                    // Zoom out
                    baseZoom = Math.max(baseZoom / 1.1, 0.3); // Min 0.3x zoom
                }
            }, { passive: false });

            // Start base loop
            let lastBaseFrameTime = performance.now();
            function baseLoop(currentTime) {
                if (baseCanvas.style.display === 'none') return;

                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastBaseFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                lastBaseFrameTime = currentTime;

                updateBasePlayer(deltaTime);
                renderBase(deltaTime);

                requestAnimationFrame(baseLoop);
            }

            baseLoop();
        }

        function updateBasePlayer(deltaTime = 1) {
            if (!basePlayer) return;

            // Combine user-placed blocks with boundary platforms for collision
            const allPlatforms = [...basePlatforms, ...baseBlocks.map(b => ({ x: b.x, y: b.y, width: 40, height: 40 }))];

            // Check grounded state
            let isGrounded = false;
            for (const platform of allPlatforms) {
                const onTop = basePlayer.y + basePlayer.height >= platform.y &&
                              basePlayer.y + basePlayer.height <= platform.y + 5;
                const horizontalOverlap = basePlayer.x + basePlayer.width > platform.x &&
                                         basePlayer.x < platform.x + platform.width;

                if (onTop && horizontalOverlap) {
                    isGrounded = true;
                    break;
                }
            }

            // Apply gravity with fast fall (scaled by size)
            const sizeScale = basePlayer.currentSize / 40;
            if ((baseKeys['s'] || baseKeys['ArrowDown']) && !isGrounded) {
                basePlayer.velocityY += GRAVITY * sizeScale * FAST_FALL_MULTIPLIER * deltaTime;
            } else {
                basePlayer.velocityY += GRAVITY * sizeScale * deltaTime;
            }

            // Movement (scaled by size)
            const scaledMoveSpeed = MOVE_SPEED * sizeScale;
            if (baseKeys['a'] || baseKeys['ArrowLeft']) {
                basePlayer.velocityX -= scaledMoveSpeed * deltaTime;
            }
            if (baseKeys['d'] || baseKeys['ArrowRight']) {
                basePlayer.velocityX += scaledMoveSpeed * deltaTime;
            }

            // Old action-based particle system
            // Track movement state for movement start particles
            const wasMovingLeft = basePlayer.prevVelocityX !== undefined && basePlayer.prevVelocityX < -0.5;
            const wasMovingRight = basePlayer.prevVelocityX !== undefined && basePlayer.prevVelocityX > 0.5;
            const isMovingLeft = basePlayer.velocityX < -0.5;
            const isMovingRight = basePlayer.velocityX > 0.5;

            // White particles on movement START
            if (isMovingLeft && !wasMovingLeft && Math.random() < 0.3) {
                spawnParticles(basePlayer.x + basePlayer.width / 2, basePlayer.y + basePlayer.height / 2, 2, 'rgb(255, 255, 255)', basePlayer.currentSize);
            }
            if (isMovingRight && !wasMovingRight && Math.random() < 0.3) {
                spawnParticles(basePlayer.x + basePlayer.width / 2, basePlayer.y + basePlayer.height / 2, 2, 'rgb(255, 255, 255)', basePlayer.currentSize);
            }

            // Orange speed-based particles
            const speed = Math.abs(basePlayer.velocityX);
            if (speed > 0.5) {
                const particleChance = Math.min(speed / 10, 0.8);
                if (Math.random() < particleChance) {
                    const particleCount = Math.floor(speed / 2);
                    spawnParticles(basePlayer.x + basePlayer.width / 2, basePlayer.y + basePlayer.height / 2, particleCount, 'rgb(255, 140, 66)', basePlayer.currentSize);
                }
            }

            // Store current velocity for next frame
            basePlayer.prevVelocityX = basePlayer.velocityX;

            // Jump with variable height based on hold time (W or Up only, NOT space)
            if ((baseKeys['w'] || baseKeys['ArrowUp']) && isGrounded && !baseIsJumping) {
                // Start jump immediately with strong initial velocity
                const sizeScale = basePlayer.currentSize / 40;
                basePlayer.velocityY = -1.5 * sizeScale; // Strong initial jump
                baseIsJumping = true;
                basePlayer.jumpHoldTime = 0;
                // White jump particles
                spawnParticles(basePlayer.x + basePlayer.width / 2, basePlayer.y + basePlayer.height, 12, 'rgb(255, 255, 255)', basePlayer.currentSize);
            }

            // Continue adding upward velocity while holding button (extends jump height)
            if (baseIsJumping && (baseKeys['w'] || baseKeys['ArrowUp']) && basePlayer.velocityY < 0 && basePlayer.jumpHoldTime < MAX_JUMP_HOLD_TIME) {
                const sizeScale = basePlayer.currentSize / 40;
                basePlayer.jumpHoldTime += deltaTime;

                // Add upward acceleration while holding (max height = 4x playerSize + 1px)
                const maxJumpVelocity = JUMP_POWER * sizeScale;
                if (Math.abs(basePlayer.velocityY) < maxJumpVelocity && basePlayer.jumpHoldTime < MAX_JUMP_HOLD_TIME) {
                    basePlayer.velocityY -= JUMP_CHARGE_RATE * sizeScale * deltaTime;
                }
            }

            // Stop adding velocity when button released
            if (baseIsJumping && (!baseKeys['w'] && !baseKeys['ArrowUp'])) {
                baseIsJumping = false;
            }

            // Stop jump when time limit exceeded
            if (baseIsJumping && basePlayer.jumpHoldTime >= MAX_JUMP_HOLD_TIME) {
                baseIsJumping = false;
            }

            // Reset jump state when grounded
            if (isGrounded && basePlayer.velocityY >= 0) {
                baseIsJumping = false;
            }

            // Fast-fall particles (white) - spawn when holding down/S in air
            if ((baseKeys['s'] || baseKeys['ArrowDown']) && !isGrounded && basePlayer.velocityY > 0) {
                // Spawn particles continuously during fast fall
                if (Math.random() < 0.3) { // 30% chance each frame for smooth particle trail
                    spawnParticles(basePlayer.x + basePlayer.width / 2, basePlayer.y, 3, 'rgb(255, 255, 255)', basePlayer.currentSize);
                }
            }

            // Friction
            if (isGrounded) {
                basePlayer.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                basePlayer.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Cap vertical velocity to prevent tunneling (scaled by size)
            const maxFallSpeed = 8 * sizeScale;
            basePlayer.velocityY = Math.min(basePlayer.velocityY, maxFallSpeed);

            // Limit horizontal speed (scaled by size)
            const scaledMaxSpeed = GROUND_MAX_SPEED * sizeScale;
            basePlayer.velocityX = Math.max(-scaledMaxSpeed, Math.min(scaledMaxSpeed, basePlayer.velocityX));

            // Update X position, check X collisions
            basePlayer.x += basePlayer.velocityX * deltaTime;
            for (const platform of allPlatforms) {
                if (checkCollision(basePlayer, platform)) {
                    if (basePlayer.velocityX > 0) {
                        basePlayer.x = platform.x - basePlayer.width;
                    } else if (basePlayer.velocityX < 0) {
                        basePlayer.x = platform.x + platform.width;
                    }
                    basePlayer.velocityX = 0;
                }
            }

            // Update Y position, check Y collisions
            basePlayer.y += basePlayer.velocityY * deltaTime;
            for (const platform of allPlatforms) {
                if (checkCollision(basePlayer, platform)) {
                    if (basePlayer.velocityY > 0) {
                        // Cyan landing particles if falling with significant velocity
                        if (basePlayer.velocityY > 2) {
                            spawnParticles(basePlayer.x + basePlayer.width / 2, basePlayer.y + basePlayer.height, 8, 'rgb(255, 255, 255)', basePlayer.currentSize);
                        }
                        basePlayer.y = platform.y - basePlayer.height;
                        basePlayer.velocityY = 0;
                    } else if (basePlayer.velocityY < 0) {
                        basePlayer.y = platform.y + platform.height;
                        basePlayer.velocityY = 0;
                        baseIsJumping = false;
                    }
                }
            }
        }

        function renderBase(deltaTime = 1) {
            if (!basePlayer) return;

            // Clear and apply zoom
            baseCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
            baseCtx.fillStyle = '#87CEEB';
            baseCtx.fillRect(0, 0, baseCanvas.width, baseCanvas.height);

            // Apply zoom transform (scale from center)
            baseCtx.translate(baseCanvas.width / 2, baseCanvas.height / 2);
            baseCtx.scale(baseZoom, baseZoom);
            baseCtx.translate(-baseCanvas.width / 2, -baseCanvas.height / 2);

            // Camera follows player
            const cameraX = basePlayer.x - baseCanvas.width / 2;
            const cameraY = basePlayer.y - baseCanvas.height / 2;

            // Draw grid (40x40px blocks)
            baseCtx.strokeStyle = '#ccc';
            baseCtx.lineWidth = 0.5;
            for (let x = 0; x <= 4000; x += 40) {
                const screenX = x - cameraX;
                baseCtx.beginPath();
                baseCtx.moveTo(screenX, -cameraY);
                baseCtx.lineTo(screenX, 4080 - cameraY);
                baseCtx.stroke();
            }
            for (let y = 0; y <= 4080; y += 40) {
                const screenY = y - cameraY;
                baseCtx.beginPath();
                baseCtx.moveTo(-cameraX, screenY);
                baseCtx.lineTo(4000 - cameraX, screenY);
                baseCtx.stroke();
            }

            // Draw boundary platforms - standardized
            for (const platform of basePlatforms) {
                const screenX = platform.x - cameraX;
                const screenY = platform.y - cameraY;

                baseCtx.fillStyle = '#4CAF50';
                baseCtx.fillRect(screenX, screenY, platform.width, platform.height);

                // Thicker dark border (inside edge)
                baseCtx.strokeStyle = '#333';
                baseCtx.lineWidth = 4;
                baseCtx.strokeRect(screenX + 2, screenY + 2, platform.width - 4, platform.height - 4);

                // Inner 40x40 grid lines
                baseCtx.strokeStyle = '#388E3C';
                baseCtx.lineWidth = 1;
                for (let gx = 40; gx < platform.width; gx += 40) {
                    baseCtx.beginPath();
                    baseCtx.moveTo(screenX + gx, screenY);
                    baseCtx.lineTo(screenX + gx, screenY + platform.height);
                    baseCtx.stroke();
                }
                for (let gy = 40; gy < platform.height; gy += 40) {
                    baseCtx.beginPath();
                    baseCtx.moveTo(screenX, screenY + gy);
                    baseCtx.lineTo(screenX + platform.width, screenY + gy);
                    baseCtx.stroke();
                }
            }

            // Draw placed blocks (golden, darker with more credits)
            for (const block of baseBlocks) {
                const screenX = block.x - cameraX;
                const screenY = block.y - cameraY;

                // Gold color gets darker with more credits (1-3)
                const credits = block.credits || 1;
                if (credits === 1) {
                    baseCtx.fillStyle = '#FFD700'; // Light gold
                } else if (credits === 2) {
                    baseCtx.fillStyle = '#DAA520'; // Medium gold (goldenrod)
                } else {
                    baseCtx.fillStyle = '#B8860B'; // Dark gold
                }
                baseCtx.fillRect(screenX, screenY, 40, 40);
                baseCtx.strokeStyle = '#FFA500';
                baseCtx.lineWidth = 2;
                baseCtx.strokeRect(screenX, screenY, 40, 40);
            }

            // Draw player
            basePlayer.updateTrail();
            basePlayer.draw(baseCtx, cameraX, cameraY, false);

            // Reset transform BEFORE drawing particles (so particles aren't zoomed)
            baseCtx.setTransform(1, 0, 0, 1, 0, 0);

            // Update and draw particles (particles use camera offset internally, not zoom)
            updateAndDrawParticles(baseCtx, cameraX, cameraY, deltaTime);
        }

        async function handleBaseClick(e) {
            if (!basePlayer) return;

            const rect = baseCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Convert screen coordinates to world coordinates
            const cameraX = basePlayer.x - baseCanvas.width / 2;
            const cameraY = basePlayer.y - baseCanvas.height / 2;
            const worldX = clickX + cameraX;
            const worldY = clickY + cameraY;

            // Snap to 40x40 grid
            const gridX = Math.floor(worldX / 40) * 40;
            const gridY = Math.floor(worldY / 40) * 40;

            // Check if within base bounds (0-4000, 0-4000) - silently prevent
            if (gridX < 0 || gridX >= 4000 || gridY < 0 || gridY >= 4000) {
                return;
            }

            // Skip if this is the same block we just interacted with (prevents spam during drag)
            const blockKey = `${gridX},${gridY}`;
            if (lastPlacedBlock === blockKey) {
                return;
            }
            lastPlacedBlock = blockKey;

            // Check if block already exists
            const existingBlock = baseBlocks.find(b => b.x === gridX && b.y === gridY);
            if (existingBlock) {
                // Block exists - try to add another credit (max 3)
                if (existingBlock.credits >= 3) {
                    return; // Silently prevent adding more than 3 credits
                }
                if (userCredits < 1) {
                    return; // Silently prevent if no credits
                }
                // Add credit to existing block
                existingBlock.credits = (existingBlock.credits || 1) + 1;
                await updateCredits(-1, 'onhand');
                await database.ref('players/' + currentUser.uid + '/baseBlocks').set(baseBlocks);
                document.getElementById('baseCredits').textContent = `Credits: ${secureCredits} (${userCredits} on hand)`;
                return;
            }

            // Check if user has credits - silently prevent
            if (userCredits < 1) {
                return;
            }

            // Place new block with 1 credit
            baseBlocks.push({ x: gridX, y: gridY, credits: 1 });
            userCredits -= 1; // Remove from onhand

            // Recalculate secure credits from blocks
            recalcSecureCredits();

            // Update stats
            if (userStats.totalCreditsEarned === undefined) userStats.totalCreditsEarned = 0;

            // Save to database
            await database.ref('players/' + currentUser.uid).update({
                credits: userCredits,
                secureCredits: secureCredits,
                baseBlocks: baseBlocks,
                stats: userStats
            });

            document.getElementById('baseCredits').textContent = `Credits: ${secureCredits} (${userCredits} on hand)`;
        }

        async function handleBaseRightClick(e) {
            e.preventDefault();
            if (!basePlayer) return false;

            const rect = baseCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Convert screen coordinates to world coordinates
            const cameraX = basePlayer.x - baseCanvas.width / 2;
            const cameraY = basePlayer.y - baseCanvas.height / 2;
            const worldX = clickX + cameraX;
            const worldY = clickY + cameraY;

            // Snap to 40x40 grid
            const gridX = Math.floor(worldX / 40) * 40;
            const gridY = Math.floor(worldY / 40) * 40;

            // Skip if this is the same block we just interacted with (prevents spam during drag)
            const blockKey = `${gridX},${gridY}`;
            if (lastPlacedBlock === blockKey) {
                return false;
            }
            lastPlacedBlock = blockKey;

            // Find block
            const index = baseBlocks.findIndex(b => b.x === gridX && b.y === gridY);
            if (index === -1) {
                return false; // Silently prevent if no block
            }

            // Remove ONE credit from the block and add to onhand
            const block = baseBlocks[index];
            const creditsInBlock = block.credits || 1;

            if (creditsInBlock > 1) {
                // Block has multiple credits - just remove one
                block.credits = creditsInBlock - 1;
            } else {
                // Block has only 1 credit - remove entire block
                baseBlocks.splice(index, 1);
            }

            // Add credit to onhand
            userCredits += 1;

            // Recalculate secure credits from blocks (will be lower now)
            recalcSecureCredits();

            // Save to database
            await database.ref('players/' + currentUser.uid).update({
                credits: userCredits,
                secureCredits: secureCredits,
                baseBlocks: baseBlocks
            });

            document.getElementById('baseCredits').textContent = `Credits: ${secureCredits} (${userCredits} on hand)`;

            return false;
        }

        // Leaderboard screen variables - canvas-based like level select
        let leaderboardActive = false;
        let leaderboardPlayer = null;
        let leaderboardPlatforms = [];
        let leaderboardKeys = {};
        let availableLeaderboards = [];
        let leaderboardIsJumping = false;

        async function showLeaderboard() {
            try {
                showScreen('leaderboardScreen');
                leaderboardActive = true;

                const canvas = document.getElementById('leaderboardCanvas');
                const ctx = canvas.getContext('2d');

                // Load all levels
                const levelsSnapshot = await database.ref('levels').once('value');
                const levelsData = levelsSnapshot.val();

                availableLeaderboards = [];
                if (levelsData) {
                    Object.entries(levelsData).forEach(([levelId, levelInfo]) => {
                        availableLeaderboards.push({
                            id: levelId,
                            name: levelInfo.name || levelId,
                            createdAt: levelInfo.createdAt || 0
                        });
                    });
                    availableLeaderboards.sort((a, b) => a.createdAt - b.createdAt);
                }

                // Setup platforms
                const portalWidth = 150;
                const portalHeight = 50;
                const levelsPerColumn = 4;
                const numColumns = Math.ceil(availableLeaderboards.length / levelsPerColumn);

                const columnSpacing = 200;
                const totalWidth = (numColumns - 1) * columnSpacing + portalWidth;
                const startX = (1200 - totalWidth) / 2;

                const groundY = 720;
                const bottomPortalY = groundY - 120;

                leaderboardPlatforms = [
                    // Boundary walls - thick floor (80px), side walls (40px), ceiling (40px)
                    { x: 0, y: 0, width: 40, height: 800 }, // Left wall (40px wide)
                    { x: 1160, y: 0, width: 40, height: 800 }, // Right wall (40px wide)
                    { x: 0, y: 0, width: 1200, height: 40 }, // Ceiling (40px thick)
                    { x: 0, y: 720, width: 1200, height: 80 } // Ground (80px thick - twice as thick)
                ];

                // Add "Back to Menu" portal
                leaderboardPlatforms.push({
                    x: 100,
                    y: bottomPortalY,
                    width: portalWidth,
                    height: portalHeight,
                    action: 'back',
                    label: 'BACK TO MENU'
                });

                // Create portals for each level
                availableLeaderboards.forEach((level, index) => {
                    const columnIndex = Math.floor(index / levelsPerColumn);
                    const rowIndex = index % levelsPerColumn;

                    const x = startX + columnIndex * columnSpacing;
                    const y = bottomPortalY - rowIndex * 80;

                    leaderboardPlatforms.push({
                        x: x,
                        y: y,
                        width: portalWidth,
                        height: portalHeight,
                        levelId: level.id,
                        levelName: level.name
                    });
                });

                // Create player
                leaderboardPlayer = new Player(600, groundY - 40, equippedCosmetics);

                // Setup input
                leaderboardKeys = {};
                const leaderboardKeyHandler = (e) => {
                    if (e.type === 'keydown') {
                        leaderboardKeys[e.key] = true;
                        if (e.key === 'Escape') {
                            leaderboardActive = false;
                            backToMainMenu();
                        }
                    } else {
                        leaderboardKeys[e.key] = false;
                    }
                };

                document.removeEventListener('keydown', leaderboardKeyHandler);
                document.removeEventListener('keyup', leaderboardKeyHandler);
                document.addEventListener('keydown', leaderboardKeyHandler);
                document.addEventListener('keyup', leaderboardKeyHandler);

                // Start loop
                let lastLeaderboardFrameTime = performance.now();
                function leaderboardLoop(currentTime) {
                    if (!leaderboardActive) return;

                    if (!currentTime) currentTime = performance.now();
                    let deltaTime = (currentTime - lastLeaderboardFrameTime) / 16.67;
                    if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                    lastLeaderboardFrameTime = currentTime;

                    updateLeaderboardPlayer(deltaTime);
                    renderLeaderboard(ctx, deltaTime);

                    requestAnimationFrame(leaderboardLoop);
                }

                leaderboardLoop();
            } catch (error) {
                console.error('Error loading leaderboards:', error);
                alert('Error loading leaderboards. Please try again.');
                backToMainMenu();
            }
        }

        function updateLeaderboardPlayer(deltaTime) {
            if (!leaderboardPlayer) return;

            // STEP 1: Calculate grounded state BEFORE physics (matches main menu)
            let isGrounded = false;
            let standingOnPlatform = null;

            for (const platform of leaderboardPlatforms) {
                const onTop = leaderboardPlayer.y + leaderboardPlayer.height >= platform.y &&
                              leaderboardPlayer.y + leaderboardPlayer.height <= platform.y + 5;
                const horizontalOverlap = leaderboardPlayer.x + leaderboardPlayer.width > platform.x &&
                                         leaderboardPlayer.x < platform.x + platform.width;

                if (onTop && horizontalOverlap) {
                    isGrounded = true;
                    standingOnPlatform = platform;
                    break;
                }
            }

            // STEP 2: Apply gravity with fast fall (scaled by size) - MATCHES MAIN MENU
            const sizeScale = leaderboardPlayer.currentSize / 40;
            if ((leaderboardKeys['s'] || leaderboardKeys['ArrowDown']) && !isGrounded) {
                leaderboardPlayer.velocityY += GRAVITY * sizeScale * FAST_FALL_MULTIPLIER * deltaTime;
            } else {
                leaderboardPlayer.velocityY += GRAVITY * sizeScale * deltaTime;
            }

            // STEP 3: Handle input (movement scaled by size)
            const scaledMoveSpeed = MOVE_SPEED * sizeScale;
            if (leaderboardKeys['a'] || leaderboardKeys['ArrowLeft']) {
                leaderboardPlayer.velocityX -= scaledMoveSpeed * deltaTime;
            }
            if (leaderboardKeys['d'] || leaderboardKeys['ArrowRight']) {
                leaderboardPlayer.velocityX += scaledMoveSpeed * deltaTime;
            }

            // Old action-based particle system
            // Track movement state for movement start particles
            const wasMovingLeft = leaderboardPlayer.prevVelocityX !== undefined && leaderboardPlayer.prevVelocityX < -0.5;
            const wasMovingRight = leaderboardPlayer.prevVelocityX !== undefined && leaderboardPlayer.prevVelocityX > 0.5;
            const isMovingLeft = leaderboardPlayer.velocityX < -0.5;
            const isMovingRight = leaderboardPlayer.velocityX > 0.5;

            // White particles on movement START (when starting to move from stopped/opposite direction)
            if (isMovingLeft && !wasMovingLeft && Math.random() < 0.3) {
                spawnParticles(leaderboardPlayer.x + leaderboardPlayer.width / 2, leaderboardPlayer.y + leaderboardPlayer.height / 2, 2, 'rgb(255, 255, 255)', leaderboardPlayer.currentSize);
            }
            if (isMovingRight && !wasMovingRight && Math.random() < 0.3) {
                spawnParticles(leaderboardPlayer.x + leaderboardPlayer.width / 2, leaderboardPlayer.y + leaderboardPlayer.height / 2, 2, 'rgb(255, 255, 255)', leaderboardPlayer.currentSize);
            }

            // Orange speed-based particles (when moving fast horizontally)
            const speed = Math.abs(leaderboardPlayer.velocityX);
            if (speed > 0.5) {
                const particleChance = Math.min(speed / 10, 0.8);
                if (Math.random() < particleChance) {
                    const particleCount = Math.floor(speed / 2);
                    spawnParticles(leaderboardPlayer.x + leaderboardPlayer.width / 2, leaderboardPlayer.y + leaderboardPlayer.height / 2, particleCount, 'rgb(255, 140, 66)', leaderboardPlayer.currentSize);
                }
            }

            // Store current velocity for next frame
            leaderboardPlayer.prevVelocityX = leaderboardPlayer.velocityX;

            // Handle platform selection
            if (standingOnPlatform && (leaderboardKeys[' '] || leaderboardKeys['Space'])) {
                if (standingOnPlatform.action === 'back') {
                    leaderboardActive = false;
                    backToMainMenu();
                } else if (standingOnPlatform.levelId) {
                    leaderboardActive = false;
                    showLevelLeaderboard(standingOnPlatform.levelId, standingOnPlatform.levelName);
                }
                leaderboardKeys[' '] = false;
                leaderboardKeys['Space'] = false;
            }

            // STEP 4: Jump with variable height based on hold time (W or Up only, NOT space)
            if ((leaderboardKeys['w'] || leaderboardKeys['ArrowUp']) && isGrounded && !leaderboardIsJumping) {
                // Start jump immediately with strong initial velocity
                leaderboardPlayer.velocityY = -1.5 * sizeScale; // Strong initial jump
                leaderboardIsJumping = true;
                leaderboardPlayer.jumpHoldTime = 0;
                // White jump particles
                spawnParticles(leaderboardPlayer.x + leaderboardPlayer.width / 2, leaderboardPlayer.y + leaderboardPlayer.height, 12, 'rgb(255, 255, 255)', leaderboardPlayer.currentSize);
            }

            // Continue adding upward velocity while holding button (extends jump height)
            if (leaderboardIsJumping && (leaderboardKeys['w'] || leaderboardKeys['ArrowUp']) && leaderboardPlayer.velocityY < 0 && leaderboardPlayer.jumpHoldTime < MAX_JUMP_HOLD_TIME) {
                leaderboardPlayer.jumpHoldTime += deltaTime;

                // Add upward acceleration while holding (max height = 4x playerSize + 1px)
                const maxJumpVelocity = JUMP_POWER * sizeScale;
                if (Math.abs(leaderboardPlayer.velocityY) < maxJumpVelocity && leaderboardPlayer.jumpHoldTime < MAX_JUMP_HOLD_TIME) {
                    leaderboardPlayer.velocityY -= JUMP_CHARGE_RATE * sizeScale * deltaTime;
                }
            }

            // Stop adding velocity when button released
            if (leaderboardIsJumping && (!leaderboardKeys['w'] && !leaderboardKeys['ArrowUp'])) {
                leaderboardIsJumping = false;
            }

            // Stop jump when time limit exceeded
            if (leaderboardIsJumping && leaderboardPlayer.jumpHoldTime >= MAX_JUMP_HOLD_TIME) {
                leaderboardIsJumping = false;
            }

            // Reset jump state when grounded
            if (isGrounded && leaderboardPlayer.velocityY >= 0) {
                leaderboardIsJumping = false;
            }

            // Fast-fall particles (white) - spawn when holding down/S in air
            if ((leaderboardKeys['s'] || leaderboardKeys['ArrowDown']) && !isGrounded && leaderboardPlayer.velocityY > 0) {
                // Spawn particles continuously during fast fall
                if (Math.random() < 0.3) { // 30% chance each frame for smooth particle trail
                    spawnParticles(leaderboardPlayer.x + leaderboardPlayer.width / 2, leaderboardPlayer.y, 3, 'rgb(255, 255, 255)', leaderboardPlayer.currentSize);
                }
            }

            // STEP 5: Apply friction using exponential decay
            if (isGrounded) {
                leaderboardPlayer.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                leaderboardPlayer.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // STEP 6: Cap vertical velocity to prevent tunneling (scaled by size)
            const maxFallSpeed = 8 * sizeScale;
            leaderboardPlayer.velocityY = Math.min(leaderboardPlayer.velocityY, maxFallSpeed);

            // Limit horizontal speed (scaled by size)
            const scaledMaxSpeed = GROUND_MAX_SPEED * sizeScale;
            leaderboardPlayer.velocityX = Math.max(-scaledMaxSpeed, Math.min(scaledMaxSpeed, leaderboardPlayer.velocityX));

            // STEP 7: Update position HORIZONTALLY first, then check X collisions
            leaderboardPlayer.x += leaderboardPlayer.velocityX * deltaTime;

            // Check horizontal collisions
            for (const platform of leaderboardPlatforms) {
                if (checkCollision(leaderboardPlayer, platform)) {
                    if (leaderboardPlayer.velocityX > 0) {
                        // Moving right, hit left side of platform
                        leaderboardPlayer.x = platform.x - leaderboardPlayer.width;
                    } else if (leaderboardPlayer.velocityX < 0) {
                        // Moving left, hit right side of platform
                        leaderboardPlayer.x = platform.x + platform.width;
                    }
                    leaderboardPlayer.velocityX = 0;
                }
            }

            // Update position VERTICALLY, then check Y collisions
            leaderboardPlayer.y += leaderboardPlayer.velocityY * deltaTime;

            // Check vertical collisions
            for (const platform of leaderboardPlatforms) {
                if (checkCollision(leaderboardPlayer, platform)) {
                    if (leaderboardPlayer.velocityY > 0) {
                        // Moving down, hit top of platform
                        // White landing particles if falling with significant velocity
                        if (leaderboardPlayer.velocityY > 2) {
                            spawnParticles(leaderboardPlayer.x + leaderboardPlayer.width / 2, leaderboardPlayer.y + leaderboardPlayer.height, 8, 'rgb(255, 255, 255)', leaderboardPlayer.currentSize);
                        }
                        leaderboardPlayer.y = platform.y - leaderboardPlayer.height;
                        leaderboardPlayer.velocityY = 0;
                    } else if (leaderboardPlayer.velocityY < 0) {
                        // Moving up, hit bottom of platform
                        leaderboardPlayer.y = platform.y + platform.height;
                        leaderboardPlayer.velocityY = 0;
                        leaderboardIsJumping = false;
                    }
                }
            }
        }

        function renderLeaderboard(ctx, deltaTime = 1) {
            // Sky blue background
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, 1200, 800);

            // Grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            for (let x = 0; x < 1200; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 800);
                ctx.stroke();
            }
            for (let y = 0; y < 800; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(1200, y);
                ctx.stroke();
            }

            // Draw platforms
            for (const platform of leaderboardPlatforms) {
                if (platform.action === 'back') {
                    // Back portal - dark blue
                    const gradient = ctx.createLinearGradient(platform.x, platform.y, platform.x, platform.y + platform.height);
                    gradient.addColorStop(0, 'rgba(25, 82, 154, 0.7)');
                    gradient.addColorStop(1, 'rgba(25, 82, 154, 0.4)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                    ctx.shadowColor = '#19529a';
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = '#19529a';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(platform.x + 2, platform.y + 2, platform.width - 4, platform.height - 4);
                    ctx.shadowBlur = 0;

                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    ctx.shadowBlur = 5;
                    ctx.fillText(platform.label, platform.x + platform.width / 2, platform.y + platform.height / 2 + 4);
                    ctx.shadowBlur = 0;
                } else if (platform.levelId) {
                    // Level leaderboard portal - light blue
                    const gradient = ctx.createLinearGradient(platform.x, platform.y, platform.x, platform.y + platform.height);
                    gradient.addColorStop(0, 'rgba(79, 172, 254, 0.5)');
                    gradient.addColorStop(1, 'rgba(79, 172, 254, 0.2)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                    ctx.shadowColor = '#4facfe';
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = '#4facfe';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(platform.x + 2, platform.y + 2, platform.width - 4, platform.height - 4);
                    ctx.shadowBlur = 0;

                    ctx.fillStyle = '#000000';
                    ctx.font = 'bold 11px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(platform.levelName, platform.x + platform.width / 2 + 1, platform.y + platform.height / 2 + 5);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(platform.levelName, platform.x + platform.width / 2, platform.y + platform.height / 2 + 4);
                } else {
                    // Boundary platforms - standardized
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                    // Thicker dark border (inside edge)
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(platform.x + 2, platform.y + 2, platform.width - 4, platform.height - 4);

                    // Inner 40x40 grid lines
                    ctx.strokeStyle = '#388E3C';
                    ctx.lineWidth = 1;
                    for (let gx = 40; gx < platform.width; gx += 40) {
                        ctx.beginPath();
                        ctx.moveTo(platform.x + gx, platform.y);
                        ctx.lineTo(platform.x + gx, platform.y + platform.height);
                        ctx.stroke();
                    }
                    for (let gy = 40; gy < platform.height; gy += 40) {
                        ctx.beginPath();
                        ctx.moveTo(platform.x, platform.y + gy);
                        ctx.lineTo(platform.x + platform.width, platform.y + gy);
                        ctx.stroke();
                    }
                }
            }

            // Draw particles
            updateAndDrawParticles(ctx, 0, 0, deltaTime);

            // Draw player
            leaderboardPlayer.draw(ctx, 0, 0);

            // Title
            ctx.textAlign = 'center';
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#000000';
            ctx.fillText('LEADERBOARDS', 600, 32);
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText('LEADERBOARDS', 600, 30);

            // Instructions
            ctx.font = 'bold 14px Arial';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillText('Jump to a portal and press SPACE to view', 600, 57);
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText('Jump to a portal and press SPACE to view', 600, 55);

            // Controls hint
            ctx.font = '11px Arial';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillText('WASD/Arrows to move • ESC to return', 600, 77);
            ctx.fillStyle = '#CCCCCC';
            ctx.fillText('WASD/Arrows to move • ESC to return', 600, 75);
        }

        async function showLevelLeaderboard(levelId, levelName) {
            showScreen('leaderboardDetailScreen');

            // Fetch all times for this level
            const timesSnapshot = await database.ref('times_history').once('value');
            const timesData = timesSnapshot.val();

            // Fetch player data for usernames
            const playersSnapshot = await database.ref('players').once('value');
            const playersData = playersSnapshot.val();

            const leaderboard = [];

            if (timesData) {
                for (const [uid, userTimes] of Object.entries(timesData)) {
                    if (userTimes[levelId]) {
                        let bestTime = Infinity;
                        Object.values(userTimes[levelId]).forEach(timeEntry => {
                            if (timeEntry.time < bestTime) {
                                bestTime = timeEntry.time;
                            }
                        });

                        if (bestTime < Infinity) {
                            leaderboard.push({
                                uid: uid,
                                username: playersData?.[uid]?.username || 'Unknown',
                                time: bestTime
                            });
                        }
                    }
                }
            }

            // Sort by time ascending (fastest first)
            leaderboard.sort((a, b) => a.time - b.time);

            // Build leaderboard HTML
            let html = '<div style="padding: 20px;">';
            html += `<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 30px;">
                <button onclick="showLeaderboard()" style="
                    background: rgba(79, 172, 254, 0.2);
                    border: 2px solid #4facfe;
                    color: #fff;
                    padding: 10px 20px;
                    border-radius: 10px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: bold;
                    transition: all 0.2s;
                " onmouseover="this.style.background='rgba(79, 172, 254, 0.4)'" onmouseout="this.style.background='rgba(79, 172, 254, 0.2)'">← Back to Levels</button>
                <h2 style="color: #4facfe; margin: 0; font-size: 28px; text-shadow: 0 0 10px rgba(79, 172, 254, 0.5);">${levelName}</h2>
                <div style="width: 120px;"></div>
            </div>`;

            if (leaderboard.length === 0) {
                html += '<p style="text-align: center; color: #aaa; font-size: 18px;">No times recorded yet. Be the first!</p>';
            } else {
                html += '<div style="background: rgba(0,0,0,0.3); border-radius: 15px; padding: 25px; max-height: 500px; overflow-y: auto;">';

                for (let i = 0; i < Math.min(leaderboard.length, 100); i++) {
                    const player = leaderboard[i];
                    const isYou = player.uid === currentUser.uid;
                    const rankColor = i === 0 ? '#FFD700' : i === 1 ? '#C0C0C0' : i === 2 ? '#CD7F32' : '#4facfe';
                    const rankBg = i === 0 ? 'rgba(255, 215, 0, 0.1)' : i === 1 ? 'rgba(192, 192, 192, 0.1)' : i === 2 ? 'rgba(205, 127, 50, 0.1)' : 'rgba(79, 172, 254, 0.05)';

                    html += `<div style="
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        padding: 15px 20px;
                        margin: 8px 0;
                        background: ${isYou ? 'rgba(79, 172, 254, 0.2)' : rankBg};
                        border-radius: 10px;
                        border-left: 5px solid ${rankColor};
                        ${isYou ? 'box-shadow: 0 0 20px rgba(79, 172, 254, 0.5);' : ''}
                    ">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <span style="
                                font-size: 24px;
                                font-weight: bold;
                                color: ${rankColor};
                                min-width: 40px;
                                text-align: center;
                            ">${i === 0 ? '🥇' : i === 1 ? '🥈' : i === 2 ? '🥉' : (i + 1)}</span>
                            <span style="
                                color: white;
                                font-size: 18px;
                                ${isYou ? 'font-weight: bold; text-shadow: 0 0 10px rgba(79, 172, 254, 0.8);' : ''}
                            ">${player.username}${isYou ? ' ⭐' : ''}</span>
                        </div>
                        <span style="
                            color: #FFD700;
                            font-weight: bold;
                            font-size: 20px;
                            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
                        ">${formatTime(player.time)}</span>
                    </div>`;
                }

                html += '</div>';
            }

            html += '</div>';
            document.getElementById('leaderboardContent').innerHTML = html;
        }

        // Exit practice mode
        function exitPracticeMode() {
            practiceMode.active = false;
            document.getElementById('practiceCanvas').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('practiceBackBtn').style.display = 'none';
            initMainMenu();
        }

        // Notification system
        function showNotification(message, type = 'info') {
            const container = document.getElementById('notificationContainer');
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;

            container.appendChild(notification);

            // Remove after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Screen management
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        function showSettings() {
            showScreen('settingsScreen');
        }

        function logout() {
            auth.signOut().then(() => {
                // Redirect to login page
                window.location.reload();
            }).catch((error) => {
                console.error('Error logging out:', error);
                alert('Error logging out. Please try again.');
            });
        }

        function backToMainMenu() {
            // Clean up listeners
            if (currentPartyId) {
                database.ref('parties/' + currentPartyId).off();
            }
            if (currentLobbyId) {
                database.ref('lobbies/' + currentLobbyId).off();
            }

            currentPartyId = null;
            currentLobbyId = null;
            practiceMode.active = false;
            raceState.active = false;
            levelSelectActive = false;
            leaderboardActive = false;
            baseActive = false;
            backpackOpen = false;

            // Hide all screens
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('practiceCanvas').style.display = 'none';
            document.getElementById('raceCanvas').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('practiceBackBtn').style.display = 'none';
            document.getElementById('timer').style.display = 'none';
            document.getElementById('racePositions').style.display = 'none';

            // Show main menu
            initMainMenu();
        }

        function openBackpack() {
            backpackOpen = true;
            showScreen('backpackScreen');
            renderBackpackGrid();
        }

        function closeBackpack() {
            backpackOpen = false;
            backToMainMenu();
        }

        function renderBackpackGrid() {
            const grid = document.getElementById('backpackGrid');
            const gridSize = Math.sqrt(backpackSize); // Get grid dimensions (e.g., 1, 2, 3, 4, 5...)

            // Set grid layout
            grid.style.gridTemplateColumns = `repeat(${gridSize}, 50px)`;
            grid.style.gridTemplateRows = `repeat(${gridSize}, 50px)`;

            // Clear existing grid
            grid.innerHTML = '';

            // Create grid cells
            for (let i = 0; i < backpackSize; i++) {
                const cell = document.createElement('div');
                cell.style.width = '50px';
                cell.style.height = '50px';
                cell.style.border = '2px solid #4facfe';
                cell.style.borderRadius = '5px';

                // Fill cells with credits (gold) or empty (dark)
                if (i < userCredits) {
                    cell.style.background = 'linear-gradient(135deg, #FFD700, #FFA500)';
                    cell.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.5)';
                } else {
                    cell.style.background = 'rgba(0, 0, 0, 0.5)';
                }

                grid.appendChild(cell);
            }

            // Update text counts
            document.getElementById('backpackCreditsCount').textContent = userCredits;
            document.getElementById('backpackMaxSize').textContent = backpackSize;
        }

        // Keyboard handling
        document.addEventListener('keydown', (e) => {
            // G key resets zoom in all modes
            if (e.key === 'g' || e.key === 'G') {
                baseZoom = 1;
                practiceZoom = 1;
                menuZoom = 1;
            }

            // Store both original key and lowercase for compatibility
            menuKeys[e.key] = true;
            menuKeys[e.key.toLowerCase()] = true;
            practiceMode.keys[e.key] = true;
            raceState.keys[e.key] = true;
            baseKeys[e.key] = true;
            baseKeys[e.key.toLowerCase()] = true;
            levelSelectKeys[e.key] = true;
            levelSelectKeys[e.key.toLowerCase()] = true;
            shopHubKeys[e.key] = true;
            shopHubKeys[e.key.toLowerCase()] = true;

            if (e.key === 'Escape') {
                if (practiceMode.active) {
                    exitPracticeMode();
                }
            }

            // R key to restart level
            if ((e.key === 'r' || e.key === 'R') && practiceMode.active && practiceMode.isLevelMode) {
                // Reset player to start position
                const player = practiceMode.player;
                player.x = practiceMode.levelData.start.x;
                player.y = practiceMode.levelData.start.y;
                player.velocityX = 0;
                player.velocityY = 0;
                player.currentSize = 40;
                player.width = 40;
                player.height = 40;

                // Reset timer and state
                practiceMode.startTime = null;
                practiceMode.finished = false;
                practiceMode.isDead = false;
            }
        });

        document.addEventListener('keyup', (e) => {
            menuKeys[e.key] = false;
            menuKeys[e.key.toLowerCase()] = false;
            baseKeys[e.key] = false;
            baseKeys[e.key.toLowerCase()] = false;
            levelSelectKeys[e.key] = false;
            levelSelectKeys[e.key.toLowerCase()] = false;
            shopHubKeys[e.key] = false;
            shopHubKeys[e.key.toLowerCase()] = false;
            delete practiceMode.keys[e.key];
            delete raceState.keys[e.key];
        });

        // Initialize on auth
        auth.onAuthStateChanged(async (user) => {
            try {
                console.log('Auth state changed, user:', user ? user.email : 'null');

                if (!user) {
                    console.log('No user, redirecting to index.html');
                    window.location.href = 'index.html';
                    return;
                }

                currentUser = user;
                console.log('User authenticated:', currentUser.email);

                // Get username
                console.log('Fetching username from database...');
                const userSnapshot = await database.ref('users/' + user.uid).once('value');
                const userData = userSnapshot.val();

                if (userData && userData.username) {
                    currentUsername = userData.username;
                    console.log('Username loaded:', currentUsername);
                } else {
                    currentUsername = user.email.split('@')[0];
                    console.log('Creating new user with username:', currentUsername);
                    await database.ref('users/' + user.uid).set({
                        username: currentUsername,
                        createdAt: firebase.database.ServerValue.TIMESTAMP
                    });
                }

                console.log('Initializing user data...');
                await initUserData();

                console.log('Initializing default levels...');
                await initializeDefaultLevels();

                console.log('Initializing main menu...');
                initMainMenu();

                console.log('Game initialization complete!');
            } catch (error) {
                console.error('ERROR during initialization:', error);
                console.error('Error stack:', error.stack);
                alert('Error loading game: ' + error.message + '\n\nCheck console for details.');
            }
        });
    </script>
</body>
</html>