<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Racers Online</title>
    <link rel="icon" type="image/png" id="favicon">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #2c2c2c;
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        canvas {
            border: 5px solid #4facfe;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(79, 172, 254, 0.4);
            background: #87CEEB;
        }

        .screen {
            display: none;
            position: absolute;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            backdrop-filter: blur(10px);
            color: white;
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #4facfe;
            text-align: center;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .screen.active {
            display: block;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #FFC107;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }

        h2 {
            font-size: 32px;
            margin: 20px 0;
            color: #4facfe;
        }

        button {
            padding: 15px 30px;
            font-size: 18px;
            margin: 10px;
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.3);
            font-weight: bold;
        }

        button:hover {
            background: linear-gradient(135deg, #6fd0ff, #20f5ff);
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.5);
        }

        button.secondary {
            background: linear-gradient(135deg, #666, #888);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        button.danger {
            background: linear-gradient(135deg, rgba(255,0,0,0.7), rgba(255,50,50,0.7));
            box-shadow: 0 4px 15px rgba(255, 0, 0, 0.3);
        }

        button.success {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        input, select {
            padding: 12px;
            font-size: 16px;
            margin: 10px;
            border-radius: 12px;
            border: 2px solid #4facfe;
            background: rgba(255,255,255,0.9);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #00f2fe;
            box-shadow: 0 4px 20px rgba(79, 172, 254, 0.4);
        }

        #creditPanel {
            position: absolute;
            top: 50%;
            left: calc(50% - 600px - 180px); /* Canvas is 1200px wide, center - half - panel spacing */
            transform: translateY(-50%);
            width: 160px;
            height: 800px;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            border: 3px solid #4facfe;
            border-radius: 15px;
            padding: 20px;
            z-index: 50;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #leaderboardPanel {
            position: absolute;
            top: 50%;
            right: calc(50% - 600px - 180px); /* Match left panel positioning */
            transform: translateY(-50%);
            width: 160px;
            height: 800px;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            border: 3px solid #4facfe;
            border-radius: 15px;
            padding: 15px;
            z-index: 50;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
        }

        .cosmetic-item {
            background: rgba(0,0,0,0.4);
            padding: 15px;
            margin: 10px;
            border-radius: 12px;
            display: inline-block;
            min-width: 200px;
            border: 2px solid rgba(79, 172, 254, 0.3);
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .cosmetic-item:hover {
            border-color: #4facfe;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.4);
        }

        .cosmetic-item.owned {
            border: 2px solid #4facfe;
            background: rgba(79, 172, 254, 0.2);
        }

        .cosmetic-item.equipped {
            background: rgba(79, 172, 254, 0.3);
            border: 2px solid #FFC107;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #4facfe;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            display: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }

        #timer {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            z-index: 50;
            display: none;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            padding: 20px 40px;
            border-radius: 15px;
            border: 3px solid #4facfe;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            font-family: 'Courier New', monospace;
        }

        .party-member {
            background: rgba(0,0,0,0.4);
            padding: 12px;
            margin: 8px;
            border-radius: 12px;
            border: 2px solid rgba(79, 172, 254, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s;
        }

        .party-member:hover {
            border-color: #4facfe;
            transform: translateY(-2px);
        }

        .party-member.ready {
            background: rgba(0,255,0,0.2);
            border: 2px solid #0f0;
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.3);
        }

        .invitation {
            background: rgba(255,215,0,0.2);
            padding: 18px;
            margin: 10px;
            border-radius: 15px;
            border: 2px solid #FFC107;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
        }

        .platform-button {
            position: absolute;
            background: rgba(79, 172, 254, 0.3);
            border: 3px solid #4facfe;
            color: #4facfe;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
        }

        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            color: white;
            text-shadow: 5px 5px 10px rgba(0,0,0,0.9);
            z-index: 200;
            display: none;
            font-weight: bold;
        }

        .player-list {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
        }

        .shop-category {
            margin: 20px 0;
        }

        .cosmetics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .levels-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .level-card {
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(79, 172, 254, 0.1));
            border: 2px solid #4facfe;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .level-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(79, 172, 254, 0.5);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
        }

        #menuCanvas {
            display: block;
        }

        .menu-hud {
            position: absolute;
            top: 20px;
            text-align: center;
            width: 100%;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            z-index: 10;
            pointer-events: none;
        }

        .menu-title {
            font-size: 64px;
            color: #FFC107;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .scroll-container {
            max-height: 60vh;
            overflow-y: auto;
            padding: 20px;
        }

        #raceResults {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 20px;
            z-index: 200;
            display: none;
            min-width: 400px;
        }

        .result-entry {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        .result-entry.winner {
            background: rgba(255,215,0,0.3);
            border: 2px solid gold;
        }

        #racePositions {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            z-index: 50;
            display: none;
        }
    </style>
</head>
<body>
    <!-- Main Menu Canvas (Interactive Platformer) -->
    <canvas id="menuCanvas" width="1200" height="800"></canvas>
    <div class="menu-hud" id="menuHUD" style="display: none;">
    </div>

    <!-- Left Side Credit Panel -->
    <div id="creditPanel" style="display: none;"></div>

    <!-- Right Side Leaderboard Panel -->
    <div id="leaderboardPanel" style="display: none;">
        <div style="font-family: 'Inter', Arial, sans-serif; font-size: 12px; color: #fff; margin-bottom: 10px; text-align: center; font-weight: bold;">
            Credits Leaderboard
        </div>
        <div id="leaderboardList" style="font-family: 'Inter', Arial, sans-serif; font-size: 10px; color: #fff;">
        </div>
    </div>

    <!-- Practice Mode Canvas -->
    <canvas id="practiceCanvas" width="1200" height="800" style="display: none;"></canvas>
    <div id="hud"></div>
    <button id="practiceBackBtn" onclick="exitPracticeMode()" style="position: absolute; top: 20px; right: 20px; z-index: 100; display: none; padding: 10px 20px; background: rgba(255,0,0,0.7); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">Back to Menu</button>

    <!-- Race Canvas -->
    <canvas id="raceCanvas" width="1200" height="800" style="display: none;"></canvas>
    <div id="timer"></div>
    <div id="racePositions"></div>
    <div id="countdown"></div>

    <!-- Party Screen -->
    <div id="partyScreen" class="screen">
        <h1>Party</h1>
        <div id="partyInfo"></div>
        <div id="partyMembers" class="player-list"></div>
        <div id="partyInvitations"></div>
        <div style="margin-top: 20px;">
            <input type="text" id="inviteUsername" placeholder="Enter username to invite">
            <button onclick="sendInvite()">Send Invite</button>
        </div>
        <div id="partyControls" style="margin-top: 20px;"></div>
        <button onclick="leaveParty()" class="secondary">Leave Party</button>
        <button onclick="backToMainMenu()" class="secondary">Back to Menu</button>
    </div>

    <!-- Join Party Screen -->
    <div id="joinPartyScreen" class="screen">
        <h1>Join Party</h1>
        <input type="text" id="partyIdInput" placeholder="Enter Party ID">
        <button onclick="joinPartyById()">Join Party</button>
        <button onclick="backToMainMenu()" class="secondary">Back</button>
    </div>

    <!-- Lobby Screen -->
    <div id="lobbyScreen" class="screen">
        <h1>Race Lobby</h1>
        <div id="lobbyInfo"></div>
        <div id="lobbyPlayers" class="player-list"></div>
        <div id="lobbyControls"></div>
        <button onclick="leaveLobby()" class="secondary">Leave Lobby</button>
    </div>

    <!-- Cosmetic Shop Screen -->
    <div id="shopScreen" class="screen">
        <h1>Cosmetic Shop</h1>
        <div id="shopCredits" style="font-size: 24px; color: #FFC107; margin-bottom: 20px;"></div>
        <div class="scroll-container">
            <div id="shopContent"></div>
        </div>
        <button onclick="backToMainMenu()">Back to Menu</button>
    </div>

    <!-- Practice Levels Screen -->
    <div id="practiceLevelsScreen" class="screen">
        <canvas id="levelSelectCanvas" width="1200" height="800" style="display: block; margin: 0 auto; background: #87CEEB;"></canvas>
        <div id="levelSelectHUD" style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; color: white; font-size: 18px; text-align: center;">
            Use arrow keys to move, press SPACE to select level
        </div>
    </div>

    <!-- Stats Screen -->
    <div id="statsScreen" class="screen">
        <h1>Your Stats</h1>
        <div id="statsContent" style="font-size: 20px;"></div>
        <button onclick="backToMainMenu()">Back to Menu</button>
    </div>

    <!-- Base Screen -->
    <div id="baseScreen" class="screen">
        <h1>Your Base</h1>
        <div id="baseCredits" style="font-size: 24px; color: #FFC107; margin-bottom: 20px;"></div>
        <canvas id="baseCanvas" width="800" height="600" style="border: 3px solid #4facfe; border-radius: 10px;"></canvas>
        <div style="margin-top: 20px;">
            <p>Click/hold to place 40x40px blocks (costs 1 credit each)</p>
            <p>Click on existing blocks to add more credits (max 3 per block)</p>
            <p>Right-click/hold to remove ONE credit from blocks</p>
            <p>Mouse wheel to zoom, press G to reset zoom</p>
        </div>
        <button onclick="backToMainMenu()">Back to Menu</button>
    </div>

    <!-- Leaderboard Screen -->
    <div id="leaderboardScreen" class="screen">
        <div class="scroll-container" style="padding-top: 20px;">
            <div id="leaderboardContent" style="max-width: 1000px; margin: 0 auto;"></div>
        </div>
        <button onclick="backToMainMenu()" style="margin-top: 20px;">Back to Menu</button>
    </div>

    <!-- Settings Screen -->
    <div id="settingsScreen" class="screen">
        <h1>Settings</h1>
        <div style="margin-top: 40px;">
            <button onclick="logout()" style="font-size: 24px; padding: 15px 30px; background: #ff4444; color: white; border: none; border-radius: 10px; cursor: pointer;">Logout</button>
        </div>
        <button onclick="backToMainMenu()" style="margin-top: 40px;">Back to Menu</button>
    </div>

    <!-- Race Results -->
    <div id="raceResults">
        <h2>Race Complete!</h2>
        <div id="resultsContent"></div>
        <button onclick="returnToParty()" class="success">Return to Party</button>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBLkFMipRS631fDNr8uwgozmxXBnqLd5_o",
            authDomain: "base-control-b391e.firebaseapp.com",
            databaseURL: "https://base-control-b391e-default-rtdb.firebaseio.com",
            projectId: "base-control-b391e",
            storageBucket: "base-control-b391e.firebasestorage.app",
            messagingSenderId: "116375376675",
            appId: "1:116375376675:web:cdc8688222c7c35accf296",
            measurementId: "G-JY7P6D49HM"
        };

        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const database = firebase.database();

        // Set auth persistence to SESSION - lasts until browser closes
        // Login page uses NONE to require re-login when visiting site
        auth.setPersistence(firebase.auth.Auth.Persistence.SESSION);

        // Create favicon
        const faviconCanvas = document.createElement('canvas');
        faviconCanvas.width = 32;
        faviconCanvas.height = 32;
        const faviconCtx = faviconCanvas.getContext('2d');
        faviconCtx.fillStyle = '#FF8C42';
        faviconCtx.fillRect(6, 6, 20, 20);
        faviconCtx.strokeStyle = '#333';
        faviconCtx.lineWidth = 2;
        faviconCtx.strokeRect(6, 6, 20, 20);
        document.getElementById('favicon').href = faviconCanvas.toDataURL('image/png');

        // Global variables
        let currentUser = null;
        let currentUsername = '';
        let userCredits = 0; // On-hand credits (can be spent)
        let secureCredits = 0; // Secure credits (stored at base, main credits display)
        let userCosmetics = { skins: ['default_orange'], trails: ['none'], hats: ['none'], effects: ['none'] };
        let equippedCosmetics = { skin: 'default_orange', trail: 'none', hat: 'none', effect: 'none' };
        let equippedItem = 'none'; // Equippable item: 'none' or 'credits'
        let userStats = { racesWon: 0, racesPlayed: 0, totalCreditsEarned: 0 };

        let currentParty = null;
        let currentPartyId = null;
        let currentLobby = null;
        let currentLobbyId = null;

        // Jump state tracking
        let menuIsJumping = false;
        let practiceIsJumping = false;
        let raceIsJumping = false;

        // Game constants
        const GRAVITY = 0.042;
        const MOVE_SPEED = 0.28;
        const GROUND_MAX_SPEED = 3.5;
        const AIR_MAX_SPEED = 4.375; // 1.25x ground speed
        const AIR_RESISTANCE = 0.88;
        const GROUND_FRICTION = 0.94;
        const GROUND_ACCELERATION = 0.15; // Gradual acceleration when grounded
        const JUMP_POWER = 3.70;
        const FAST_FALL_MULTIPLIER = 2.0;

        // Game feel constants
        const COYOTE_TIME = 6; // Frames you can still jump after leaving platform
        const JUMP_BUFFER_TIME = 8; // Frames to remember jump input before landing
        const ACCELERATION = 0.5; // Smoother acceleration
        const DECELERATION = 0.8; // Smoother deceleration

        // Particle system
        class Particle {
            constructor(x, y, vx, vy, color, life, size = 4) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.size = size;
            }

            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.vy += GRAVITY * deltaTime * 0.5;
                this.life -= deltaTime;
            }

            draw(ctx, cameraX, cameraY) {
                const alpha = this.life / this.maxLife;
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                ctx.fillRect(screenX, screenY, this.size, this.size);
            }
        }

        let particles = [];

        function spawnParticles(x, y, count, color, playerSize = 40) {
            // Scale particle size based on player size (default 40px)
            const particleSize = Math.max(2, Math.floor(playerSize / 10));

            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 2 + 1;
                particles.push(new Particle(
                    x,
                    y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed - 1,
                    color,
                    30 + Math.random() * 20,
                    particleSize
                ));
            }
        }

        function updateAndDrawParticles(ctx, cameraX, cameraY, deltaTime) {
            // Update and draw all particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(deltaTime);
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                } else {
                    particles[i].draw(ctx, cameraX, cameraY);
                }
            }
        }

        // Cosmetics catalog
        const cosmeticsCatalog = {
            skins: [
                { id: 'default_orange', name: 'Default Orange', price: 0, color: '#FF8C42' },
                { id: 'red_racer', name: 'Red Racer', price: 50, color: '#FF0000' },
                { id: 'blue_blur', name: 'Blue Blur', price: 50, color: '#0066FF' },
                { id: 'green_machine', name: 'Green Machine', price: 100, color: '#00FF00' },
                { id: 'purple_pro', name: 'Purple Pro', price: 100, color: '#9900FF' },
                { id: 'golden_champion', name: 'Golden Champion', price: 500, color: '#FFD700' }
            ],
            trails: [
                { id: 'none', name: 'None', price: 0 },
                { id: 'rainbow', name: 'Rainbow Trail', price: 100 },
                { id: 'fire', name: 'Fire Trail', price: 150 },
                { id: 'ice', name: 'Ice Trail', price: 150 },
                { id: 'star', name: 'Star Trail', price: 200 }
            ],
            hats: [
                { id: 'none', name: 'None', price: 0 },
                { id: 'crown', name: 'Crown', price: 200 },
                { id: 'propeller', name: 'Propeller', price: 150 },
                { id: 'halo', name: 'Halo', price: 300 }
            ],
            effects: [
                { id: 'none', name: 'None', price: 0 },
                { id: 'sparkles', name: 'Sparkles', price: 100 },
                { id: 'glow', name: 'Glow', price: 150 },
                { id: 'shadow_clone', name: 'Shadow Clone', price: 300 }
            ]
        };

        // Map definitions (preserved from original)
        const maps = [
            {
                id: 'simple_map',
                name: 'Simple Map',
                difficulty: 'Easy',
                platforms: [
                    { x: -40, y: -280, width: 40, height: 320 },
                    { x: 0, y: -280, width: 280, height: 40 },
                    { x: 280, y: -280, width: 40, height: 320 },
                    { x: 0, y: 0, width: 280, height: 40 }
                ],
                hazards: [
                    { x: 120, y: -120, width: 40, height: 120 }
                ],
                growers: [],
                shrinkers: [],
                defaultSizeBlocks: [],
                start: { x: 0, y: -40, width: 40, height: 40 },
                finish: { x: 240, y: -40, width: 40, height: 40 }
            },
            {
                id: 'custom_level',
                name: 'Original Map',
                difficulty: 'Medium',
                platforms: [
                    { x: 0, y: 400, width: 40, height: 200 },
                    { x: 40, y: 560, width: 520, height: 40 },
                    { x: 240, y: 440, width: 80, height: 40 },
                    { x: 320, y: 320, width: 80, height: 40 },
                    { x: 240, y: 200, width: 80, height: 40 },
                    { x: 320, y: 80, width: 80, height: 40 },
                    { x: 160, y: -80, width: 360, height: 40 },
                    { x: 480, y: -40, width: 40, height: 480 },
                    { x: -240, y: 160, width: 400, height: 40 },
                    { x: -80, y: 40, width: 40, height: 160 },
                    { x: -160, y: -80, width: 320, height: 40 },
                    { x: -200, y: -80, width: 40, height: 200 },
                    { x: -320, y: 80, width: 120, height: 40 },
                    { x: -320, y: 120, width: 40, height: 240 },
                    { x: -240, y: 480, width: 40, height: 40 },
                    { x: 0, y: 720, width: 40, height: 40 },
                    { x: 160, y: 720, width: 40, height: 40 },
                    { x: 560, y: 320, width: 40, height: 280 },
                    { x: 160, y: 40, width: 80, height: 40 },
                    { x: 440, y: 680, width: 40, height: 40 },
                    { x: 600, y: 520, width: 240, height: 40 },
                    { x: 480, y: 640, width: 440, height: 40 },
                    { x: 920, y: 320, width: 40, height: 360 },
                    { x: 600, y: 320, width: 320, height: 40 },
                    { x: 320, y: 760, width: 120, height: 40 }
                ],
                hazards: [
                    { x: 200, y: 80, width: 40, height: 80 },
                    { x: 0, y: 360, width: 40, height: 40 },
                    { x: -520, y: 800, width: 1560, height: 80 }
                ],
                growers: [],
                shrinkers: [],
                defaultSizeBlocks: [],
                start: { x: 80, y: 480 },
                finish: { x: 700, y: 470, width: 100, height: 50 }
            },
            {
                id: 'hard_level',
                name: 'Hard Level',
                difficulty: 'Hard',
                platforms: [
                    { x: 40, y: -200, width: 240, height: 30 },
                    { x: 40, y: -170, width: 80, height: 30 },
                    { x: 200, y: -170, width: 80, height: 30 },
                    { x: -280, y: -410, width: 60, height: 90 },
                    { x: -280, y: -260, width: 60, height: 20 },
                    { x: -280, y: -120, width: 40, height: 40 },
                    { x: -200, y: -40, width: 40, height: 40 },
                    { x: 560, y: -400, width: 240, height: 80 },
                    { x: 400, y: -640, width: 160, height: 80 },
                    { x: 560, y: -800, width: 80, height: 80 },
                    { x: 240, y: -1040, width: 160, height: 80 },
                    { x: -80, y: 0, width: 115, height: 40 },
                    { x: 340, y: 20, width: 180, height: 20 },
                    { x: 360, y: 0, width: 160, height: 20 },
                    { x: 40, y: 100, width: 100, height: 20 },
                    { x: 160, y: 140, width: 80, height: 20 },
                    { x: 260, y: 80, width: 60, height: 20 },
                    { x: 320, y: -80, width: 20, height: 80 },
                    { x: 520, y: -120, width: 160, height: 40 },
                    { x: 640, y: -80, width: 40, height: 120 },
                    { x: 520, y: 0, width: 120, height: 40 }
                ],
                hazards: [
                    { x: 40, y: -320, width: 80, height: 120 },
                    { x: -80, y: -200, width: 40, height: 200 },
                    { x: 240, y: -1120, width: 80, height: 80 },
                    { x: -360, y: 280, width: 1280, height: 40 },
                    { x: 920, y: -1280, width: 40, height: 1600 },
                    { x: -360, y: -1280, width: 1280, height: 40 },
                    { x: -400, y: -1280, width: 40, height: 1600 }
                ],
                growers: [
                    { x: 80, y: -640, width: 80, height: 80 }
                ],
                shrinkers: [
                    { x: 80, y: -1200, width: 80, height: 80 }
                ],
                defaultSizeBlocks: [
                    { x: 520, y: -80, width: 40, height: 80 }
                ],
                start: { x: 0, y: -80, width: 40, height: 40 },
                finish: { x: 600, y: -80, width: 40, height: 80 }
            }
        ];

        // Player class for rendering
        class Player {
            constructor(x, y, cosmetics) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.velocityX = 0;
                this.velocityY = 0;
                this.cosmetics = cosmetics || { skin: 'default_orange', trail: 'none', hat: 'none', effect: 'none' };
                this.trail = [];
                this.currentSize = 40;

                // Game feel variables
                this.coyoteTimer = 0;
                this.jumpBufferTimer = 0;
                this.wasGrounded = false;

                // Size transition variables (from level creator)
                this.targetSize = 40;
                this.sizeTransitioning = false;
                this.sizeTransitionProgress = 0;
            }

            getSkinColor() {
                const skin = cosmeticsCatalog.skins.find(s => s.id === this.cosmetics.skin);
                return skin ? skin.color : '#FF8C42';
            }

            updateTrail() {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 10) {
                    this.trail.shift();
                }
            }

            draw(ctx, cameraX, cameraY, showName, name) {
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;

                // Draw trail
                if (this.cosmetics.trail !== 'none' && this.trail.length > 1) {
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const alpha = i / this.trail.length;
                        const trailX = this.trail[i].x - cameraX;
                        const trailY = this.trail[i].y - cameraY;

                        ctx.globalAlpha = alpha * 0.5;

                        if (this.cosmetics.trail === 'rainbow') {
                            ctx.fillStyle = `hsl(${(i * 36) % 360}, 100%, 50%)`;
                        } else if (this.cosmetics.trail === 'fire') {
                            ctx.fillStyle = i % 2 === 0 ? '#FF6600' : '#FF0000';
                        } else if (this.cosmetics.trail === 'ice') {
                            ctx.fillStyle = i % 2 === 0 ? '#00FFFF' : '#FFFFFF';
                        } else if (this.cosmetics.trail === 'star') {
                            ctx.fillStyle = '#FFFF00';
                        }

                        ctx.fillRect(trailX, trailY, this.width, this.height);
                    }
                    ctx.restore();
                }

                // Draw effect (behind player)
                if (this.cosmetics.effect === 'glow') {
                    ctx.save();
                    ctx.shadowColor = this.getSkinColor();
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = this.getSkinColor();
                    ctx.fillRect(screenX, screenY, this.width, this.height);
                    ctx.restore();
                } else if (this.cosmetics.effect === 'shadow_clone') {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = this.getSkinColor();
                    ctx.fillRect(screenX - 10, screenY + 5, this.width, this.height);
                    ctx.restore();
                }

                // Draw player
                ctx.fillStyle = this.getSkinColor();
                ctx.fillRect(screenX, screenY, this.width, this.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX, screenY, this.width, this.height);

                // Draw hat
                if (this.cosmetics.hat === 'crown') {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(screenX + this.width / 2, screenY - 15);
                    ctx.lineTo(screenX + 5, screenY - 5);
                    ctx.lineTo(screenX + this.width - 5, screenY - 5);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.cosmetics.hat === 'propeller') {
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(screenX + 10, screenY - 10);
                    ctx.lineTo(screenX + this.width - 10, screenY - 10);
                    ctx.stroke();
                } else if (this.cosmetics.hat === 'halo') {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, screenY - 10, 15, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw sparkles effect
                if (this.cosmetics.effect === 'sparkles') {
                    ctx.fillStyle = '#FFFF00';
                    for (let i = 0; i < 5; i++) {
                        const angle = (Date.now() / 100 + i * 72) % 360;
                        const rad = angle * Math.PI / 180;
                        const sparkX = screenX + this.width / 2 + Math.cos(rad) * 30;
                        const sparkY = screenY + this.height / 2 + Math.sin(rad) * 30;
                        ctx.fillRect(sparkX - 2, sparkY - 2, 4, 4);
                    }
                }

                // Draw equipped item (credits display)
                if (equippedItem === 'credits' && userCredits > 0) {
                    // Small yellow square in center of character (1/4 size)
                    const creditSize = this.width / 4;
                    const creditX = screenX + (this.width - creditSize) / 2;
                    const creditY = screenY + (this.height - creditSize) / 2;
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(creditX, creditY, creditSize, creditSize);
                    ctx.strokeStyle = '#FFA500';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(creditX, creditY, creditSize, creditSize);
                }

                // Draw name
                if (showName && name) {
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(name, screenX + this.width / 2, screenY - 10);
                }
            }
        }

        // Initialize user data
        async function initUserData() {
            if (!currentUser) return;

            const userRef = database.ref('players/' + currentUser.uid);
            const snapshot = await userRef.once('value');
            const data = snapshot.val();

            if (data) {
                userCredits = data.credits || 0;
                userCosmetics = data.cosmetics || { skins: ['default_orange'], trails: ['none'], hats: ['none'], effects: ['none'] };
                equippedCosmetics = data.equippedCosmetics || { skin: 'default_orange', trail: 'none', hat: 'none', effect: 'none' };
                equippedItem = data.equippedItem || 'none';
                userStats = data.stats || { racesWon: 0, racesPlayed: 0, totalCreditsEarned: 0 };

                // Calculate secure credits from BASE blocks (sum of all credits in blocks)
                const baseBlocks = data.baseBlocks || [];
                secureCredits = baseBlocks.reduce((sum, block) => sum + (block.credits || 1), 0);

                // Update Firebase to match actual BASE block count
                await userRef.update({
                    secureCredits: secureCredits
                });
            } else {
                // Initialize new user
                secureCredits = 0;
                await userRef.set({
                    username: currentUsername,
                    credits: 0,
                    secureCredits: 0,
                    cosmetics: userCosmetics,
                    equippedCosmetics: equippedCosmetics,
                    stats: userStats
                });
            }
        }

        // Update credits in Firebase
        async function updateCredits(amount, type = 'onhand') {
            if (type === 'onhand') {
                userCredits += amount;
            } else if (type === 'secure') {
                secureCredits += amount;
            }

            if (amount > 0) {
                userStats.totalCreditsEarned += amount;
            }

            await database.ref('players/' + currentUser.uid).update({
                credits: userCredits,
                secureCredits: secureCredits,
                stats: userStats
            });
        }

        async function transferCredits(amount, fromType, toType) {
            if (fromType === 'onhand' && userCredits >= amount) {
                userCredits -= amount;
                secureCredits += amount;
            } else if (fromType === 'secure' && secureCredits >= amount) {
                secureCredits -= amount;
                userCredits += amount;
            } else {
                return false; // Insufficient funds
            }

            await database.ref('players/' + currentUser.uid).update({
                credits: userCredits,
                secureCredits: secureCredits
            });
            return true;
        }

        // Main menu (interactive platformer)
        let menuPlayer = null;
        let menuKeys = {};
        let menuPlatforms = [];
        let menuCameraX = 0;
        let menuCameraY = 0;

        async function loadMiniLeaderboard() {
            try {
                // Fetch ALL players
                const playersSnapshot = await database.ref('players').once('value');
                const players = [];

                playersSnapshot.forEach(child => {
                    const data = child.val();
                    players.push({
                        username: data.username || 'Unknown',
                        secureCredits: data.secureCredits || 0
                    });
                });

                // Sort by secure credits descending
                players.sort((a, b) => b.secureCredits - a.secureCredits);

                // Build leaderboard HTML
                let html = '';
                for (let i = 0; i < players.length; i++) {
                    const player = players[i];
                    const isCurrentUser = player.username === currentUsername;
                    html += `<div style="padding: 4px 0; ${isCurrentUser ? 'background: rgba(79, 172, 254, 0.3); border-radius: 5px; padding: 4px;' : ''}">
                        <div style="font-size: 9px;">${i + 1}. ${player.username}</div>
                        <div style="font-size: 8px; color: #FFD700;">${player.secureCredits}</div>
                    </div>`;
                }

                document.getElementById('leaderboardList').innerHTML = html;
            } catch (error) {
                console.error('Error loading leaderboard:', error);
                document.getElementById('leaderboardList').innerHTML = '<div style="font-size: 9px;">Error loading</div>';
            }
        }

        function initMainMenu() {
            const canvas = document.getElementById('menuCanvas');
            const ctx = canvas.getContext('2d');

            canvas.style.display = 'block';
            document.getElementById('menuHUD').style.display = 'block';

            // Portal platforms: 3 stacks (left: 3, middle: 4, right: 3) with 80px spacing
            // All platforms are 120px wide, 40px tall, stacked with 80px gap between them

            const leftX = 200;   // Left stack X position
            const middleX = 540; // Middle stack X position (centered at 600)
            const rightX = 880;  // Right stack X position
            const middleBottomY = 600; // Middle stack bottom (EARN MODE)
            const sideBottomY = middleBottomY - 40; // Side stacks 40px higher
            const spacing = 120; // 40px platform + 80px gap = 120px total spacing
            const groundY = middleBottomY + 120; // Ground 120px below EARN MODE

            menuPlatforms = [
                // Boundary walls - symmetrical around center
                { x: -640, y: -640, width: 40, height: 1400, label: '', action: 'none' }, // Left wall
                { x: 1200, y: -640, width: 40, height: 1400, label: '', action: 'none' }, // Right wall
                { x: -640, y: -640, width: 1880, height: 40, label: '', action: 'none' }, // Ceiling
                { x: -640, y: 720, width: 1880, height: 40, label: '', action: 'none' },  // Ground (moved to boundaries)

                // Interior platforms from JSON
                { x: -40, y: -120, width: 120, height: 40, label: '', action: 'none' },
                { x: -40, y: -240, width: 120, height: 40, label: '', action: 'none' },
                { x: -40, y: -360, width: 120, height: 40, label: '', action: 'none' },
                { x: 160, y: -280, width: 120, height: 40, label: '', action: 'none' },
                { x: 160, y: -160, width: 120, height: 40, label: '', action: 'none' },
                { x: -240, y: -280, width: 120, height: 40, label: '', action: 'none' },
                { x: -240, y: -160, width: 120, height: 40, label: '', action: 'none' },
                { x: -240, y: -400, width: 120, height: 40, label: '', action: 'none' },
                { x: -40, y: -480, width: 120, height: 40, label: '', action: 'none' },
                { x: 160, y: -400, width: 120, height: 40, label: '', action: 'none' },

                // Stepped walls from JSON
                { x: -360, y: -80, width: 40, height: 80, label: '', action: 'none' },
                { x: -400, y: -160, width: 40, height: 160, label: '', action: 'none' },
                { x: -440, y: -240, width: 40, height: 240, label: '', action: 'none' },
                { x: -480, y: -320, width: 40, height: 320, label: '', action: 'none' },
                { x: -520, y: -400, width: 40, height: 400, label: '', action: 'none' },
                { x: -560, y: -480, width: 40, height: 480, label: '', action: 'none' },
                { x: 360, y: -80, width: 40, height: 80, label: '', action: 'none' },
                { x: 400, y: -160, width: 40, height: 160, label: '', action: 'none' },
                { x: 440, y: -240, width: 40, height: 240, label: '', action: 'none' },
                { x: 480, y: -320, width: 40, height: 320, label: '', action: 'none' },
                { x: 520, y: -400, width: 40, height: 400, label: '', action: 'none' },
                { x: 560, y: -480, width: 40, height: 480, label: '', action: 'none' },

                // LEFT STACK (3 portals) - 40px higher than middle
                { x: leftX, y: sideBottomY, width: 120, height: 40, label: 'BASE', action: 'base' },
                { x: leftX, y: sideBottomY - spacing, width: 120, height: 40, label: 'VIEW STATS', action: 'stats' },
                { x: leftX, y: sideBottomY - spacing * 2, width: 120, height: 40, label: 'COSMETIC SHOP', action: 'shop' },

                // MIDDLE STACK (4 portals)
                { x: middleX, y: middleBottomY, width: 120, height: 40, label: 'EARN MODE', action: 'practice' },
                { x: middleX, y: middleBottomY - spacing, width: 120, height: 40, label: 'PRACTICE LEVELS', action: 'practiceLevels' },
                { x: middleX, y: middleBottomY - spacing * 2, width: 120, height: 40, label: 'CREATE PARTY', action: 'createParty' },
                { x: middleX, y: middleBottomY - spacing * 3, width: 120, height: 40, label: 'JOIN PARTY', action: 'joinParty' },

                // RIGHT STACK (3 portals) - 40px higher than middle
                { x: rightX, y: sideBottomY, width: 120, height: 40, label: 'LEVEL CREATOR', action: 'creator' },
                { x: rightX, y: sideBottomY - spacing, width: 120, height: 40, label: 'LEADERBOARD', action: 'leaderboard' },
                { x: rightX, y: sideBottomY - spacing * 2, width: 120, height: 40, label: 'SETTINGS', action: 'settings' }
            ];

            // Spawn player on ground platform, centered
            const spawnX = 600 - 20; // Center X (600) - half player width (20)
            const spawnY = groundY - 40; // On top of ground platform
            menuPlayer = new Player(spawnX, spawnY, equippedCosmetics);

            // Center camera on player
            menuCameraX = spawnX + 20 - 600; // Player center - half canvas width
            menuCameraY = spawnY + 20 - 400; // Player center - half canvas height

            // Populate and show credit panel with player preview
            const skinData = cosmeticsCatalog.skins.find(s => s.id === equippedCosmetics.skin);
            const playerColor = skinData ? skinData.color : '#FF8C42';
            document.getElementById('creditPanel').innerHTML = `
                <div style="font-family: 'Inter', Arial, sans-serif; color: #fff; text-align: center; width: 100%;">
                    <div style="width: 100px; height: 100px; background: ${playerColor}; border: 4px solid #333; border-radius: 12px; margin: 0 auto 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); position: relative;">
                        ${equippedItem === 'credits' && userCredits > 0 ? `
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 25px; height: 25px; background: #FFD700; border: 2px solid #FFA500;"></div>
                        ` : ''}
                    </div>
                    <div style="font-weight: bold; font-size: 16px; margin-bottom: 20px;">${currentUsername}</div>
                    <div style="background: rgba(0,0,0,0.5); border-radius: 12px; padding: 15px; margin-bottom: 12px; border: 2px solid rgba(255, 215, 0, 0.3);">
                        <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; color: #4facfe;">Secure Credits</div>
                        <div style="font-size: 32px; font-weight: bold; color: #FFD700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);">${secureCredits.toLocaleString()}</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.5); border-radius: 12px; padding: 12px; border: 2px solid rgba(170, 170, 170, 0.2);">
                        <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; color: #4facfe;">On Hand</div>
                        <div style="font-size: 22px; font-weight: bold; color: #bbb; text-shadow: 0 0 8px rgba(187, 187, 187, 0.4);">${userCredits.toLocaleString()}</div>
                    </div>
                </div>
            `;
            document.getElementById('creditPanel').style.display = 'block';

            // Populate and show leaderboard panel
            loadMiniLeaderboard();
            document.getElementById('leaderboardPanel').style.display = 'block';

            // Game loop with delta time
            let lastMenuFrameTime = performance.now();
            function menuLoop(currentTime) {
                if (canvas.style.display === 'none') return;

                // Calculate delta time (normalize to 60fps baseline)
                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastMenuFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1; // Clamp deltaTime
                lastMenuFrameTime = currentTime;

                // Update player physics
                updateMenuPlayer(deltaTime);

                // Render
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw background 40x40px gridlines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;

                // Vertical lines
                const startX = Math.floor(menuCameraX / 40) * 40;
                for (let x = startX; x < menuCameraX + canvas.width; x += 40) {
                    const screenX = x - menuCameraX;
                    ctx.beginPath();
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, canvas.height);
                    ctx.stroke();
                }

                // Horizontal lines
                const startY = Math.floor(menuCameraY / 40) * 40;
                for (let y = startY; y < menuCameraY + canvas.height; y += 40) {
                    const screenY = y - menuCameraY;
                    ctx.beginPath();
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(canvas.width, screenY);
                    ctx.stroke();
                }

                // Draw platforms
                for (const platform of menuPlatforms) {
                    const screenX = platform.x - menuCameraX;
                    const screenY = platform.y - menuCameraY;

                    if (platform.label) {
                        // Gradient background for platform buttons
                        const gradient = ctx.createLinearGradient(screenX, screenY, screenX, screenY + platform.height);
                        gradient.addColorStop(0, 'rgba(79, 172, 254, 0.5)');
                        gradient.addColorStop(1, 'rgba(79, 172, 254, 0.2)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);

                        // Glowing border
                        ctx.shadowColor = '#4facfe';
                        ctx.shadowBlur = 15;
                        ctx.strokeStyle = '#4facfe';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(screenX, screenY, platform.width, platform.height);
                        ctx.shadowBlur = 0;

                        // Text with shadow
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = 'rgba(0,0,0,0.5)';
                        ctx.shadowBlur = 5;
                        ctx.fillText(platform.label, screenX + platform.width / 2, screenY + platform.height / 2 + 5);
                        ctx.shadowBlur = 0;
                    } else {
                        // Green platform
                        ctx.fillStyle = '#00AA00';
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);

                        // Draw 40x40 grid lines
                        ctx.strokeStyle = '#006600';
                        ctx.lineWidth = 1;
                        for (let gx = 0; gx < platform.width; gx += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX + gx, screenY);
                            ctx.lineTo(screenX + gx, screenY + platform.height);
                            ctx.stroke();
                        }
                        for (let gy = 0; gy < platform.height; gy += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY + gy);
                            ctx.lineTo(screenX + platform.width, screenY + gy);
                            ctx.stroke();
                        }
                    }
                }

                // Draw particles
                updateAndDrawParticles(ctx, menuCameraX, menuCameraY, deltaTime);

                // Draw player
                menuPlayer.updateTrail();
                menuPlayer.draw(ctx, menuCameraX, menuCameraY, false);

                requestAnimationFrame(menuLoop);
            }

            menuLoop();
        }

        function updateMenuPlayer(deltaTime = 1) {
            // Check current grounded state BEFORE applying physics
            // Check if player is standing on a platform (touching from above)
            let isGrounded = false;
            let standingOnPlatform = null;
            for (const platform of menuPlatforms) {
                // Check if player is directly above platform
                const onTop = menuPlayer.y + menuPlayer.height >= platform.y &&
                              menuPlayer.y + menuPlayer.height <= platform.y + 5;
                const horizontalOverlap = menuPlayer.x + menuPlayer.width > platform.x &&
                                         menuPlayer.x < platform.x + platform.width;

                if (onTop && horizontalOverlap) {
                    isGrounded = true;
                    standingOnPlatform = platform;
                    break;
                }
            }

            // Landing particles (gray)
            if (isGrounded && !menuPlayer.wasGrounded) {
                spawnParticles(menuPlayer.x + menuPlayer.width / 2, menuPlayer.y + menuPlayer.height, 8, 'rgb(200, 200, 200)', menuPlayer.currentSize);
            }
            menuPlayer.wasGrounded = isGrounded;

            // Check for platform interaction when standing on action platform
            if (standingOnPlatform && standingOnPlatform.action && standingOnPlatform.action !== 'none') {
                if (menuKeys[' ']) {
                    executePlatformAction(standingOnPlatform.action);
                }
            }

            // Apply gravity with fast fall
            if ((menuKeys['s'] || menuKeys['ArrowDown']) && !isGrounded) {
                menuPlayer.velocityY += GRAVITY * FAST_FALL_MULTIPLIER * deltaTime;
            } else {
                menuPlayer.velocityY += GRAVITY * deltaTime;
            }

            // Handle input
            if (menuKeys['a'] || menuKeys['ArrowLeft']) {
                menuPlayer.velocityX -= MOVE_SPEED * deltaTime;
            }
            if (menuKeys['d'] || menuKeys['ArrowRight']) {
                menuPlayer.velocityX += MOVE_SPEED * deltaTime;
            }

            // Speed-based movement particles (same as practice mode)
            const speed = Math.abs(menuPlayer.velocityX);
            if (speed > 0.5) {
                // More particles = faster movement
                const particleChance = Math.min(speed / 10, 0.8); // Max 80% chance
                if (Math.random() < particleChance) {
                    const particleCount = Math.floor(speed / 2);
                    spawnParticles(
                        menuPlayer.x + menuPlayer.width / 2 + (Math.random() - 0.5) * menuPlayer.width,
                        menuPlayer.y + menuPlayer.height,
                        Math.max(1, particleCount),
                        menuPlayer.getSkinColor()
                    );
                }
            }

            // Jump with variable height (W or Up Arrow only, NOT space)
            if ((menuKeys['w'] || menuKeys['ArrowUp']) && isGrounded) {
                // Scale jump power by size (menu player is always 40px, so sizeScale = 1)
                const sizeScale = menuPlayer.currentSize / 40;
                menuPlayer.velocityY = -JUMP_POWER * sizeScale;
                menuIsJumping = true;
                // Jump particles (white)
                spawnParticles(menuPlayer.x + menuPlayer.width / 2, menuPlayer.y + menuPlayer.height, 12, 'rgb(255, 255, 255)', menuPlayer.currentSize);
            }

            // Cut jump short if button released (variable jump height)
            if (menuIsJumping && !menuKeys['w'] && !menuKeys['ArrowUp']) {
                if (menuPlayer.velocityY < 0) {
                    menuPlayer.velocityY *= 0.5;
                }
                menuIsJumping = false;
            }

            // Reset jump state when grounded
            if (isGrounded && menuPlayer.velocityY >= 0) {
                menuIsJumping = false;
            }

            // Fast-fall particles (white) - spawn when holding down/S in air
            if ((menuKeys['s'] || menuKeys['ArrowDown']) && !isGrounded && menuPlayer.velocityY > 0) {
                // Spawn particles continuously during fast fall
                if (Math.random() < 0.3) { // 30% chance each frame for smooth particle trail
                    spawnParticles(menuPlayer.x + menuPlayer.width / 2, menuPlayer.y, 3, 'rgb(255, 255, 255)', menuPlayer.currentSize);
                }
            }

            // Apply friction using exponential decay
            if (isGrounded) {
                menuPlayer.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                menuPlayer.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Limit speed
            menuPlayer.velocityX = Math.max(-GROUND_MAX_SPEED, Math.min(GROUND_MAX_SPEED, menuPlayer.velocityX));

            // Update position HORIZONTALLY first, then check X collisions
            menuPlayer.x += menuPlayer.velocityX * deltaTime;

            // Check horizontal collisions
            for (const platform of menuPlatforms) {
                if (checkCollision(menuPlayer, platform)) {
                    if (menuPlayer.velocityX > 0) {
                        // Moving right, hit left side of platform
                        menuPlayer.x = platform.x - menuPlayer.width;
                    } else if (menuPlayer.velocityX < 0) {
                        // Moving left, hit right side of platform
                        menuPlayer.x = platform.x + platform.width;
                    }
                    menuPlayer.velocityX = 0;
                }
            }

            // Update position VERTICALLY, then check Y collisions
            menuPlayer.y += menuPlayer.velocityY * deltaTime;

            // Check vertical collisions
            for (const platform of menuPlatforms) {
                if (checkCollision(menuPlayer, platform)) {
                    if (menuPlayer.velocityY > 0) {
                        // Moving down, hit top of platform
                        menuPlayer.y = platform.y - menuPlayer.height;
                        menuPlayer.velocityY = 0;
                    } else if (menuPlayer.velocityY < 0) {
                        // Moving up, hit bottom of platform
                        menuPlayer.y = platform.y + platform.height;
                        menuPlayer.velocityY = 0;
                        menuIsJumping = false;
                    }
                }
            }

            // Keep player in bounds (but allow vertical movement)
            if (menuPlayer.x < 0) menuPlayer.x = 0;
            if (menuPlayer.x > 1200 - menuPlayer.width) menuPlayer.x = 1200 - menuPlayer.width;

            // Respawn if fall too far
            if (menuPlayer.y > 1500) {
                menuPlayer.x = 600 - 20;
                menuPlayer.y = 720 - 40;
                menuPlayer.velocityX = 0;
                menuPlayer.velocityY = 0;
            }

            // Keep camera fixed (do not follow player on home page)
            menuCameraX = 0;
            menuCameraY = 0;
        }

        function checkCollision(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

        function executePlatformAction(action) {
            document.getElementById('menuCanvas').style.display = 'none';
            document.getElementById('menuHUD').style.display = 'none';
            document.getElementById('creditPanel').style.display = 'none';
            document.getElementById('leaderboardPanel').style.display = 'none';

            switch(action) {
                case 'practice':
                    startPracticeMode();
                    break;
                case 'practiceLevels':
                    showPracticeLevels();
                    break;
                case 'createParty':
                    createParty();
                    break;
                case 'joinParty':
                    showScreen('joinPartyScreen');
                    break;
                case 'shop':
                    showShop();
                    break;
                case 'stats':
                    showStats();
                    break;
                case 'creator':
                    window.location.href = 'creator.html';
                    break;
                case 'base':
                    showBase();
                    break;
                case 'leaderboard':
                    showLeaderboard();
                    break;
                case 'settings':
                    showSettings();
                    break;
            }
        }

        // Level selection variables
        let levelSelectActive = false;
        let levelSelectPlayer = null;
        let levelSelectPlatforms = [];
        let levelSelectKeys = {};
        let availableLevels = [];
        let playerBestTimes = {};

        async function showPracticeLevels() {
            showScreen('practiceLevelsScreen');
            levelSelectActive = true;

            const canvas = document.getElementById('levelSelectCanvas');
            const ctx = canvas.getContext('2d');

            // Load all levels from Firebase
            const levelsSnapshot = await database.ref('levels').once('value');
            const levelsData = levelsSnapshot.val();

            availableLevels = [];
            if (levelsData) {
                Object.entries(levelsData).forEach(([levelId, levelInfo]) => {
                    availableLevels.push({
                        id: levelId,
                        name: levelInfo.name || levelId,
                        createdAt: levelInfo.createdAt || 0
                    });
                });
                // Sort by creation date (oldest first)
                availableLevels.sort((a, b) => a.createdAt - b.createdAt);
            }

            // Load player's best times
            const timesSnapshot = await database.ref('times_history/' + currentUser.uid).once('value');
            playerBestTimes = {};
            timesSnapshot.forEach((levelSnapshot) => {
                const levelId = levelSnapshot.key;
                let bestTime = Infinity;
                levelSnapshot.forEach((timeSnapshot) => {
                    const timeData = timeSnapshot.val();
                    if (timeData.time < bestTime) {
                        bestTime = timeData.time;
                    }
                });
                if (bestTime !== Infinity) {
                    playerBestTimes[levelId] = bestTime;
                }
            });

            // Create platformer-style layout like main menu
            // Portal platforms: 120px wide, 40px tall, stacked with 80px gap (120px total spacing)
            const spacing = 120; // 40px platform + 80px gap
            const portalWidth = 120;
            const portalHeight = 40;

            // Calculate how many levels per column (max 4)
            const levelsPerColumn = 4;
            const numColumns = Math.ceil(availableLevels.length / levelsPerColumn);

            // Center the columns
            const columnSpacing = 200; // Horizontal space between columns
            const totalWidth = numColumns * columnSpacing;
            const startX = (1200 - totalWidth) / 2 + 100; // Center and offset

            const groundY = 720;
            const bottomPortalY = groundY - 120; // 120px above ground

            levelSelectPlatforms = [
                // Boundary walls
                { x: -40, y: -40, width: 40, height: 880 }, // Left wall
                { x: 1200, y: -40, width: 40, height: 880 }, // Right wall
                { x: -40, y: -40, width: 1280, height: 40 }, // Ceiling
                { x: -40, y: groundY, width: 1280, height: 40 }, // Ground
            ];

            // Create portal platforms for each level
            availableLevels.forEach((level, index) => {
                const columnIndex = Math.floor(index / levelsPerColumn);
                const rowIndex = index % levelsPerColumn;

                const x = startX + columnIndex * columnSpacing;
                const y = bottomPortalY - (rowIndex * spacing);

                levelSelectPlatforms.push({
                    x: x,
                    y: y,
                    width: portalWidth,
                    height: portalHeight,
                    levelId: level.id,
                    levelName: level.name
                });
            });

            // Create player on ground
            const spawnX = 600 - 20; // Center
            const spawnY = groundY - 40; // On top of ground
            levelSelectPlayer = new Player(spawnX, spawnY, equippedCosmetics);

            // Start render loop
            let lastFrameTime = performance.now();
            function levelSelectLoop(currentTime) {
                if (!levelSelectActive) return;

                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                lastFrameTime = currentTime;

                updateLevelSelect(deltaTime);
                renderLevelSelect(ctx);

                requestAnimationFrame(levelSelectLoop);
            }
            levelSelectLoop();
        }

        function updateLevelSelect(deltaTime) {
            if (!levelSelectPlayer) return;

            // Apply gravity
            levelSelectPlayer.velocityY += GRAVITY * deltaTime;

            // Apply friction (use previous frame's grounded state)
            if (levelSelectPlayer.wasGrounded) {
                levelSelectPlayer.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                levelSelectPlayer.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Cap vertical velocity to prevent tunneling
            const maxFallSpeed = 8;
            levelSelectPlayer.velocityY = Math.min(levelSelectPlayer.velocityY, maxFallSpeed);

            // Limit horizontal speed
            const maxSpeed = GROUND_MAX_SPEED;
            levelSelectPlayer.velocityX = Math.max(-maxSpeed, Math.min(maxSpeed, levelSelectPlayer.velocityX));

            // Handle movement
            if (levelSelectKeys['a'] || levelSelectKeys['ArrowLeft']) {
                levelSelectPlayer.velocityX -= MOVE_SPEED * deltaTime;
            }
            if (levelSelectKeys['d'] || levelSelectKeys['ArrowRight']) {
                levelSelectPlayer.velocityX += MOVE_SPEED * deltaTime;
            }

            // Update position
            levelSelectPlayer.x += levelSelectPlayer.velocityX * deltaTime;
            levelSelectPlayer.y += levelSelectPlayer.velocityY * deltaTime;

            // Collision detection - matches main menu and level creator
            let isGrounded = false;
            let standingOnPlatform = null;

            for (const platform of levelSelectPlatforms) {
                if (levelSelectPlayer.x + levelSelectPlayer.width > platform.x &&
                    levelSelectPlayer.x < platform.x + platform.width &&
                    levelSelectPlayer.y + levelSelectPlayer.height > platform.y &&
                    levelSelectPlayer.y < platform.y + platform.height) {

                    const overlapLeft = (levelSelectPlayer.x + levelSelectPlayer.width) - platform.x;
                    const overlapRight = (platform.x + platform.width) - levelSelectPlayer.x;
                    const overlapTop = (levelSelectPlayer.y + levelSelectPlayer.height) - platform.y;
                    const overlapBottom = (platform.y + platform.height) - levelSelectPlayer.y;

                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    // Floor collision (landing on top)
                    if ((minOverlap === overlapTop && levelSelectPlayer.velocityY >= 0) ||
                        (levelSelectPlayer.velocityY > 0 && overlapTop < overlapBottom &&
                         overlapTop < overlapLeft * 0.5 && overlapTop < overlapRight * 0.5)) {
                        levelSelectPlayer.y = platform.y - levelSelectPlayer.height;
                        levelSelectPlayer.velocityY = 0;
                        isGrounded = true;
                        standingOnPlatform = platform;
                    }
                    // Ceiling collision (hitting from below)
                    else if (minOverlap === overlapBottom && levelSelectPlayer.velocityY < 0) {
                        levelSelectPlayer.y = platform.y + platform.height;
                        levelSelectPlayer.velocityY = 0;
                    }
                    // Left wall collision
                    else if (minOverlap === overlapLeft) {
                        levelSelectPlayer.x = platform.x - levelSelectPlayer.width;
                        levelSelectPlayer.velocityX = 0;
                    }
                    // Right wall collision
                    else if (minOverlap === overlapRight) {
                        levelSelectPlayer.x = platform.x + platform.width;
                        levelSelectPlayer.velocityX = 0;
                    }
                }
            }

            levelSelectPlayer.wasGrounded = isGrounded;

            // Check if player pressed space on a level platform
            if (standingOnPlatform && standingOnPlatform.levelId && (levelSelectKeys[' '] || levelSelectKeys['Space'])) {
                levelSelectActive = false; // Stop level selection loop
                playLevel(standingOnPlatform.levelId);
                levelSelectKeys[' '] = false;
                levelSelectKeys['Space'] = false;
            }

            // Jump with W or Up (no space)
            if ((levelSelectKeys['w'] || levelSelectKeys['ArrowUp']) && isGrounded) {
                levelSelectPlayer.velocityY = -JUMP_POWER;
            }
        }

        function renderLevelSelect(ctx) {
            // Clear with sky blue background
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, 1200, 800);

            // Draw background gridlines (40x40px)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;

            // Vertical lines
            for (let x = 0; x < 1200; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 800);
                ctx.stroke();
            }

            // Horizontal lines
            for (let y = 0; y < 800; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(1200, y);
                ctx.stroke();
            }

            // Draw platforms
            for (const platform of levelSelectPlatforms) {
                if (platform.levelId) {
                    // Level portal platform - green with blue outline
                    ctx.fillStyle = '#00AA00';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                    // Blue portal outline
                    ctx.strokeStyle = '#0066FF';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);

                    // Level name (white text, smaller font)
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(platform.levelName, platform.x + platform.width / 2, platform.y + 20);

                    // Best time indicator
                    const bestTime = playerBestTimes[platform.levelId];
                    if (bestTime) {
                        ctx.font = '8px Arial';
                        ctx.fillStyle = '#FFD700';
                        ctx.fillText(`${formatTime(bestTime)}`, platform.x + platform.width / 2, platform.y + 32);
                    } else {
                        ctx.font = '8px Arial';
                        ctx.fillStyle = '#CCCCCC';
                        ctx.fillText('No time', platform.x + platform.width / 2, platform.y + 32);
                    }
                } else {
                    // Boundary platforms - dark green
                    ctx.fillStyle = '#00AA00';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                }
            }

            // Draw player
            levelSelectPlayer.draw(ctx, 0, 0);

            // Draw instructions at top
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Jump to a portal and press SPACE to play!', 600, 30);
            ctx.font = '12px Arial';
            ctx.fillText('WASD or Arrow Keys to move | ESC to go back', 600, 50);
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const milliseconds = ms % 1000;
            return `${minutes}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        }

        async function playLevel(levelId) {
            try {
                // Load level from Firebase
                const levelSnapshot = await database.ref('levels/' + levelId).once('value');
                const levelInfo = levelSnapshot.val();

                if (!levelInfo || !levelInfo.data) {
                    alert('Error: Level data not found!');
                    return;
                }

                const levelData = levelInfo.data;

                // Hide practice levels screen
                document.getElementById('practiceLevelsScreen').classList.remove('active');

                // Show practice canvas
                const canvas = document.getElementById('practiceCanvas');
                canvas.style.display = 'block';
                document.getElementById('hud').style.display = 'block';
                document.getElementById('practiceBackBtn').style.display = 'block';

                // Initialize practice mode with level data
                practiceMode.active = true;
                practiceMode.isLevelMode = true; // Flag to indicate we're playing a level, not infinite mode
                practiceMode.levelData = levelData;
                practiceMode.levelId = levelId;
                practiceMode.levelName = levelInfo.name;
                practiceMode.startTime = null; // Will be set when player moves
                practiceMode.finishTime = null;
                practiceMode.finished = false;

                // Find the leftmost platform to spawn player
                let startX = 100;
                let startY = -50;
                if (levelData.platforms && levelData.platforms.length > 0) {
                    const leftmostPlatform = levelData.platforms.reduce((prev, curr) =>
                        curr.x < prev.x ? curr : prev
                    );
                    startX = leftmostPlatform.x + 40;  // Spawn 40px from left edge
                    startY = leftmostPlatform.y - 40;   // Spawn at same Y height (player is 40px tall)
                }
                practiceMode.player = new Player(startX, startY, equippedCosmetics);

                // Load platforms from level
                practiceMode.platforms = levelData.platforms || [];

                // Load other level elements
                practiceMode.hazards = levelData.hazards || [];
                practiceMode.growers = levelData.growers || [];
                practiceMode.shrinkers = levelData.shrinkers || [];
                practiceMode.defaultSizeBlocks = levelData.defaultSizeBlocks || [];

                // Reset other properties
                practiceMode.credits = [];
                practiceMode.creditsCollected = 0;
                practiceMode.cameraX = 0;
                practiceMode.cameraY = 0;

                // Start the practice loop
                let lastPracticeFrameTime = performance.now();
                function practiceLoop(currentTime) {
                    if (!practiceMode.active) return;

                    // Calculate delta time
                    if (!currentTime) currentTime = performance.now();
                    let deltaTime = (currentTime - lastPracticeFrameTime) / 16.67;
                    if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                    lastPracticeFrameTime = currentTime;

                    // Start timer when player first moves
                    if (!practiceMode.startTime && !practiceMode.finished) {
                        const isMoving = practiceMode.keys['a'] || practiceMode.keys['d'] ||
                                       practiceMode.keys['w'] || practiceMode.keys['s'] ||
                                       practiceMode.keys['ArrowLeft'] || practiceMode.keys['ArrowRight'] ||
                                       practiceMode.keys['ArrowUp'] || practiceMode.keys['ArrowDown'];
                        if (isMoving) {
                            practiceMode.startTime = Date.now();
                        }
                    }

                    // Update player
                    updatePracticePlayer(deltaTime);

                    // Check finish zone
                    if (levelData.finish && !practiceMode.finished) {
                        const finish = levelData.finish;
                        if (practiceMode.player.x + practiceMode.player.width > finish.x &&
                            practiceMode.player.x < finish.x + finish.width &&
                            practiceMode.player.y + practiceMode.player.height > finish.y &&
                            practiceMode.player.y < finish.y + finish.height) {
                            practiceMode.finished = true;
                            practiceMode.finishTime = Date.now() - practiceMode.startTime;

                            // Save time to Firebase
                            await database.ref('times_history/' + currentUser.uid + '/' + levelId).push({
                                time: practiceMode.finishTime,
                                timestamp: firebase.database.ServerValue.TIMESTAMP
                            });
                        }
                    }

                    // Update HUD with timer
                    let timerText = '';
                    if (practiceMode.finished) {
                        const totalMs = practiceMode.finishTime;
                        const minutes = Math.floor(totalMs / 60000);
                        const seconds = Math.floor((totalMs % 60000) / 1000);
                        const ms = totalMs % 1000;
                        timerText = `<div style="font-size: 20px; color: #00FF00; margin-top: 5px;">FINISHED: ${minutes}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}</div>`;
                    } else if (practiceMode.startTime) {
                        const elapsed = Date.now() - practiceMode.startTime;
                        const minutes = Math.floor(elapsed / 60000);
                        const seconds = Math.floor((elapsed % 60000) / 1000);
                        const ms = elapsed % 1000;
                        timerText = `<div style="font-size: 20px; color: #FFD700; margin-top: 5px;">Time: ${minutes}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}</div>`;
                    } else {
                        timerText = `<div style="font-size: 16px; color: #aaa; margin-top: 5px;">Move to start timer!</div>`;
                    }

                    document.getElementById('hud').innerHTML = `
                        <div style="font-size: 24px; font-weight: bold;">${levelInfo.name}</div>
                        <div style="font-size: 14px; margin-top: 3px; color: #aaa;">By ${levelInfo.creator}</div>
                        ${timerText}
                    `;

                    // Render
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Camera follows player
                    practiceMode.cameraX = practiceMode.player.x - canvas.width / 2 + practiceMode.player.width / 2;
                    practiceMode.cameraY = practiceMode.player.y - canvas.height / 2 + practiceMode.player.height / 2;

                    // Draw platforms (exact colors from level creator)
                    ctx.fillStyle = '#4CAF50';
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    for (const platform of practiceMode.platforms) {
                        const screenX = platform.x - practiceMode.cameraX;
                        const screenY = platform.y - practiceMode.cameraY;
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);
                        ctx.strokeRect(screenX, screenY, platform.width, platform.height);
                    }

                    // Draw hazards (exact colors from level creator)
                    ctx.fillStyle = '#FF3333';
                    ctx.strokeStyle = '#333';
                    for (const hazard of practiceMode.hazards) {
                        const screenX = hazard.x - practiceMode.cameraX;
                        const screenY = hazard.y - practiceMode.cameraY;
                        ctx.fillRect(screenX, screenY, hazard.width, hazard.height);
                        ctx.strokeRect(screenX, screenY, hazard.width, hazard.height);
                    }

                    // Draw growers (exact colors from level creator)
                    ctx.fillStyle = '#00FF88';
                    ctx.strokeStyle = '#333';
                    for (const grower of practiceMode.growers) {
                        const screenX = grower.x - practiceMode.cameraX;
                        const screenY = grower.y - practiceMode.cameraY;
                        ctx.fillRect(screenX, screenY, grower.width, grower.height);
                        ctx.strokeRect(screenX, screenY, grower.width, grower.height);
                    }

                    // Draw shrinkers (exact colors from level creator)
                    ctx.fillStyle = '#BB66FF';
                    ctx.strokeStyle = '#333';
                    for (const shrinker of practiceMode.shrinkers) {
                        const screenX = shrinker.x - practiceMode.cameraX;
                        const screenY = shrinker.y - practiceMode.cameraY;
                        ctx.fillRect(screenX, screenY, shrinker.width, shrinker.height);
                        ctx.strokeRect(screenX, screenY, shrinker.width, shrinker.height);
                    }

                    // Draw default size blocks (exact colors from level creator)
                    ctx.fillStyle = '#FFB84D';
                    ctx.strokeStyle = '#333';
                    for (const block of practiceMode.defaultSizeBlocks) {
                        const screenX = block.x - practiceMode.cameraX;
                        const screenY = block.y - practiceMode.cameraY;
                        ctx.fillRect(screenX, screenY, block.width, block.height);
                        ctx.strokeRect(screenX, screenY, block.width, block.height);
                    }

                    // Draw finish zone
                    if (levelData.finish) {
                        const finish = levelData.finish;
                        const finishScreenX = finish.x - practiceMode.cameraX;
                        const finishScreenY = finish.y - practiceMode.cameraY;
                        ctx.fillStyle = practiceMode.finished ? '#00FF00' : '#FFD700';
                        ctx.fillRect(finishScreenX, finishScreenY, finish.width, finish.height);
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(finishScreenX, finishScreenY, finish.width, finish.height);

                        // Draw "FINISH" text
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('FINISH', finishScreenX + finish.width / 2, finishScreenY + finish.height / 2 + 6);
                    }

                    // Draw particles
                    updateAndDrawParticles(ctx, practiceMode.cameraX, practiceMode.cameraY, deltaTime);

                    // Draw player
                    const screenX = practiceMode.player.x - practiceMode.cameraX;
                    const screenY = practiceMode.player.y - practiceMode.cameraY;

                    // Draw player with cosmetics
                    ctx.fillStyle = practiceMode.player.getSkinColor();
                    ctx.fillRect(screenX, screenY, practiceMode.player.width, practiceMode.player.height);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, screenY, practiceMode.player.width, practiceMode.player.height);

                    // Draw equipped item (credits display) even in practice mode
                    if (equippedItem === 'credits' && userCredits > 0) {
                        const creditSize = practiceMode.player.width / 4;
                        const creditX = screenX + (practiceMode.player.width - creditSize) / 2;
                        const creditY = screenY + (practiceMode.player.height - creditSize) / 2;
                        ctx.fillStyle = '#FFD700';
                        ctx.fillRect(creditX, creditY, creditSize, creditSize);
                        ctx.strokeStyle = '#FFA500';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(creditX, creditY, creditSize, creditSize);
                    }

                    requestAnimationFrame(practiceLoop);
                }

                practiceLoop();

            } catch (error) {
                console.error('Error loading level:', error);
                alert('Error loading level: ' + error.message);
            }
        }

        // Admin function to add levels to Firebase
        async function addLevelToDatabase(levelName, creatorName, levelData) {
            try {
                const levelId = 'level_' + Date.now();
                await database.ref('levels/' + levelId).set({
                    name: levelName,
                    creator: creatorName,
                    data: levelData,
                    createdAt: firebase.database.ServerValue.TIMESTAMP
                });
                console.log('Level added successfully with ID:', levelId);
                return levelId;
            } catch (error) {
                console.error('Error adding level:', error);
                throw error;
            }
        }

        // Add the "Vertical Challenge" level on first load
        async function initializeDefaultLevels() {
            const levelsSnapshot = await database.ref('levels').once('value');
            const levels = levelsSnapshot.val();

            // Only add default level if no levels exist
            if (!levels) {
                const verticalChallengeData = {
                    "platforms": [
                        {"x": 0, "y": 0, "width": 240, "height": 40},
                        {"x": 280, "y": -40, "width": 200, "height": 40},
                        {"x": 520, "y": -80, "width": 160, "height": 40},
                        {"x": 720, "y": -120, "width": 120, "height": 40},
                        {"x": 880, "y": -160, "width": 80, "height": 40},
                        {"x": 1000, "y": -200, "width": 40, "height": 40},
                        {"x": 1040, "y": -320, "width": 40, "height": 80},
                        {"x": 1080, "y": -480, "width": 40, "height": 120},
                        {"x": 1120, "y": -680, "width": 40, "height": 160},
                        {"x": 1160, "y": -920, "width": 40, "height": 200},
                        {"x": 1200, "y": -1200, "width": 40, "height": 240},
                        {"x": -320, "y": 40, "width": 280, "height": 40},
                        {"x": -680, "y": 80, "width": 320, "height": 40},
                        {"x": -1120, "y": 120, "width": 400, "height": 40},
                        {"x": 1240, "y": -1520, "width": 40, "height": 280},
                        {"x": 1280, "y": -1880, "width": 40, "height": 320},
                        {"x": 1320, "y": -2280, "width": 40, "height": 360},
                        {"x": 1360, "y": -2720, "width": 40, "height": 400},
                        {"x": 1030, "y": -250, "width": 10, "height": 10},
                        {"x": 1070, "y": -400, "width": 10, "height": 10},
                        {"x": 1110, "y": -560, "width": 10, "height": 10},
                        {"x": 1110, "y": -640, "width": 10, "height": 10},
                        {"x": 1150, "y": -760, "width": 10, "height": 10},
                        {"x": 1150, "y": -840, "width": 10, "height": 10},
                        {"x": 1180, "y": -1080, "width": 20, "height": 20},
                        {"x": 1220, "y": -1360, "width": 20, "height": 20},
                        {"x": 1260, "y": -1640, "width": 20, "height": 20},
                        {"x": 1260, "y": -1760, "width": 20, "height": 20},
                        {"x": 1300, "y": -2040, "width": 20, "height": 20},
                        {"x": 1300, "y": -2180, "width": 20, "height": 20},
                        {"x": 1340, "y": -2400, "width": 20, "height": 20},
                        {"x": 1340, "y": -2520, "width": 20, "height": 20},
                        {"x": 1340, "y": -2640, "width": 20, "height": 20},
                        {"x": 1400, "y": -3200, "width": 40, "height": 440},
                        {"x": 1440, "y": -3680, "width": 40, "height": 440},
                        {"x": 1360, "y": -3040, "width": 40, "height": 40},
                        {"x": 1320, "y": -3960, "width": 280, "height": 40},
                        {"x": -1600, "y": 160, "width": 440, "height": 40},
                        {"x": -2120, "y": 200, "width": 480, "height": 40},
                        {"x": 1400, "y": -3480, "width": 40, "height": 40},
                        {"x": 1400, "y": -3720, "width": 120, "height": 40}
                    ],
                    "hazards": [],
                    "growers": [
                        {"x": 1360, "y": -2760, "width": 40, "height": 40},
                        {"x": -2120, "y": 120, "width": 40, "height": 80},
                        {"x": -2080, "y": 120, "width": 40, "height": 40},
                        {"x": -2040, "y": 120, "width": 40, "height": 80}
                    ],
                    "shrinkers": [
                        {"x": 280, "y": -280, "width": 20, "height": 240}
                    ],
                    "defaultSizeBlocks": [
                        {"x": 1160, "y": -930, "width": 40, "height": 10},
                        {"x": 1560, "y": -4160, "width": 40, "height": 200},
                        {"x": 1360, "y": -4160, "width": 200, "height": 40},
                        {"x": 1320, "y": -4160, "width": 40, "height": 200},
                        {"x": -680, "y": -280, "width": 20, "height": 360}
                    ],
                    "backgroundBlocks": [],
                    "foregroundBlocks": [],
                    "triggers": [],
                    "start": {"x": -2080, "y": 160, "width": 40, "height": 40},
                    "finish": {"x": 1400, "y": -4080, "width": 120, "height": 120},
                    "physics": {
                        "gravity": 0.042,
                        "moveSpeed": 0.28,
                        "jumpPower": 3.7,
                        "maxSpeed": 3.5,
                        "friction": 0.94,
                        "airRes": 0.88,
                        "fastFallMultiplier": 2
                    }
                };

                await addLevelToDatabase('Vertical Challenge', 'System', verticalChallengeData);
                console.log('Default level "Vertical Challenge" added to database');
            }
        }

        // Practice mode (infinite runner with credit earning)
        let practiceMode = {
            active: false,
            player: null,
            platforms: [],
            credits: [], // Physical credit coins to collect
            platformsPassed: 0,
            creditsCollected: 0,
            lastPlatformX: 0,
            cameraX: 0,
            cameraY: 0,
            keys: {}
        };

        function startPracticeMode() {
            try {
                console.log('Starting practice mode...');

                const canvas = document.getElementById('practiceCanvas');
                const ctx = canvas.getContext('2d');

                if (!canvas || !ctx) {
                    console.error('Canvas or context not found!');
                    alert('Error: Practice canvas not found. Please refresh the page.');
                    return;
                }

                canvas.style.display = 'block';
                document.getElementById('hud').style.display = 'block';
                document.getElementById('practiceBackBtn').style.display = 'block';

                practiceMode.active = true;
                practiceMode.player = new Player(100, 300, equippedCosmetics);
                practiceMode.platforms = [];
                practiceMode.credits = [];
                practiceMode.platformsPassed = 0;
                practiceMode.creditsCollected = 0;
                practiceMode.lastPlatformX = -200; // Start from negative to generate from beginning

                console.log('Player created:', practiceMode.player);

                // Generate initial platforms
                for (let i = 0; i < 20; i++) {
                    generatePracticePlatform();
                }

                console.log('Generated platforms:', practiceMode.platforms.length);
                console.log('Generated credits:', practiceMode.credits.length);

            let lastPracticeFrameTime = performance.now();
            function practiceLoop(currentTime) {
                if (!practiceMode.active) return;

                // Calculate delta time
                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastPracticeFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                lastPracticeFrameTime = currentTime;

                // Update
                updatePracticePlayer(deltaTime);

                // Generate new platforms
                while (practiceMode.lastPlatformX < practiceMode.cameraX + 1500) {
                    generatePracticePlatform();
                }

                // Remove old platforms and credits
                practiceMode.platforms = practiceMode.platforms.filter(p => p.x > practiceMode.cameraX - 200);
                practiceMode.credits = practiceMode.credits.filter(c => c.x > practiceMode.cameraX - 200);

                // Update HUD
                document.getElementById('hud').innerHTML = `
                    <div style="font-size: 24px; font-weight: bold;">EARN MODE</div>
                    <div style="font-size: 18px; margin-top: 5px;">Collected This Run: ${practiceMode.creditsCollected}</div>
                    <div style="font-size: 16px; margin-top: 3px;">Credits: ${secureCredits} <span style="font-size: 12px; color: #aaa;">(${userCredits} on hand)</span></div>
                    <div style="font-size: 14px; margin-top: 3px; color: #aaa;">Active Credits: ${practiceMode.credits.filter(c => !c.collected).length}</div>
                    <div style="font-size: 16px; color: #FFD700; margin-top: 5px;">Collect coins!</div>
                `;

                // Render
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw death zone at bottom (red warning blocks)
                ctx.fillStyle = '#FF0000';
                const deathZoneY = 900 - practiceMode.cameraY;
                ctx.fillRect(0, deathZoneY, canvas.width, canvas.height - deathZoneY);

                // Draw skull icons on death zone
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 30px Arial';
                for (let x = 0; x < canvas.width; x += 60) {
                    ctx.fillText('', x, deathZoneY + 40);
                }

                // Draw platforms
                for (const platform of practiceMode.platforms) {
                    const screenX = platform.x - practiceMode.cameraX;
                    const screenY = platform.y - practiceMode.cameraY;

                    if (platform.isHazard) {
                        ctx.fillStyle = '#FF0000';
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);
                    } else {
                        // Green platform
                        ctx.fillStyle = '#00AA00';
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);

                        // Draw 40x40 grid lines
                        ctx.strokeStyle = '#006600';
                        ctx.lineWidth = 1;
                        for (let gx = 0; gx < platform.width; gx += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX + gx, screenY);
                            ctx.lineTo(screenX + gx, screenY + platform.height);
                            ctx.stroke();
                        }
                        for (let gy = 0; gy < platform.height; gy += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY + gy);
                            ctx.lineTo(screenX + platform.width, screenY + gy);
                            ctx.stroke();
                        }
                    }
                }

                // Draw credit coins
                for (const credit of practiceMode.credits) {
                    if (!credit.collected) {
                        const screenX = credit.x - practiceMode.cameraX;
                        const screenY = credit.y - practiceMode.cameraY;

                        // Draw golden coin with glow
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 15;

                        // Outer golden circle
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(screenX + 15, screenY + 15, 15, 0, Math.PI * 2);
                        ctx.fill();

                        // Inner darker circle for depth
                        ctx.fillStyle = '#FFA500';
                        ctx.beginPath();
                        ctx.arc(screenX + 15, screenY + 15, 10, 0, Math.PI * 2);
                        ctx.fill();

                        // Dollar sign
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('$', screenX + 15, screenY + 20);
                    }
                }

                // Update and draw particles
                particles = particles.filter(p => p.life > 0);
                for (const particle of particles) {
                    particle.update(deltaTime);
                    particle.draw(ctx, practiceMode.cameraX, practiceMode.cameraY);
                }

                // Draw player with squash/stretch
                practiceMode.player.updateTrail();
                practiceMode.player.draw(ctx, practiceMode.cameraX, practiceMode.cameraY, false);

                requestAnimationFrame(practiceLoop);
            }

            console.log('Starting practice loop...');
            practiceLoop();

            } catch (error) {
                console.error('Error starting practice mode:', error);
                alert('Error starting earn mode: ' + error.message);
            }
        }

        function generatePracticePlatform() {
            const lastPlatform = practiceMode.platforms[practiceMode.platforms.length - 1];
            const baseX = lastPlatform ? lastPlatform.x + lastPlatform.width + Math.random() * 150 + 50 : 0;
            const baseY = lastPlatform ? lastPlatform.y + (Math.random() - 0.5) * 100 : 500;

            // Width must be multiples of 40 (40x40 blocks only)
            const numBlocks = Math.floor(Math.random() * 4) + 2; // 2-5 blocks wide
            const width = numBlocks * 40;
            const platformY = Math.max(200, Math.min(600, Math.round(baseY / 40) * 40)); // Snap Y to 40px grid

            practiceMode.platforms.push({
                x: baseX,
                y: platformY,
                width: width,
                height: 40,
                isHazard: false
            });

            // Spawn credit coin above platform (70% chance per platform)
            if (Math.random() < 0.7) {
                practiceMode.credits.push({
                    x: baseX + width / 2 - 15, // Center above platform
                    y: platformY - 60, // Float above platform
                    width: 30,
                    height: 30,
                    collected: false
                });
            }

            practiceMode.lastPlatformX = baseX;
        }

        function updatePracticePlayer(deltaTime = 1) {
            const player = practiceMode.player;

            // Scale factors based on player size (from level creator) - freeze movement during transition
            if (!player.sizeTransitioning) {
                const sizeScale = player.currentSize / 40;

                // Handle input - scaled by size like level creator
                const scaledMoveSpeed = MOVE_SPEED * sizeScale;
                const wasMovingLeft = player.velocityX < -0.5;
                const wasMovingRight = player.velocityX > 0.5;

                if (practiceMode.keys['a'] || practiceMode.keys['ArrowLeft']) {
                    player.velocityX -= scaledMoveSpeed * deltaTime;
                    // White particles when starting left movement or changing direction
                    if (!wasMovingLeft && Math.random() < 0.3) {
                        spawnParticles(player.x + player.width / 2, player.y + player.height / 2, 2, 'rgb(255, 255, 255)', player.currentSize);
                    }
                }
                if (practiceMode.keys['d'] || practiceMode.keys['ArrowRight']) {
                    player.velocityX += scaledMoveSpeed * deltaTime;
                    // White particles when starting right movement or changing direction
                    if (!wasMovingRight && Math.random() < 0.3) {
                        spawnParticles(player.x + player.width / 2, player.y + player.height / 2, 2, 'rgb(255, 255, 255)', player.currentSize);
                    }
                }
            }

            // Orange speed-based movement particles (more = faster)
            const speed = Math.abs(player.velocityX);
            if (speed > 0.5) {
                const particleChance = Math.min(speed / 10, 0.8); // Max 80% chance
                if (Math.random() < particleChance) {
                    const particleCount = Math.floor(speed / 2);
                    spawnParticles(
                        player.x + player.width / 2 + (Math.random() - 0.5) * player.width,
                        player.y + player.height,
                        Math.max(1, particleCount),
                        'rgb(255, 140, 66)', // Orange
                        player.currentSize
                    );
                }
            }

            // JUMP BUFFER: Remember jump input (W or Up only, NOT space)
            if (practiceMode.keys['w'] || practiceMode.keys['ArrowUp']) {
                player.jumpBufferTimer = JUMP_BUFFER_TIME;
            } else {
                player.jumpBufferTimer = Math.max(0, player.jumpBufferTimer - deltaTime);
            }

            // Jump with coyote time and jump buffering
            if (player.jumpBufferTimer > 0 && player.coyoteTimer > 0 && !practiceIsJumping) {
                // Scale jump power by size so all sizes can jump 4x their height + 1px
                const sizeScale = player.currentSize / 40;
                player.velocityY = -JUMP_POWER * sizeScale;
                practiceIsJumping = true;
                player.coyoteTimer = 0;
                player.jumpBufferTimer = 0;
                // White jump particles
                spawnParticles(player.x + player.width / 2, player.y + player.height, 12, 'rgb(255, 255, 255)', player.currentSize);
            }

            // Cut jump short if button released (variable jump height)
            if (practiceIsJumping && !practiceMode.keys['w'] && !practiceMode.keys['ArrowUp']) {
                if (player.velocityY < 0) {
                    player.velocityY *= 0.5;
                }
                practiceIsJumping = false;
            }

            // Apply gravity scaled by size (from level creator)
            const sizeScale = player.currentSize / 40;
            if ((practiceMode.keys['s'] || practiceMode.keys['ArrowDown']) && !player.wasGrounded && player.velocityY > 0) {
                player.velocityY += GRAVITY * sizeScale * FAST_FALL_MULTIPLIER * deltaTime;
                // White fast-fall particles - only when actually falling down
                if (Math.random() < 0.3) {
                    spawnParticles(player.x + player.width / 2, player.y, 3, 'rgb(255, 255, 255)', player.currentSize);
                }
            } else {
                player.velocityY += GRAVITY * sizeScale * deltaTime;
            }

            // Apply friction using exponential decay (use previous frame's grounded state)
            if (player.wasGrounded) {
                player.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                player.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Cap vertical velocity to prevent tunneling
            const maxFallSpeed = 8 * sizeScale;
            player.velocityY = Math.min(player.velocityY, maxFallSpeed);

            // Limit horizontal speed
            const maxSpeed = GROUND_MAX_SPEED;
            player.velocityX = Math.max(-maxSpeed, Math.min(maxSpeed, player.velocityX));

            // Update position
            player.x += player.velocityX * deltaTime;
            player.y += player.velocityY * deltaTime;

            // Collision detection - matches level creator
            let isGrounded = false;
            for (const platform of practiceMode.platforms) {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {

                    const overlapLeft = (player.x + player.width) - platform.x;
                    const overlapRight = (platform.x + platform.width) - player.x;
                    const overlapTop = (player.y + player.height) - platform.y;
                    const overlapBottom = (platform.y + platform.height) - player.y;

                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    // Floor collision (landing on top)
                    if ((minOverlap === overlapTop && player.velocityY >= 0) ||
                        (player.velocityY > 0 && overlapTop < overlapBottom &&
                         overlapTop < overlapLeft * 0.5 && overlapTop < overlapRight * 0.5)) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        isGrounded = true;
                    }
                    // Ceiling collision (hitting from below)
                    else if (minOverlap === overlapBottom && player.velocityY < 0) {
                        player.y = platform.y + platform.height;
                        player.velocityY = 0;
                    }
                    // Left wall collision
                    else if (minOverlap === overlapLeft) {
                        player.x = platform.x - player.width;
                        player.velocityX = 0;
                    }
                    // Right wall collision
                    else if (minOverlap === overlapRight) {
                        player.x = platform.x + platform.width;
                        player.velocityX = 0;
                    }
                }
            }

            // COYOTE TIME: Allow jumping shortly after leaving platform
            if (isGrounded) {
                player.coyoteTimer = COYOTE_TIME;
                // Landing particles
                if (!player.wasGrounded) {
                    spawnParticles(player.x + player.width / 2, player.y + player.height, 8, 'rgb(200, 200, 200)', player.currentSize);
                }
            } else {
                player.coyoteTimer = Math.max(0, player.coyoteTimer - deltaTime);
            }
            player.wasGrounded = isGrounded;

            // Reset jump state when grounded
            if (isGrounded && player.velocityY >= 0) {
                practiceIsJumping = false;
            }

            // Check credit collection
            for (const credit of practiceMode.credits) {
                if (!credit.collected && checkCollision(player, credit)) {
                    credit.collected = true;
                    practiceMode.creditsCollected++;
                    updateCredits(1);
                }
            }

            // Check grower collision (double size) - smooth transition like level creator
            if (practiceMode.growers) {
                for (const grower of practiceMode.growers) {
                    if (checkCollision(player, grower)) {
                        if (player.currentSize !== 80 && !player.sizeTransitioning) {
                            player.sizeTransitioning = true;
                            player.targetSize = 80;
                            player.sizeTransitionProgress = 0;
                        }
                    }
                }
            }

            // Check shrinker collision (half size) - smooth transition like level creator
            if (practiceMode.shrinkers) {
                for (const shrinker of practiceMode.shrinkers) {
                    if (checkCollision(player, shrinker)) {
                        if (player.currentSize !== 20 && !player.sizeTransitioning) {
                            player.sizeTransitioning = true;
                            player.targetSize = 20;
                            player.sizeTransitionProgress = 0;
                        }
                    }
                }
            }

            // Check default size block collision (reset to normal) - smooth transition like level creator
            if (practiceMode.defaultSizeBlocks) {
                for (const block of practiceMode.defaultSizeBlocks) {
                    if (checkCollision(player, block)) {
                        if (player.currentSize !== 40 && !player.sizeTransitioning) {
                            player.sizeTransitioning = true;
                            player.targetSize = 40;
                            player.sizeTransitionProgress = 0;
                        }
                    }
                }
            }

            // Update size transition (from level creator)
            if (player.sizeTransitioning) {
                player.sizeTransitionProgress += deltaTime * 0.1;  // Transition speed

                if (player.sizeTransitionProgress >= 1) {
                    // Transition complete
                    player.sizeTransitioning = false;
                    player.currentSize = player.targetSize;
                    player.width = player.targetSize;
                    player.height = player.targetSize;
                } else {
                    // Interpolate size from center
                    const startSize = player.currentSize;
                    const t = player.sizeTransitionProgress;
                    const newSize = startSize + (player.targetSize - startSize) * t;

                    // Calculate center point before resize
                    const centerX = player.x + player.width / 2;
                    const centerY = player.y + player.height / 2;

                    // Update size
                    player.width = newSize;
                    player.height = newSize;

                    // Reposition from center
                    player.x = centerX - player.width / 2;
                    player.y = centerY - player.height / 2;
                }
            }

            // Die if fall off - return to main menu with credits intact
            if (player.y > 900) {
                // Death particles
                spawnParticles(player.x + player.width / 2, player.y + player.height / 2, 30, 'rgb(255, 0, 0)');

                // Exit earn mode and return to menu (credits already on-hand)
                exitPracticeMode();
            }

            // Update camera
            practiceMode.cameraX = player.x - 300;
            practiceMode.cameraY = 0;
        }

        // Party system
        async function createParty() {
            // Generate 4-letter party code
            const partyId = Array.from({length: 4}, () =>
                'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[Math.floor(Math.random() * 26)]
            ).join('');
            currentPartyId = partyId;

            await database.ref('parties/' + partyId).set({
                leaderId: currentUser.uid,
                mapId: maps[0].id,  // Default map
                raceStarted: false,
                members: {
                    [currentUser.uid]: {
                        username: currentUsername,
                        ready: false,
                        betting: false,
                        betAmount: 1
                    }
                },
                invitations: {},
                createdAt: firebase.database.ServerValue.TIMESTAMP
            });

            listenToParty(partyId);
            showScreen('partyScreen');
        }

        function listenToParty(partyId) {
            database.ref('parties/' + partyId).on('value', (snapshot) => {
                const party = snapshot.val();
                if (!party) {
                    // Party was deleted
                    currentPartyId = null;
                    backToMainMenu();
                    return;
                }

                currentParty = party;

                // Check if race started
                if (party.raceStarted && !raceState.active) {
                    startMultiplayerRace();
                } else {
                    updatePartyUI();
                }
            });

            // Listen for invitations
            database.ref('parties/' + partyId + '/invitations/' + currentUser.uid).on('value', (snapshot) => {
                const invite = snapshot.val();
                if (invite && invite.status === 'pending') {
                    // Show invitation
                }
            });
        }

        function updatePartyUI() {
            if (!currentParty) return;

            const isLeader = currentParty.leaderId === currentUser.uid;

            // Check betting status
            const allPlayers = Object.values(currentParty.members || {});
            const allBetting = allPlayers.every(p => p.betting === true);
            const noBetting = allPlayers.every(p => p.betting === false);
            const bettingMismatch = !allBetting && !noBetting;
            const allBets = allPlayers.filter(p => p.betting).map(p => p.betAmount);
            const allBetsMatch = allBets.length === 0 || allBets.every(bet => bet === allBets[0]);

            const myBetting = currentParty.members[currentUser.uid].betting;

            // Map options
            let mapOptions = '';
            for (const map of maps) {
                mapOptions += `<option value="${map.id}" ${currentParty.mapId === map.id ? 'selected' : ''}>${map.name}</option>`;
            }

            document.getElementById('partyInfo').innerHTML = `
                <div style="font-size: 20px; color: #4facfe; margin-bottom: 10px;">
                    Party ID: <span style="color: #FFC107;">${currentPartyId}</span>
                </div>
                <div>Share this ID with friends to invite them!</div>
                <div style="margin-top: 15px;">
                    <label>Map:</label>
                    <select id="partyMapSelect" onchange="updatePartyMap()" ${isLeader ? '' : 'disabled'}>
                        ${mapOptions}
                    </select>
                </div>
                <div style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                    <div style="margin-bottom: 10px;">
                        <label>
                            <input type="checkbox" id="partyBettingToggle" ${myBetting ? 'checked' : ''} onchange="togglePartyBetting()" style="width: auto; margin-right: 8px;">
                            Enable Betting
                        </label>
                    </div>
                    <div style="${myBetting ? '' : 'opacity: 0.5; pointer-events: none;'}">
                        <label>Bet Amount (credits):</label>
                        <input type="number" id="partyBetAmount" value="${currentParty.members[currentUser.uid].betAmount}" min="1" max="1000" onchange="updatePartyBet()">
                    </div>
                    <div style="font-size: 14px; margin-top: 10px;">
                        ${noBetting ? '<span style="color: #4CAF50;"> No betting - Just for fun!</span>' : ''}
                        ${allBetting && allBetsMatch ? `<span style="color: #4CAF50;"> All players betting ${allBets[0]} credit(s)</span>` : ''}
                        ${allBetting && !allBetsMatch ? '<span style="color: #ff4444;"> All betting but amounts don\'t match!</span>' : ''}
                        ${bettingMismatch ? '<span style="color: #ff4444;"> Some betting, some not - all must agree!</span>' : ''}
                    </div>
                </div>
            `;

            let membersHTML = '<h3>Members:</h3>';
            for (const [uid, member] of Object.entries(currentParty.members || {})) {
                const readyBadge = member.ready ? ' ' : '';
                const leaderBadge = uid === currentParty.leaderId ? ' [LEADER]' : '';
                const betInfo = member.betting ? `[Betting: ${member.betAmount}]` : '[No Betting]';
                const betColor = member.betting ? '#FFD700' : '#888';
                const isMe = uid === currentUser.uid ? ' (You)' : '';
                membersHTML += `<div class="party-member ${member.ready ? 'ready' : ''}">${member.username}${isMe}${leaderBadge} <span style="color: ${betColor};">${betInfo}</span>${readyBadge}</div>`;
            }
            document.getElementById('partyMembers').innerHTML = membersHTML;

            // Party controls
            const memberCount = Object.keys(currentParty.members || {}).length;
            const allReady = Object.values(currentParty.members).every(m => m.ready);
            const canStart = memberCount >= 2 && allReady && !bettingMismatch && allBetsMatch;

            let startHint = '';
            if (!canStart && allReady && memberCount >= 2) {
                if (bettingMismatch) {
                    startHint = '<div style="color: #ff4444; font-size: 12px; margin-top: 5px;">All players must agree on betting!</div>';
                } else if (!allBetsMatch) {
                    startHint = '<div style="color: #ff4444; font-size: 12px; margin-top: 5px;">All bet amounts must match!</div>';
                }
            }

            if (isLeader) {
                document.getElementById('partyControls').innerHTML = `
                    <button onclick="toggleReady()">Toggle Ready</button>
                    <button onclick="startPartyRace()" ${canStart ? '' : 'disabled'}>Start Race</button>
                    ${startHint}
                `;
            } else {
                document.getElementById('partyControls').innerHTML = `
                    <button onclick="toggleReady()">Toggle Ready</button>
                `;
            }
        }

        async function sendInvite() {
            const username = document.getElementById('inviteUsername').value.trim();
            if (!username) return;

            // Find user by username
            const usersSnapshot = await database.ref('users').orderByChild('username').equalTo(username).once('value');
            const users = usersSnapshot.val();

            if (!users) {
                alert('User not found');
                return;
            }

            const userId = Object.keys(users)[0];

            await database.ref('parties/' + currentPartyId + '/invitations/' + userId).set({
                username: username,
                status: 'pending',
                from: currentUsername
            });

            document.getElementById('inviteUsername').value = '';
            alert('Invite sent!');
        }

        async function joinPartyById() {
            const partyId = document.getElementById('partyIdInput').value.trim();
            if (!partyId) return;

            const partySnapshot = await database.ref('parties/' + partyId).once('value');
            if (!partySnapshot.exists()) {
                alert('Party not found');
                return;
            }

            currentPartyId = partyId;
            await database.ref('parties/' + partyId + '/members/' + currentUser.uid).set({
                username: currentUsername,
                ready: false,
                betting: false,
                betAmount: 1
            });

            listenToParty(partyId);
            showScreen('partyScreen');
        }

        async function togglePartyBetting() {
            const betting = document.getElementById('partyBettingToggle').checked;
            await database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid + '/betting').set(betting);
        }

        async function updatePartyBet() {
            const betAmount = Math.max(1, parseInt(document.getElementById('partyBetAmount').value) || 1);
            await database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid + '/betAmount').set(betAmount);
        }

        async function updatePartyMap() {
            const mapId = document.getElementById('partyMapSelect').value;
            await database.ref('parties/' + currentPartyId + '/mapId').set(mapId);
        }

        async function toggleReady() {
            if (!currentPartyId) return;
            const currentReady = currentParty.members[currentUser.uid].ready;
            await database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid + '/ready').set(!currentReady);
        }

        async function startPartyRace() {
            // Deduct credits if betting enabled
            const myMember = currentParty.members[currentUser.uid];
            if (myMember.betting) {
                await updateCredits(-myMember.betAmount, 'onhand');
            }

            // Mark race as started
            await database.ref('parties/' + currentPartyId).update({
                raceStarted: true,
                raceStartTime: firebase.database.ServerValue.TIMESTAMP
            });
        }

        async function leaveParty() {
            if (!currentPartyId) return;

            await database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid).remove();

            // If leader, delete party
            if (currentParty.leaderId === currentUser.uid) {
                await database.ref('parties/' + currentPartyId).remove();
            }

            database.ref('parties/' + currentPartyId).off();
            currentPartyId = null;
            backToMainMenu();
        }

        // Lobby system
        async function startRaceLobby() {
            const lobbyId = 'lobby_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            currentLobbyId = lobbyId;

            // Move all party members to lobby
            const lobbyPlayers = {};
            for (const [uid, member] of Object.entries(currentParty.members)) {
                lobbyPlayers[uid] = {
                    username: member.username,
                    ready: false,
                    betting: false, // Betting enabled/disabled
                    betAmount: 1, // Each player sets their own bet
                    credits: 0 // Will be fetched
                };
            }

            await database.ref('lobbies/' + lobbyId).set({
                mapId: maps[0].id,
                players: lobbyPlayers,
                raceStarted: false,
                leaderId: currentParty.leaderId
            });

            // Notify all party members to join lobby
            for (const uid of Object.keys(currentParty.members)) {
                await database.ref('parties/' + currentPartyId + '/lobbyId').set(lobbyId);
            }

            listenToLobby(lobbyId);
            showScreen('lobbyScreen');
        }

        function listenToLobby(lobbyId) {
            database.ref('lobbies/' + lobbyId).on('value', (snapshot) => {
                const lobby = snapshot.val();
                if (!lobby) {
                    currentLobbyId = null;
                    backToMainMenu();
                    return;
                }

                currentLobby = lobby;

                if (lobby.raceStarted && lobby.raceStartTime) {
                    startMultiplayerRace();
                } else {
                    updateLobbyUI();
                }
            });
        }

        function updateLobbyUI() {
            if (!currentLobby) return;

            const isLeader = currentLobby.leaderId === currentUser.uid;

            // Map selection
            let mapOptions = '';
            for (const map of maps) {
                mapOptions += `<option value="${map.id}" ${currentLobby.mapId === map.id ? 'selected' : ''}>${map.name}</option>`;
            }

            // Check betting status
            const allPlayers = Object.values(currentLobby.players || {});
            const allBetting = allPlayers.every(p => p.betting === true);
            const noBetting = allPlayers.every(p => p.betting === false);
            const bettingMismatch = !allBetting && !noBetting;

            // Check if all bets match (only matters if betting)
            const allBets = allPlayers.filter(p => p.betting).map(p => p.betAmount);
            const allBetsMatch = allBets.length === 0 || allBets.every(bet => bet === allBets[0]);
            const agreedBet = allBetsMatch && allBets.length > 0 ? allBets[0] : null;

            const myBetting = currentLobby.players[currentUser.uid].betting;

            document.getElementById('lobbyInfo').innerHTML = `
                <div>
                    <label>Map:</label>
                    <select id="lobbyMapSelect" onchange="updateLobbyMap()" ${isLeader ? '' : 'disabled'}>
                        ${mapOptions}
                    </select>
                </div>
                <div style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                    <div style="margin-bottom: 10px;">
                        <label>
                            <input type="checkbox" id="bettingToggle" ${myBetting ? 'checked' : ''} onchange="toggleBetting()" style="width: auto; margin-right: 8px;">
                            Enable Betting
                        </label>
                    </div>
                    <div id="betAmountSection" style="${myBetting ? '' : 'opacity: 0.5; pointer-events: none;'}">
                        <label>Bet Amount (credits):</label>
                        <input type="number" id="lobbyBetAmount" value="${currentLobby.players[currentUser.uid].betAmount}" min="1" max="1000" onchange="updateLobbyBet()">
                    </div>
                    <div style="font-size: 14px; margin-top: 10px;">
                        ${noBetting ? '<span style="color: #4CAF50;"> No betting - Just for fun!</span>' : ''}
                        ${allBetting && allBetsMatch ? `<span style="color: #4CAF50;"> All players betting ${agreedBet} credit(s)</span>` : ''}
                        ${allBetting && !allBetsMatch ? '<span style="color: #ff4444;"> All betting but amounts don\'t match!</span>' : ''}
                        ${bettingMismatch ? '<span style="color: #ff4444;"> Some betting, some not - all must agree!</span>' : ''}
                    </div>
                </div>
            `;

            // Players with their bet amounts and betting status
            let playersHTML = '<h3>Players:</h3>';
            for (const [uid, player] of Object.entries(currentLobby.players || {})) {
                const readyBadge = player.ready ? ' ' : '';
                const betInfo = player.betting ? `[Betting: ${player.betAmount}]` : '[No Betting]';
                const isMe = uid === currentUser.uid ? ' (You)' : '';
                const betColor = player.betting ? '#FFD700' : '#888';
                playersHTML += `<div class="party-member ${player.ready ? 'ready' : ''}">${player.username}${isMe} <span style="color: ${betColor};">${betInfo}</span>${readyBadge}</div>`;
            }
            document.getElementById('lobbyPlayers').innerHTML = playersHTML;

            // Controls
            const allReady = Object.values(currentLobby.players).every(p => p.ready);
            const canStart = allReady && !bettingMismatch && allBetsMatch;

            let startHint = '';
            if (!canStart && allReady) {
                if (bettingMismatch) {
                    startHint = '<div style="color: #ff4444; font-size: 12px; margin-top: 5px;">All players must agree on betting!</div>';
                } else if (!allBetsMatch) {
                    startHint = '<div style="color: #ff4444; font-size: 12px; margin-top: 5px;">All bet amounts must match!</div>';
                }
            }

            if (isLeader) {
                document.getElementById('lobbyControls').innerHTML = `
                    <button onclick="toggleLobbyReady()">Toggle Ready</button>
                    <button onclick="startRace()" ${canStart ? '' : 'disabled'}>Start Race</button>
                    ${startHint}
                `;
            } else {
                document.getElementById('lobbyControls').innerHTML = `
                    <button onclick="toggleLobbyReady()">Toggle Ready</button>
                `;
            }
        }

        async function updateLobbyMap() {
            const mapId = document.getElementById('lobbyMapSelect').value;
            await database.ref('lobbies/' + currentLobbyId + '/mapId').set(mapId);
        }

        async function toggleBetting() {
            const betting = document.getElementById('bettingToggle').checked;
            await database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid + '/betting').set(betting);
        }

        async function updateLobbyBet() {
            const betAmount = Math.max(1, parseInt(document.getElementById('lobbyBetAmount').value) || 1);
            await database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid + '/betAmount').set(betAmount);
        }

        async function toggleLobbyReady() {
            if (!currentLobbyId) return;
            const currentReady = currentLobby.players[currentUser.uid].ready;
            await database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid + '/ready').set(!currentReady);
        }

        async function startRace() {
            // Deduct bet from player's credits only if betting is enabled
            const myPlayer = currentLobby.players[currentUser.uid];
            if (myPlayer.betting) {
                await updateCredits(-myPlayer.betAmount, 'onhand');
            }

            await database.ref('lobbies/' + currentLobbyId).update({
                raceStarted: true,
                raceStartTime: firebase.database.ServerValue.TIMESTAMP
            });
        }

        async function leaveLobby() {
            if (!currentLobbyId) return;
            database.ref('lobbies/' + currentLobbyId).off();
            await database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid).remove();
            currentLobbyId = null;
            backToMainMenu();
        }

        // Multiplayer racing
        let raceState = {
            active: false,
            player: null,
            opponents: {},
            map: null,
            startTime: 0,
            finishTime: 0,
            finished: false,
            cameraX: 0,
            cameraY: 0,
            keys: {},
            platforms: [],
            hazards: []
        };

        async function startMultiplayerRace() {
            const canvas = document.getElementById('raceCanvas');
            const ctx = canvas.getContext('2d');
            canvas.style.display = 'block';
            document.getElementById('timer').style.display = 'block';
            document.getElementById('racePositions').style.display = 'block';

            // Hide party screen
            document.getElementById('partyScreen').classList.remove('active');

            // Get map from party (not lobby)
            raceState.map = maps.find(m => m.id === currentParty.mapId);
            raceState.platforms = raceState.map.platforms;
            raceState.hazards = raceState.map.hazards;

            // Create player at start position
            raceState.player = new Player(raceState.map.start.x, raceState.map.start.y, equippedCosmetics);
            raceState.active = true;
            raceState.finished = false;
            raceState.startTime = Date.now();

            // Countdown
            await showCountdown();

            // Listen for opponent positions (use party members, not lobby players)
            database.ref('parties/' + currentPartyId + '/members').on('value', (snapshot) => {
                const members = snapshot.val();
                raceState.opponents = {};
                for (const [uid, member] of Object.entries(members)) {
                    if (uid !== currentUser.uid && member.position) {
                        raceState.opponents[uid] = {
                            username: member.username,
                            player: new Player(member.position.x, member.position.y, member.equippedCosmetics || {}),
                            finished: member.finished || false
                        };
                    }
                }
            });

            // Start position sync (use party path, not lobby path)
            // Update every 33ms (~30fps) for smoother multiplayer movement
            const positionSyncInterval = setInterval(() => {
                if (!raceState.active || raceState.finished) {
                    clearInterval(positionSyncInterval);
                    return;
                }

                database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid).update({
                    position: { x: raceState.player.x, y: raceState.player.y },
                    velocity: { x: raceState.player.velocityX, y: raceState.player.velocityY },
                    equippedCosmetics: equippedCosmetics
                });
            }, 33);

            let lastRaceFrameTime = performance.now();
            function raceLoop(currentTime) {
                if (!raceState.active) return;

                // Calculate delta time
                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastRaceFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                lastRaceFrameTime = currentTime;

                // Update
                updateRacePlayer(deltaTime);

                // Check finish
                if (!raceState.finished && checkCollision(raceState.player, raceState.map.finish)) {
                    finishRace();
                }

                // Update timer
                const elapsed = (Date.now() - raceState.startTime) / 1000;
                document.getElementById('timer').textContent = elapsed.toFixed(2);

                // Update positions
                updateRacePositions();

                // Render
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw platforms
                for (const platform of raceState.platforms) {
                    const screenX = platform.x - raceState.cameraX;
                    const screenY = platform.y - raceState.cameraY;

                    // Green platform
                    ctx.fillStyle = '#00AA00';
                    ctx.fillRect(screenX, screenY, platform.width, platform.height);

                    // Draw 40x40 grid lines
                    ctx.strokeStyle = '#006600';
                    ctx.lineWidth = 1;
                    for (let gx = 0; gx < platform.width; gx += 40) {
                        ctx.beginPath();
                        ctx.moveTo(screenX + gx, screenY);
                        ctx.lineTo(screenX + gx, screenY + platform.height);
                        ctx.stroke();
                    }
                    for (let gy = 0; gy < platform.height; gy += 40) {
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY + gy);
                        ctx.lineTo(screenX + platform.width, screenY + gy);
                        ctx.stroke();
                    }
                }

                // Draw hazards (red)
                for (const hazard of raceState.hazards) {
                    const screenX = hazard.x - raceState.cameraX;
                    const screenY = hazard.y - raceState.cameraY;
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(screenX, screenY, hazard.width, hazard.height);
                }

                // Draw finish line
                const finishScreenX = raceState.map.finish.x - raceState.cameraX;
                const finishScreenY = raceState.map.finish.y - raceState.cameraY;
                ctx.fillStyle = '#00FF00';
                ctx.fillRect(finishScreenX, finishScreenY, raceState.map.finish.width, raceState.map.finish.height);

                // Draw opponents
                for (const opponent of Object.values(raceState.opponents)) {
                    opponent.player.updateTrail();
                    opponent.player.draw(ctx, raceState.cameraX, raceState.cameraY, true, opponent.username);
                }

                // Draw local player
                raceState.player.updateTrail();
                raceState.player.draw(ctx, raceState.cameraX, raceState.cameraY, true, currentUsername);

                requestAnimationFrame(raceLoop);
            }

            raceLoop();
        }

        function updateRacePlayer(deltaTime = 1) {
            const player = raceState.player;

            // Check hazards first (before position update)
            for (const hazard of raceState.hazards) {
                if (checkCollision(player, hazard)) {
                    // Reset to start
                    player.x = raceState.map.start.x;
                    player.y = raceState.map.start.y;
                    player.velocityX = 0;
                    player.velocityY = 0;
                    raceIsJumping = false;
                }
            }

            // Apply gravity with fast fall (scaled by size)
            const sizeScale = player.currentSize / 40;
            if ((raceState.keys['s'] || raceState.keys['ArrowDown']) && !player.wasGrounded) {
                player.velocityY += GRAVITY * sizeScale * FAST_FALL_MULTIPLIER * deltaTime;
                // Fast-fall particles (white)
                if (Math.random() < 0.3) {
                    spawnParticles(player.x + player.width / 2, player.y, 3, 'rgb(255, 255, 255)');
                }
            } else {
                player.velocityY += GRAVITY * sizeScale * deltaTime;
            }

            // Apply friction using exponential decay (use previous frame's grounded state)
            if (player.wasGrounded) {
                player.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                player.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Cap vertical velocity to prevent tunneling
            const maxFallSpeed = 8 * sizeScale;
            player.velocityY = Math.min(player.velocityY, maxFallSpeed);

            // Limit horizontal speed
            const maxSpeed = GROUND_MAX_SPEED;
            player.velocityX = Math.max(-maxSpeed, Math.min(maxSpeed, player.velocityX));

            // Handle input (acceleration-based movement)
            if (raceState.keys['a'] || raceState.keys['ArrowLeft']) {
                player.velocityX -= MOVE_SPEED * deltaTime;
            }
            if (raceState.keys['d'] || raceState.keys['ArrowRight']) {
                player.velocityX += MOVE_SPEED * deltaTime;
            }

            // Update position
            player.x += player.velocityX * deltaTime;
            player.y += player.velocityY * deltaTime;

            // Collision detection - matches level creator and practice mode
            let isGrounded = false;
            for (const platform of raceState.platforms) {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {

                    const overlapLeft = (player.x + player.width) - platform.x;
                    const overlapRight = (platform.x + platform.width) - player.x;
                    const overlapTop = (player.y + player.height) - platform.y;
                    const overlapBottom = (platform.y + platform.height) - player.y;

                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    // Floor collision (landing on top)
                    if ((minOverlap === overlapTop && player.velocityY >= 0) ||
                        (player.velocityY > 0 && overlapTop < overlapBottom &&
                         overlapTop < overlapLeft * 0.5 && overlapTop < overlapRight * 0.5)) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        isGrounded = true;
                    }
                    // Ceiling collision (hitting from below)
                    else if (minOverlap === overlapBottom && player.velocityY < 0) {
                        player.y = platform.y + platform.height;
                        player.velocityY = 0;
                    }
                    // Left wall collision
                    else if (minOverlap === overlapLeft) {
                        player.x = platform.x - player.width;
                        player.velocityX = 0;
                    }
                    // Right wall collision
                    else if (minOverlap === overlapRight) {
                        player.x = platform.x + platform.width;
                        player.velocityX = 0;
                    }
                }
            }

            // Landing particles (gray)
            if (isGrounded && !player.wasGrounded) {
                spawnParticles(player.x + player.width / 2, player.y + player.height, 8, 'rgb(200, 200, 200)', player.currentSize);
            }
            player.wasGrounded = isGrounded;

            // Jump with variable height (W or Up only, NOT space)
            if ((raceState.keys['w'] || raceState.keys['ArrowUp']) && isGrounded) {
                // Scale jump power by size
                const sizeScale = player.currentSize / 40;
                player.velocityY = -JUMP_POWER * sizeScale;
                raceIsJumping = true;
                // Jump particles (white)
                spawnParticles(player.x + player.width / 2, player.y + player.height, 12, 'rgb(255, 255, 255)', player.currentSize);
            }

            // Cut jump short if button released (variable jump height)
            if (raceIsJumping && !raceState.keys['w'] && !raceState.keys['ArrowUp']) {
                if (player.velocityY < 0) {
                    player.velocityY *= 0.5;
                }
                raceIsJumping = false;
            }

            // Reset jump state when grounded
            if (isGrounded && player.velocityY >= 0) {
                raceIsJumping = false;
            }

            // Update camera
            raceState.cameraX = player.x - 400;
            raceState.cameraY = player.y - 300;
        }

        function updateRacePositions() {
            // Calculate positions based on distance to finish
            const finishX = raceState.map.finish.x;

            const positions = [
                { uid: currentUser.uid, username: currentUsername, distance: Math.abs(raceState.player.x - finishX), finished: raceState.finished }
            ];

            for (const [uid, opponent] of Object.entries(raceState.opponents)) {
                positions.push({
                    uid: uid,
                    username: opponent.username,
                    distance: Math.abs(opponent.player.x - finishX),
                    finished: opponent.finished
                });
            }

            positions.sort((a, b) => {
                if (a.finished && !b.finished) return -1;
                if (!a.finished && b.finished) return 1;
                return a.distance - b.distance;
            });

            let html = '<h3>Positions</h3>';
            for (let i = 0; i < positions.length; i++) {
                html += `<div>${i + 1}. ${positions[i].username}${positions[i].finished ? ' [FINISHED]' : ''}</div>`;
            }
            document.getElementById('racePositions').innerHTML = html;
        }

        async function finishRace() {
            raceState.finished = true;
            raceState.finishTime = Date.now() - raceState.startTime;

            await database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid).update({
                finished: true,
                finishTime: raceState.finishTime
            });

            // Check if all finished
            setTimeout(checkRaceComplete, 2000);
        }

        async function checkRaceComplete() {
            const snapshot = await database.ref('parties/' + currentPartyId + '/members').once('value');
            const members = snapshot.val();

            const allFinished = Object.values(members).every(m => m.finished);

            if (allFinished) {
                // Calculate results
                const results = [];
                for (const [uid, member] of Object.entries(members)) {
                    results.push({
                        uid: uid,
                        username: member.username,
                        time: member.finishTime
                    });
                }

                results.sort((a, b) => a.time - b.time);

                // Check if betting was enabled
                const bettingEnabled = Object.values(members).some(m => m.betting);
                const pot = bettingEnabled ? Object.values(members).filter(m => m.betting).reduce((sum, m) => sum + (m.betAmount || 0), 0) : 0;

                // Award credits to winner only if betting was enabled
                if (bettingEnabled && results[0].uid === currentUser.uid) {
                    await updateCredits(pot, 'onhand');
                    userStats.racesWon++;
                } else if (bettingEnabled) {
                    // Lost - already deducted at race start
                }

                userStats.racesPlayed++;
                await database.ref('players/' + currentUser.uid + '/stats').set(userStats);

                // Show results
                showRaceResults(results, pot, bettingEnabled);
            }
        }

        function showRaceResults(results, pot, bettingEnabled) {
            let html = '';
            for (let i = 0; i < results.length; i++) {
                const isMe = results[i].uid === currentUser.uid;
                const isWinner = i === 0;
                html += `<div class="result-entry ${isWinner ? 'winner' : ''}" style="${isMe ? 'font-weight: bold; color: #4facfe;' : ''}">
                    ${i + 1}. ${results[i].username} - ${(results[i].time / 1000).toFixed(2)}s
                </div>`;
            }

            if (bettingEnabled) {
                if (results[0].uid === currentUser.uid) {
                    html = `<div style="color: #FFD700; font-size: 24px; margin-bottom: 20px;">YOU WIN! +${pot} credits</div>` + html;
                } else {
                    const myBet = currentParty.members[currentUser.uid].betAmount;
                    html = `<div style="color: #ff4444; font-size: 18px; margin-bottom: 20px;">You lost ${myBet} credits</div>` + html;
                }
            } else {
                if (results[0].uid === currentUser.uid) {
                    html = `<div style="color: #FFD700; font-size: 24px; margin-bottom: 20px;">YOU WIN!</div>` + html;
                } else {
                    html = `<div style="color: #888; font-size: 18px; margin-bottom: 20px;">No betting - Just for fun!</div>` + html;
                }
            }

            document.getElementById('resultsContent').innerHTML = html;
            document.getElementById('raceResults').style.display = 'block';
        }

        async function returnToParty() {
            document.getElementById('raceResults').style.display = 'none';
            document.getElementById('raceCanvas').style.display = 'none';
            document.getElementById('timer').style.display = 'none';
            document.getElementById('racePositions').style.display = 'none';

            raceState.active = false;
            database.ref('lobbies/' + currentLobbyId + '/players').off();

            await database.ref('lobbies/' + currentLobbyId).remove();

            showScreen('partyScreen');
        }

        async function showCountdown() {
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';

            for (let i = 3; i > 0; i--) {
                countdownEl.textContent = i;
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            countdownEl.textContent = 'GO!';
            await new Promise(resolve => setTimeout(resolve, 500));
            countdownEl.style.display = 'none';
        }

        // Cosmetic shop
        function showShop() {
            showScreen('shopScreen');
            updateShopUI();
        }

        function updateShopUI() {
            document.getElementById('shopCredits').textContent = `On-Hand Credits: ${userCredits}`;

            let html = '';

            // Equippable Items Section
            html += `<div class="shop-category">
                <h2>EQUIPPABLE ITEMS</h2>
                <div class="cosmetics-grid">
                    <div class="cosmetic-item ${equippedItem === 'credits' ? 'equipped' : ''}">
                        <div style="font-weight: bold;">Credit Display</div>
                        <div style="color: #aaa; font-size: 12px;">Show credits on character</div>
                        ${equippedItem === 'credits'
                            ? '<div style="color: #0f0;"> EQUIPPED</div><button onclick="unequipItem()" style="margin-top: 5px;">Unequip</button>'
                            : '<button onclick="equipItem(\'credits\')" style="margin-top: 5px;">Equip</button>'
                        }
                    </div>
                </div>
            </div>`;

            for (const [category, items] of Object.entries(cosmeticsCatalog)) {
                html += `<div class="shop-category">
                    <h2>${category.toUpperCase()}</h2>
                    <div class="cosmetics-grid">`;

                for (const item of items) {
                    const owned = userCosmetics[category].includes(item.id);
                    const equipped = equippedCosmetics[category === 'skins' ? 'skin' : category.slice(0, -1)] === item.id;

                    html += `<div class="cosmetic-item ${owned ? 'owned' : ''} ${equipped ? 'equipped' : ''}">
                        <div style="font-weight: bold;">${item.name}</div>
                        <div style="color: #FFC107;">${item.price} credits</div>`;

                    if (equipped) {
                        html += `<div style="display: flex; flex-direction: column; gap: 5px; margin-top: 5px;">
                            <div style="color: #0f0;"> EQUIPPED</div>
                            <button onclick="unequipCosmetic('${category}')">Unequip</button>
                        </div>`;
                    } else if (owned) {
                        html += `<button onclick="equipCosmetic('${category}', '${item.id}')" style="margin-top: 5px;">Equip</button>`;
                    } else {
                        html += `<button onclick="buyCosmetic('${category}', '${item.id}', ${item.price})" ${userCredits >= item.price ? '' : 'disabled'} style="margin-top: 5px;">Buy</button>`;
                    }

                    html += `</div>`;
                }

                html += `</div></div>`;
            }

            document.getElementById('shopContent').innerHTML = html;
        }

        async function buyCosmetic(category, itemId, price) {
            if (userCredits < price) {
                alert('Not enough credits!');
                return;
            }

            await updateCredits(-price);
            userCosmetics[category].push(itemId);
            await database.ref('players/' + currentUser.uid + '/cosmetics').set(userCosmetics);

            updateShopUI();
        }

        async function equipCosmetic(category, itemId) {
            const slot = category === 'skins' ? 'skin' : category.slice(0, -1);
            equippedCosmetics[slot] = itemId;
            await database.ref('players/' + currentUser.uid + '/equippedCosmetics').set(equippedCosmetics);

            // Update menu player cosmetics immediately
            if (menuPlayer) {
                menuPlayer.cosmetics = equippedCosmetics;
            }

            updateShopUI();
        }

        async function unequipCosmetic(category) {
            const slot = category === 'skins' ? 'skin' : category.slice(0, -1);
            const defaultValue = slot === 'skin' ? 'default_orange' : 'none';
            equippedCosmetics[slot] = defaultValue;
            await database.ref('players/' + currentUser.uid + '/equippedCosmetics').set(equippedCosmetics);

            // Update menu player cosmetics immediately
            if (menuPlayer) {
                menuPlayer.cosmetics = equippedCosmetics;
            }

            updateShopUI();
        }

        async function equipItem(itemId) {
            equippedItem = itemId;
            await database.ref('players/' + currentUser.uid + '/equippedItem').set(equippedItem);
            updateShopUI();
        }

        async function unequipItem() {
            equippedItem = 'none';
            await database.ref('players/' + currentUser.uid + '/equippedItem').set(equippedItem);
            updateShopUI();
        }

        // Stats screen
        function showStats() {
            showScreen('statsScreen');
            document.getElementById('statsContent').innerHTML = `
                <div style="margin: 20px 0;">Races Won: ${userStats.racesWon}</div>
                <div style="margin: 20px 0;">Races Played: ${userStats.racesPlayed}</div>
                <div style="margin: 20px 0;">Win Rate: ${userStats.racesPlayed > 0 ? ((userStats.racesWon / userStats.racesPlayed) * 100).toFixed(1) : 0}%</div>
                <div style="margin: 20px 0;">Total Credits Earned: ${userStats.totalCreditsEarned}</div>
            `;
        }

        // Zoom variables for all modes
        let baseZoom = 1;
        let practiceZoom = 1;
        let menuZoom = 1;

        // Base screen (build with credits)
        let baseBlocks = []; // Each block: { x, y, credits } where credits can be 1-3
        let baseCanvas, baseCtx;
        let basePlayer = null;
        let baseKeys = {};
        let baseIsJumping = false;
        let basePlatforms = [];
        let lastPlacedBlock = null; // Track last placed block for continuous placement

        async function showBase() {
            showScreen('baseScreen');
            document.getElementById('baseCredits').textContent = `Credits: ${secureCredits} (${userCredits} on hand)`;

            baseCanvas = document.getElementById('baseCanvas');
            baseCtx = baseCanvas.getContext('2d');

            // Load base blocks from Firebase
            const baseSnapshot = await database.ref('players/' + currentUser.uid + '/baseBlocks').once('value');
            baseBlocks = baseSnapshot.val() || [];

            // Create base platforms (100x100 blocks = 4000x4000px area)
            basePlatforms = [
                // Ground
                { x: 0, y: 4000, width: 4000, height: 80 },
                // Left wall (100 blocks high)
                { x: -40, y: 0, width: 40, height: 4080 },
                // Right wall
                { x: 4000, y: 0, width: 40, height: 4080 }
            ];

            // Initialize player next to one of the blocks in base
            let spawnX = 2000;
            let spawnY = 3960; // Default spawn on ground
            if (baseBlocks.length > 0) {
                // Pick the first block and spawn next to it (to the right)
                const firstBlock = baseBlocks[0];
                spawnX = firstBlock.x + 20; // Spawn to the right of the block (20x20 blocks)
                spawnY = firstBlock.y; // Same height as the block
            }
            basePlayer = new Player(spawnX, spawnY, equippedCosmetics);

            renderBase();

            // Track mouse state for continuous placement/removal
            let isMouseDown = false;
            let isRightMouseDown = false;

            // Add mouse handlers for continuous placement/removal
            baseCanvas.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // Left click
                    isMouseDown = true;
                    handleBaseClick(e);
                } else if (e.button === 2) { // Right click
                    isRightMouseDown = true;
                    handleBaseRightClick(e);
                }
            });

            baseCanvas.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    isMouseDown = false;
                    lastPlacedBlock = null;
                } else if (e.button === 2) {
                    isRightMouseDown = false;
                    lastPlacedBlock = null;
                }
            });

            baseCanvas.addEventListener('mouseleave', () => {
                isMouseDown = false;
                isRightMouseDown = false;
                lastPlacedBlock = null;
            });

            baseCanvas.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    handleBaseClick(e);
                } else if (isRightMouseDown) {
                    handleBaseRightClick(e);
                }
            });

            baseCanvas.oncontextmenu = (e) => {
                e.preventDefault();
                return false;
            };

            // Add zoom with mouse wheel
            baseCanvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY < 0) {
                    // Zoom in
                    baseZoom = Math.min(baseZoom * 1.1, 3); // Max 3x zoom
                } else {
                    // Zoom out
                    baseZoom = Math.max(baseZoom / 1.1, 0.3); // Min 0.3x zoom
                }
            }, { passive: false });

            // Start base loop
            let lastBaseFrameTime = performance.now();
            function baseLoop(currentTime) {
                if (baseCanvas.style.display === 'none') return;

                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastBaseFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                lastBaseFrameTime = currentTime;

                updateBasePlayer(deltaTime);
                renderBase();

                requestAnimationFrame(baseLoop);
            }

            baseLoop();
        }

        function updateBasePlayer(deltaTime = 1) {
            if (!basePlayer) return;

            // Combine user-placed blocks with boundary platforms for collision
            const allPlatforms = [...basePlatforms, ...baseBlocks.map(b => ({ x: b.x, y: b.y, width: 20, height: 20 }))];

            // Check grounded state
            let isGrounded = false;
            for (const platform of allPlatforms) {
                const onTop = basePlayer.y + basePlayer.height >= platform.y &&
                              basePlayer.y + basePlayer.height <= platform.y + 5;
                const horizontalOverlap = basePlayer.x + basePlayer.width > platform.x &&
                                         basePlayer.x < platform.x + platform.width;

                if (onTop && horizontalOverlap) {
                    isGrounded = true;
                    break;
                }
            }

            // Apply gravity
            if ((baseKeys['s'] || baseKeys['ArrowDown']) && !isGrounded) {
                basePlayer.velocityY += GRAVITY * FAST_FALL_MULTIPLIER * deltaTime;
                // Fast-fall particles (white)
                if (Math.random() < 0.3) {
                    spawnParticles(basePlayer.x + basePlayer.width / 2, basePlayer.y, 3, 'rgb(255, 255, 255)');
                }
            } else {
                basePlayer.velocityY += GRAVITY * deltaTime;
            }

            // Movement
            if (baseKeys['a'] || baseKeys['ArrowLeft']) {
                basePlayer.velocityX -= MOVE_SPEED * deltaTime;
            }
            if (baseKeys['d'] || baseKeys['ArrowRight']) {
                basePlayer.velocityX += MOVE_SPEED * deltaTime;
            }

            // Jump
            if ((baseKeys['w'] || baseKeys['ArrowUp']) && isGrounded) {
                // Scale jump power by size (BASE player is always 40px)
                const sizeScale = basePlayer.currentSize / 40;
                basePlayer.velocityY = -JUMP_POWER * sizeScale;
                baseIsJumping = true;
            }

            // Variable jump height
            if (baseIsJumping && !baseKeys['w'] && !baseKeys['ArrowUp']) {
                if (basePlayer.velocityY < 0) {
                    basePlayer.velocityY *= 0.5;
                }
                baseIsJumping = false;
            }

            // Friction
            if (isGrounded) {
                basePlayer.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                basePlayer.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Limit speed
            basePlayer.velocityX = Math.max(-GROUND_MAX_SPEED, Math.min(GROUND_MAX_SPEED, basePlayer.velocityX));

            // Update X position, check X collisions
            basePlayer.x += basePlayer.velocityX * deltaTime;
            for (const platform of allPlatforms) {
                if (checkCollision(basePlayer, platform)) {
                    if (basePlayer.velocityX > 0) {
                        basePlayer.x = platform.x - basePlayer.width;
                    } else if (basePlayer.velocityX < 0) {
                        basePlayer.x = platform.x + platform.width;
                    }
                    basePlayer.velocityX = 0;
                }
            }

            // Update Y position, check Y collisions
            basePlayer.y += basePlayer.velocityY * deltaTime;
            for (const platform of allPlatforms) {
                if (checkCollision(basePlayer, platform)) {
                    if (basePlayer.velocityY > 0) {
                        basePlayer.y = platform.y - basePlayer.height;
                        basePlayer.velocityY = 0;
                    } else if (basePlayer.velocityY < 0) {
                        basePlayer.y = platform.y + platform.height;
                        basePlayer.velocityY = 0;
                        baseIsJumping = false;
                    }
                }
            }
        }

        function renderBase() {
            if (!basePlayer) return;

            // Clear and apply zoom
            baseCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
            baseCtx.fillStyle = '#87CEEB';
            baseCtx.fillRect(0, 0, baseCanvas.width, baseCanvas.height);

            // Apply zoom transform (scale from center)
            baseCtx.translate(baseCanvas.width / 2, baseCanvas.height / 2);
            baseCtx.scale(baseZoom, baseZoom);
            baseCtx.translate(-baseCanvas.width / 2, -baseCanvas.height / 2);

            // Camera follows player
            const cameraX = basePlayer.x - baseCanvas.width / 2;
            const cameraY = basePlayer.y - baseCanvas.height / 2;

            // Draw grid (40x40px blocks)
            baseCtx.strokeStyle = '#ccc';
            baseCtx.lineWidth = 0.5;
            for (let x = 0; x <= 4000; x += 20) {
                const screenX = x - cameraX;
                baseCtx.beginPath();
                baseCtx.moveTo(screenX, -cameraY);
                baseCtx.lineTo(screenX, 4080 - cameraY);
                baseCtx.stroke();
            }
            for (let y = 0; y <= 4080; y += 20) {
                const screenY = y - cameraY;
                baseCtx.beginPath();
                baseCtx.moveTo(-cameraX, screenY);
                baseCtx.lineTo(4000 - cameraX, screenY);
                baseCtx.stroke();
            }

            // Draw boundary platforms (ground and walls)
            for (const platform of basePlatforms) {
                const screenX = platform.x - cameraX;
                const screenY = platform.y - cameraY;
                baseCtx.fillStyle = '#00AA00';
                baseCtx.fillRect(screenX, screenY, platform.width, platform.height);

                // Grid lines
                baseCtx.strokeStyle = '#006600';
                baseCtx.lineWidth = 1;
                for (let gx = 0; gx < platform.width; gx += 40) {
                    baseCtx.beginPath();
                    baseCtx.moveTo(screenX + gx, screenY);
                    baseCtx.lineTo(screenX + gx, screenY + platform.height);
                    baseCtx.stroke();
                }
                for (let gy = 0; gy < platform.height; gy += 40) {
                    baseCtx.beginPath();
                    baseCtx.moveTo(screenX, screenY + gy);
                    baseCtx.lineTo(screenX + platform.width, screenY + gy);
                    baseCtx.stroke();
                }
            }

            // Draw placed blocks (golden, darker with more credits)
            for (const block of baseBlocks) {
                const screenX = block.x - cameraX;
                const screenY = block.y - cameraY;

                // Gold color gets darker with more credits (1-3)
                const credits = block.credits || 1;
                if (credits === 1) {
                    baseCtx.fillStyle = '#FFD700'; // Light gold
                } else if (credits === 2) {
                    baseCtx.fillStyle = '#DAA520'; // Medium gold (goldenrod)
                } else {
                    baseCtx.fillStyle = '#B8860B'; // Dark gold
                }
                baseCtx.fillRect(screenX, screenY, 40, 40);
                baseCtx.strokeStyle = '#FFA500';
                baseCtx.lineWidth = 2;
                baseCtx.strokeRect(screenX, screenY, 40, 40);
            }

            // Draw player
            basePlayer.updateTrail();
            basePlayer.draw(baseCtx, cameraX, cameraY, false);
        }

        async function handleBaseClick(e) {
            if (!basePlayer) return;

            const rect = baseCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Convert screen coordinates to world coordinates
            const cameraX = basePlayer.x - baseCanvas.width / 2;
            const cameraY = basePlayer.y - baseCanvas.height / 2;
            const worldX = clickX + cameraX;
            const worldY = clickY + cameraY;

            // Snap to 40x40 grid
            const gridX = Math.floor(worldX / 40) * 40;
            const gridY = Math.floor(worldY / 40) * 40;

            // Check if within base bounds (0-4000, 0-4000) - silently prevent
            if (gridX < 0 || gridX >= 4000 || gridY < 0 || gridY >= 4000) {
                return;
            }

            // Skip if this is the same block we just interacted with (prevents spam during drag)
            const blockKey = `${gridX},${gridY}`;
            if (lastPlacedBlock === blockKey) {
                return;
            }
            lastPlacedBlock = blockKey;

            // Check if block already exists
            const existingBlock = baseBlocks.find(b => b.x === gridX && b.y === gridY);
            if (existingBlock) {
                // Block exists - try to add another credit (max 3)
                if (existingBlock.credits >= 3) {
                    return; // Silently prevent adding more than 3 credits
                }
                if (userCredits < 1) {
                    return; // Silently prevent if no credits
                }
                // Add credit to existing block
                existingBlock.credits = (existingBlock.credits || 1) + 1;
                await updateCredits(-1, 'onhand');
                await database.ref('players/' + currentUser.uid + '/baseBlocks').set(baseBlocks);
                document.getElementById('baseCredits').textContent = `Credits: ${secureCredits} (${userCredits} on hand)`;
                return;
            }

            // Check if user has credits - silently prevent
            if (userCredits < 1) {
                return;
            }

            // Place new block with 1 credit
            baseBlocks.push({ x: gridX, y: gridY, credits: 1 });
            await updateCredits(-1, 'onhand');
            await database.ref('players/' + currentUser.uid + '/baseBlocks').set(baseBlocks);

            document.getElementById('baseCredits').textContent = `Credits: ${secureCredits} (${userCredits} on hand)`;
        }

        async function handleBaseRightClick(e) {
            e.preventDefault();
            if (!basePlayer) return false;

            const rect = baseCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Convert screen coordinates to world coordinates
            const cameraX = basePlayer.x - baseCanvas.width / 2;
            const cameraY = basePlayer.y - baseCanvas.height / 2;
            const worldX = clickX + cameraX;
            const worldY = clickY + cameraY;

            // Snap to 40x40 grid
            const gridX = Math.floor(worldX / 40) * 40;
            const gridY = Math.floor(worldY / 40) * 40;

            // Skip if this is the same block we just interacted with (prevents spam during drag)
            const blockKey = `${gridX},${gridY}`;
            if (lastPlacedBlock === blockKey) {
                return false;
            }
            lastPlacedBlock = blockKey;

            // Find block
            const index = baseBlocks.findIndex(b => b.x === gridX && b.y === gridY);
            if (index === -1) {
                return false; // Silently prevent if no block
            }

            // Remove ONE credit from the block
            const block = baseBlocks[index];
            const creditsInBlock = block.credits || 1;

            if (creditsInBlock > 1) {
                // Block has multiple credits - just remove one
                block.credits = creditsInBlock - 1;
                await updateCredits(1, 'secure');  // One credit goes to secure storage
                await database.ref('players/' + currentUser.uid + '/baseBlocks').set(baseBlocks);
            } else {
                // Block has only 1 credit - remove entire block
                baseBlocks.splice(index, 1);
                await updateCredits(1, 'secure');  // One credit goes to secure storage
                await database.ref('players/' + currentUser.uid + '/baseBlocks').set(baseBlocks);
            }

            document.getElementById('baseCredits').textContent = `Credits: ${secureCredits} (${userCredits} on hand)`;

            return false;
        }

        // Leaderboard screen
        async function showLeaderboard() {
            showScreen('leaderboardScreen');

            // Fetch all players with their credits
            const playersSnapshot = await database.ref('players').once('value');
            const playersData = playersSnapshot.val();

            if (!playersData) {
                document.getElementById('leaderboardContent').innerHTML = '<p>No players found.</p>';
                return;
            }

            // Create array of players with secure credits
            const leaderboard = [];
            for (const [uid, playerData] of Object.entries(playersData)) {
                if (playerData.username) {
                    leaderboard.push({
                        uid: uid,
                        username: playerData.username,
                        secureCredits: playerData.secureCredits || 0
                    });
                }
            }

            // Sort by secure credits descending
            leaderboard.sort((a, b) => b.secureCredits - a.secureCredits);

            // Build HTML with player info sidebar
            let html = '<div style="display: flex; gap: 20px; height: 100%;">';

            // Left sidebar with player info
            html += `<div style="
                width: 250px;
                background: linear-gradient(135deg, rgba(79, 172, 254, 0.2), rgba(79, 172, 254, 0.05));
                border: 2px solid #4facfe;
                border-radius: 15px;
                padding: 25px;
                box-shadow: 0 8px 32px rgba(79, 172, 254, 0.3);
            ">
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="
                        width: 80px;
                        height: 80px;
                        background: ${menuPlayer ? menuPlayer.getSkinColor() : '#FF8C42'};
                        border: 4px solid #333;
                        border-radius: 10px;
                        margin: 0 auto 15px;
                        box-shadow: 0 4px 15px rgba(0,0,0,0.4);
                    "></div>
                    <div style="font-size: 20px; font-weight: bold; color: #fff; margin-bottom: 5px;">${currentUsername}</div>
                </div>

                <div style="
                    background: rgba(0,0,0,0.3);
                    border-radius: 10px;
                    padding: 15px;
                    margin-bottom: 15px;
                ">
                    <div style="color: #4facfe; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">Secure Credits</div>
                    <div style="font-size: 32px; font-weight: bold; color: #FFD700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);">${secureCredits}</div>
                </div>

                <div style="
                    background: rgba(0,0,0,0.3);
                    border-radius: 10px;
                    padding: 15px;
                ">
                    <div style="color: #4facfe; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">On Hand</div>
                    <div style="font-size: 24px; font-weight: bold; color: #aaa;">${userCredits}</div>
                </div>
            </div>`;

            // Right side with leaderboard
            html += '<div style="flex: 1; background: rgba(0,0,0,0.3); border-radius: 15px; padding: 25px; overflow-y: auto; max-height: 600px;">';

            for (let i = 0; i < Math.min(leaderboard.length, 50); i++) {
                const player = leaderboard[i];
                const isYou = player.uid === currentUser.uid;
                const rankColor = i === 0 ? '#FFD700' : i === 1 ? '#C0C0C0' : i === 2 ? '#CD7F32' : '#4facfe';
                const rankBg = i === 0 ? 'rgba(255, 215, 0, 0.1)' : i === 1 ? 'rgba(192, 192, 192, 0.1)' : i === 2 ? 'rgba(205, 127, 50, 0.1)' : 'rgba(79, 172, 254, 0.05)';

                html += `<div style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 15px 20px;
                    margin: 8px 0;
                    background: ${isYou ? 'rgba(79, 172, 254, 0.2)' : rankBg};
                    border-radius: 10px;
                    border-left: 5px solid ${rankColor};
                    transition: transform 0.2s, box-shadow 0.2s;
                    ${isYou ? 'box-shadow: 0 0 20px rgba(79, 172, 254, 0.5);' : ''}
                " onmouseover="this.style.transform='translateX(5px)'; this.style.boxShadow='0 4px 15px rgba(0,0,0,0.3)';" onmouseout="this.style.transform='translateX(0)'; this.style.boxShadow='none';">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <span style="
                            font-size: 24px;
                            font-weight: bold;
                            color: ${rankColor};
                            min-width: 40px;
                            text-align: center;
                        ">${i === 0 ? '' : i === 1 ? '' : i === 2 ? '' : (i + 1)}</span>
                        <span style="
                            color: white;
                            font-size: 18px;
                            ${isYou ? 'font-weight: bold; text-shadow: 0 0 10px rgba(79, 172, 254, 0.8);' : ''}
                        ">${player.username}${isYou ? ' ' : ''}</span>
                    </div>
                    <span style="
                        color: #FFD700;
                        font-weight: bold;
                        font-size: 20px;
                        text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
                    ">${player.secureCredits.toLocaleString()}</span>
                </div>`;
            }

            html += '</div></div>'; // Close leaderboard div and main flex container
            document.getElementById('leaderboardContent').innerHTML = html;
        }

        // Exit practice mode
        function exitPracticeMode() {
            practiceMode.active = false;
            document.getElementById('practiceCanvas').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('practiceBackBtn').style.display = 'none';
            initMainMenu();
        }

        // Screen management
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        function showSettings() {
            showScreen('settingsScreen');
        }

        function logout() {
            auth.signOut().then(() => {
                // Redirect to login page
                window.location.reload();
            }).catch((error) => {
                console.error('Error logging out:', error);
                alert('Error logging out. Please try again.');
            });
        }

        function backToMainMenu() {
            // Clean up listeners
            if (currentPartyId) {
                database.ref('parties/' + currentPartyId).off();
            }
            if (currentLobbyId) {
                database.ref('lobbies/' + currentLobbyId).off();
            }

            currentPartyId = null;
            currentLobbyId = null;
            practiceMode.active = false;
            raceState.active = false;

            // Hide all screens
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('practiceCanvas').style.display = 'none';
            document.getElementById('raceCanvas').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('practiceBackBtn').style.display = 'none';
            document.getElementById('timer').style.display = 'none';
            document.getElementById('racePositions').style.display = 'none';

            // Show main menu
            initMainMenu();
        }

        // Keyboard handling
        document.addEventListener('keydown', (e) => {
            // G key resets zoom in all modes
            if (e.key === 'g' || e.key === 'G') {
                baseZoom = 1;
                practiceZoom = 1;
                menuZoom = 1;
            }

            // Store both original key and lowercase for compatibility
            menuKeys[e.key] = true;
            menuKeys[e.key.toLowerCase()] = true;
            practiceMode.keys[e.key] = true;
            raceState.keys[e.key] = true;
            baseKeys[e.key] = true;
            baseKeys[e.key.toLowerCase()] = true;
            levelSelectKeys[e.key] = true;
            levelSelectKeys[e.key.toLowerCase()] = true;

            if (e.key === 'Escape') {
                if (practiceMode.active) {
                    exitPracticeMode();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            menuKeys[e.key] = false;
            menuKeys[e.key.toLowerCase()] = false;
            baseKeys[e.key] = false;
            baseKeys[e.key.toLowerCase()] = false;
            levelSelectKeys[e.key] = false;
            levelSelectKeys[e.key.toLowerCase()] = false;
            delete practiceMode.keys[e.key];
            delete raceState.keys[e.key];
        });

        // Initialize on auth
        auth.onAuthStateChanged(async (user) => {
            if (!user) {
                window.location.href = 'index.html';
            } else {
                currentUser = user;

                // Get username
                const userSnapshot = await database.ref('users/' + user.uid).once('value');
                const userData = userSnapshot.val();

                if (userData && userData.username) {
                    currentUsername = userData.username;
                } else {
                    currentUsername = user.email.split('@')[0];
                    await database.ref('users/' + user.uid).set({
                        username: currentUsername,
                        createdAt: firebase.database.ServerValue.TIMESTAMP
                    });
                }

                await initUserData();
                await initializeDefaultLevels();
                initMainMenu();
            }
        });
    </script>
</body>
</html>