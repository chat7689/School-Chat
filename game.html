<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Racers Online</title>
    <link rel="icon" type="image/png" id="favicon">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #2c2c2c;
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        canvas {
            border: 5px solid #333;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            background: #87CEEB;
        }

        .screen {
            display: none;
            position: absolute;
            background: rgba(0,0,0,0.95);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 100;
        }

        .screen.active {
            display: block;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #FFC107;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }

        h2 {
            font-size: 32px;
            margin: 20px 0;
            color: #4facfe;
        }

        button {
            padding: 15px 30px;
            font-size: 18px;
            margin: 10px;
            background: #4facfe;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: #6fd0ff;
            transform: scale(1.05);
        }

        button.secondary {
            background: #666;
        }

        button.danger {
            background: rgba(255,0,0,0.7);
        }

        button.success {
            background: #4CAF50;
        }

        input, select {
            padding: 12px;
            font-size: 16px;
            margin: 10px;
            border-radius: 8px;
            border: 2px solid #4facfe;
            background: rgba(255,255,255,0.9);
        }

        .cosmetic-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            margin: 10px;
            border-radius: 10px;
            display: inline-block;
            min-width: 200px;
        }

        .cosmetic-item.owned {
            border: 2px solid #4facfe;
        }

        .cosmetic-item.equipped {
            background: rgba(79, 172, 254, 0.3);
            border: 2px solid #FFC107;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            z-index: 50;
            display: none;
        }

        #timer {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            z-index: 50;
            display: none;
            font-family: 'Courier New', monospace;
        }

        .party-member {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            margin: 5px;
            border-radius: 5px;
        }

        .party-member.ready {
            background: rgba(0,255,0,0.2);
            border: 2px solid #0f0;
        }

        .invitation {
            background: rgba(255,255,0,0.2);
            padding: 15px;
            margin: 10px;
            border-radius: 10px;
            border: 2px solid #FFC107;
        }

        .platform-button {
            position: absolute;
            background: rgba(79, 172, 254, 0.3);
            border: 3px solid #4facfe;
            color: #4facfe;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
        }

        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            color: white;
            text-shadow: 5px 5px 10px rgba(0,0,0,0.9);
            z-index: 200;
            display: none;
            font-weight: bold;
        }

        .player-list {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
        }

        .shop-category {
            margin: 20px 0;
        }

        .cosmetics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
        }

        #menuCanvas {
            display: block;
        }

        .menu-hud {
            position: absolute;
            top: 20px;
            text-align: center;
            width: 100%;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            z-index: 10;
            pointer-events: none;
        }

        .menu-title {
            font-size: 64px;
            color: #FFC107;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .scroll-container {
            max-height: 60vh;
            overflow-y: auto;
            padding: 20px;
        }

        #raceResults {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 20px;
            z-index: 200;
            display: none;
            min-width: 400px;
        }

        .result-entry {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        .result-entry.winner {
            background: rgba(255,215,0,0.3);
            border: 2px solid gold;
        }

        #racePositions {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            z-index: 50;
            display: none;
        }
    </style>
</head>
<body>
    <!-- Main Menu Canvas (Interactive Platformer) -->
    <canvas id="menuCanvas" width="1200" height="800"></canvas>
    <div class="menu-hud" id="menuHUD" style="display: none;">
        <div class="menu-title">BLOCK RACERS ONLINE</div>
        <div id="menuUserInfo"></div>
    </div>

    <!-- Practice Mode Canvas -->
    <canvas id="practiceCanvas" width="1200" height="800" style="display: none;"></canvas>
    <div id="hud"></div>

    <!-- Race Canvas -->
    <canvas id="raceCanvas" width="1200" height="800" style="display: none;"></canvas>
    <div id="timer"></div>
    <div id="racePositions"></div>
    <div id="countdown"></div>

    <!-- Party Screen -->
    <div id="partyScreen" class="screen">
        <h1>Party</h1>
        <div id="partyInfo"></div>
        <div id="partyMembers" class="player-list"></div>
        <div id="partyInvitations"></div>
        <div style="margin-top: 20px;">
            <input type="text" id="inviteUsername" placeholder="Enter username to invite">
            <button onclick="sendInvite()">Send Invite</button>
        </div>
        <div id="partyControls" style="margin-top: 20px;"></div>
        <button onclick="leaveParty()" class="secondary">Leave Party</button>
        <button onclick="backToMainMenu()" class="secondary">Back to Menu</button>
    </div>

    <!-- Join Party Screen -->
    <div id="joinPartyScreen" class="screen">
        <h1>Join Party</h1>
        <input type="text" id="partyIdInput" placeholder="Enter Party ID">
        <button onclick="joinPartyById()">Join Party</button>
        <button onclick="backToMainMenu()" class="secondary">Back</button>
    </div>

    <!-- Lobby Screen -->
    <div id="lobbyScreen" class="screen">
        <h1>Race Lobby</h1>
        <div id="lobbyInfo"></div>
        <div id="lobbyPlayers" class="player-list"></div>
        <div id="lobbyControls"></div>
        <button onclick="leaveLobby()" class="secondary">Leave Lobby</button>
    </div>

    <!-- Cosmetic Shop Screen -->
    <div id="shopScreen" class="screen">
        <h1>Cosmetic Shop</h1>
        <div id="shopCredits" style="font-size: 24px; color: #FFC107; margin-bottom: 20px;"></div>
        <div class="scroll-container">
            <div id="shopContent"></div>
        </div>
        <button onclick="backToMainMenu()">Back to Menu</button>
    </div>

    <!-- Stats Screen -->
    <div id="statsScreen" class="screen">
        <h1>Your Stats</h1>
        <div id="statsContent" style="font-size: 20px;"></div>
        <button onclick="backToMainMenu()">Back to Menu</button>
    </div>

    <!-- Base Screen -->
    <div id="baseScreen" class="screen">
        <h1>Your Base</h1>
        <div id="baseCredits" style="font-size: 24px; color: #FFC107; margin-bottom: 20px;"></div>
        <canvas id="baseCanvas" width="800" height="600" style="border: 3px solid #4facfe; border-radius: 10px;"></canvas>
        <div style="margin-top: 20px;">
            <p>Click on the grid to place 40x40px blocks (costs 1 credit each)</p>
            <p>Right-click to remove blocks (refunds 1 credit)</p>
        </div>
        <button onclick="backToMainMenu()">Back to Menu</button>
    </div>

    <!-- Leaderboard Screen -->
    <div id="leaderboardScreen" class="screen">
        <h1>Credits Leaderboard</h1>
        <div class="scroll-container">
            <div id="leaderboardContent" style="max-width: 600px; margin: 0 auto;"></div>
        </div>
        <button onclick="backToMainMenu()">Back to Menu</button>
    </div>

    <!-- Race Results -->
    <div id="raceResults">
        <h2>Race Complete!</h2>
        <div id="resultsContent"></div>
        <button onclick="returnToParty()" class="success">Return to Party</button>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBLkFMipRS631fDNr8uwgozmxXBnqLd5_o",
            authDomain: "base-control-b391e.firebaseapp.com",
            databaseURL: "https://base-control-b391e-default-rtdb.firebaseio.com",
            projectId: "base-control-b391e",
            storageBucket: "base-control-b391e.firebasestorage.app",
            messagingSenderId: "116375376675",
            appId: "1:116375376675:web:cdc8688222c7c35accf296",
            measurementId: "G-JY7P6D49HM"
        };

        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const database = firebase.database();

        // Create favicon
        const faviconCanvas = document.createElement('canvas');
        faviconCanvas.width = 32;
        faviconCanvas.height = 32;
        const faviconCtx = faviconCanvas.getContext('2d');
        faviconCtx.fillStyle = '#FF8C42';
        faviconCtx.fillRect(6, 6, 20, 20);
        faviconCtx.strokeStyle = '#333';
        faviconCtx.lineWidth = 2;
        faviconCtx.strokeRect(6, 6, 20, 20);
        document.getElementById('favicon').href = faviconCanvas.toDataURL('image/png');

        // Global variables
        let currentUser = null;
        let currentUsername = '';
        let userCredits = 0;
        let userCosmetics = { skins: ['default_orange'], trails: ['none'], hats: ['none'], effects: ['none'] };
        let equippedCosmetics = { skin: 'default_orange', trail: 'none', hat: 'none', effect: 'none' };
        let userStats = { racesWon: 0, racesPlayed: 0, totalCreditsEarned: 0 };

        let currentParty = null;
        let currentPartyId = null;
        let currentLobby = null;
        let currentLobbyId = null;

        // Jump state tracking
        let menuIsJumping = false;
        let practiceIsJumping = false;
        let raceIsJumping = false;

        // Game constants
        const GRAVITY = 0.042;
        const MOVE_SPEED = 0.28;
        const MAX_SPEED = 3.5;
        const AIR_RESISTANCE = 0.88;
        const GROUND_FRICTION = 0.94;
        const JUMP_POWER = 3.70;
        const FAST_FALL_MULTIPLIER = 2.0;

        // Cosmetics catalog
        const cosmeticsCatalog = {
            skins: [
                { id: 'default_orange', name: 'Default Orange', price: 0, color: '#FF8C42' },
                { id: 'red_racer', name: 'Red Racer', price: 50, color: '#FF0000' },
                { id: 'blue_blur', name: 'Blue Blur', price: 50, color: '#0066FF' },
                { id: 'green_machine', name: 'Green Machine', price: 100, color: '#00FF00' },
                { id: 'purple_pro', name: 'Purple Pro', price: 100, color: '#9900FF' },
                { id: 'golden_champion', name: 'Golden Champion', price: 500, color: '#FFD700' }
            ],
            trails: [
                { id: 'none', name: 'None', price: 0 },
                { id: 'rainbow', name: 'Rainbow Trail', price: 100 },
                { id: 'fire', name: 'Fire Trail', price: 150 },
                { id: 'ice', name: 'Ice Trail', price: 150 },
                { id: 'star', name: 'Star Trail', price: 200 }
            ],
            hats: [
                { id: 'none', name: 'None', price: 0 },
                { id: 'crown', name: 'Crown', price: 200 },
                { id: 'propeller', name: 'Propeller', price: 150 },
                { id: 'halo', name: 'Halo', price: 300 }
            ],
            effects: [
                { id: 'none', name: 'None', price: 0 },
                { id: 'sparkles', name: 'Sparkles', price: 100 },
                { id: 'glow', name: 'Glow', price: 150 },
                { id: 'shadow_clone', name: 'Shadow Clone', price: 300 }
            ]
        };

        // Map definitions (preserved from original)
        const maps = [
            {
                id: 'simple_map',
                name: 'Simple Map',
                difficulty: 'Easy',
                platforms: [
                    { x: -40, y: -280, width: 40, height: 320 },
                    { x: 0, y: -280, width: 280, height: 40 },
                    { x: 280, y: -280, width: 40, height: 320 },
                    { x: 0, y: 0, width: 280, height: 40 }
                ],
                hazards: [
                    { x: 120, y: -120, width: 40, height: 120 }
                ],
                growers: [],
                shrinkers: [],
                defaultSizeBlocks: [],
                start: { x: 0, y: -40, width: 40, height: 40 },
                finish: { x: 240, y: -40, width: 40, height: 40 }
            },
            {
                id: 'custom_level',
                name: 'Original Map',
                difficulty: 'Medium',
                platforms: [
                    { x: 0, y: 400, width: 40, height: 200 },
                    { x: 40, y: 560, width: 520, height: 40 },
                    { x: 240, y: 440, width: 80, height: 40 },
                    { x: 320, y: 320, width: 80, height: 40 },
                    { x: 240, y: 200, width: 80, height: 40 },
                    { x: 320, y: 80, width: 80, height: 40 },
                    { x: 160, y: -80, width: 360, height: 40 },
                    { x: 480, y: -40, width: 40, height: 480 },
                    { x: -240, y: 160, width: 400, height: 40 },
                    { x: -80, y: 40, width: 40, height: 160 },
                    { x: -160, y: -80, width: 320, height: 40 },
                    { x: -200, y: -80, width: 40, height: 200 },
                    { x: -320, y: 80, width: 120, height: 40 },
                    { x: -320, y: 120, width: 40, height: 240 },
                    { x: -240, y: 480, width: 40, height: 40 },
                    { x: 0, y: 720, width: 40, height: 40 },
                    { x: 160, y: 720, width: 40, height: 40 },
                    { x: 560, y: 320, width: 40, height: 280 },
                    { x: 160, y: 40, width: 80, height: 40 },
                    { x: 440, y: 680, width: 40, height: 40 },
                    { x: 600, y: 520, width: 240, height: 40 },
                    { x: 480, y: 640, width: 440, height: 40 },
                    { x: 920, y: 320, width: 40, height: 360 },
                    { x: 600, y: 320, width: 320, height: 40 },
                    { x: 320, y: 760, width: 120, height: 40 }
                ],
                hazards: [
                    { x: 200, y: 80, width: 40, height: 80 },
                    { x: 0, y: 360, width: 40, height: 40 },
                    { x: -520, y: 800, width: 1560, height: 80 }
                ],
                growers: [],
                shrinkers: [],
                defaultSizeBlocks: [],
                start: { x: 80, y: 480 },
                finish: { x: 700, y: 470, width: 100, height: 50 }
            },
            {
                id: 'hard_level',
                name: 'Hard Level',
                difficulty: 'Hard',
                platforms: [
                    { x: 40, y: -200, width: 240, height: 30 },
                    { x: 40, y: -170, width: 80, height: 30 },
                    { x: 200, y: -170, width: 80, height: 30 },
                    { x: -280, y: -410, width: 60, height: 90 },
                    { x: -280, y: -260, width: 60, height: 20 },
                    { x: -280, y: -120, width: 40, height: 40 },
                    { x: -200, y: -40, width: 40, height: 40 },
                    { x: 560, y: -400, width: 240, height: 80 },
                    { x: 400, y: -640, width: 160, height: 80 },
                    { x: 560, y: -800, width: 80, height: 80 },
                    { x: 240, y: -1040, width: 160, height: 80 },
                    { x: -80, y: 0, width: 115, height: 40 },
                    { x: 340, y: 20, width: 180, height: 20 },
                    { x: 360, y: 0, width: 160, height: 20 },
                    { x: 40, y: 100, width: 100, height: 20 },
                    { x: 160, y: 140, width: 80, height: 20 },
                    { x: 260, y: 80, width: 60, height: 20 },
                    { x: 320, y: -80, width: 20, height: 80 },
                    { x: 520, y: -120, width: 160, height: 40 },
                    { x: 640, y: -80, width: 40, height: 120 },
                    { x: 520, y: 0, width: 120, height: 40 }
                ],
                hazards: [
                    { x: 40, y: -320, width: 80, height: 120 },
                    { x: -80, y: -200, width: 40, height: 200 },
                    { x: 240, y: -1120, width: 80, height: 80 },
                    { x: -360, y: 280, width: 1280, height: 40 },
                    { x: 920, y: -1280, width: 40, height: 1600 },
                    { x: -360, y: -1280, width: 1280, height: 40 },
                    { x: -400, y: -1280, width: 40, height: 1600 }
                ],
                growers: [
                    { x: 80, y: -640, width: 80, height: 80 }
                ],
                shrinkers: [
                    { x: 80, y: -1200, width: 80, height: 80 }
                ],
                defaultSizeBlocks: [
                    { x: 520, y: -80, width: 40, height: 80 }
                ],
                start: { x: 0, y: -80, width: 40, height: 40 },
                finish: { x: 600, y: -80, width: 40, height: 80 }
            }
        ];

        // Player class for rendering
        class Player {
            constructor(x, y, cosmetics) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.velocityX = 0;
                this.velocityY = 0;
                this.cosmetics = cosmetics || { skin: 'default_orange', trail: 'none', hat: 'none', effect: 'none' };
                this.trail = [];
                this.currentSize = 40;
            }

            getSkinColor() {
                const skin = cosmeticsCatalog.skins.find(s => s.id === this.cosmetics.skin);
                return skin ? skin.color : '#FF8C42';
            }

            updateTrail() {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 10) {
                    this.trail.shift();
                }
            }

            draw(ctx, cameraX, cameraY, showName, name) {
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;

                // Draw trail
                if (this.cosmetics.trail !== 'none' && this.trail.length > 1) {
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const alpha = i / this.trail.length;
                        const trailX = this.trail[i].x - cameraX;
                        const trailY = this.trail[i].y - cameraY;

                        ctx.globalAlpha = alpha * 0.5;

                        if (this.cosmetics.trail === 'rainbow') {
                            ctx.fillStyle = `hsl(${(i * 36) % 360}, 100%, 50%)`;
                        } else if (this.cosmetics.trail === 'fire') {
                            ctx.fillStyle = i % 2 === 0 ? '#FF6600' : '#FF0000';
                        } else if (this.cosmetics.trail === 'ice') {
                            ctx.fillStyle = i % 2 === 0 ? '#00FFFF' : '#FFFFFF';
                        } else if (this.cosmetics.trail === 'star') {
                            ctx.fillStyle = '#FFFF00';
                        }

                        ctx.fillRect(trailX, trailY, this.width, this.height);
                    }
                    ctx.restore();
                }

                // Draw effect (behind player)
                if (this.cosmetics.effect === 'glow') {
                    ctx.save();
                    ctx.shadowColor = this.getSkinColor();
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = this.getSkinColor();
                    ctx.fillRect(screenX, screenY, this.width, this.height);
                    ctx.restore();
                } else if (this.cosmetics.effect === 'shadow_clone') {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = this.getSkinColor();
                    ctx.fillRect(screenX - 10, screenY + 5, this.width, this.height);
                    ctx.restore();
                }

                // Draw player
                ctx.fillStyle = this.getSkinColor();
                ctx.fillRect(screenX, screenY, this.width, this.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX, screenY, this.width, this.height);

                // Draw hat
                if (this.cosmetics.hat === 'crown') {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(screenX + this.width / 2, screenY - 15);
                    ctx.lineTo(screenX + 5, screenY - 5);
                    ctx.lineTo(screenX + this.width - 5, screenY - 5);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.cosmetics.hat === 'propeller') {
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(screenX + 10, screenY - 10);
                    ctx.lineTo(screenX + this.width - 10, screenY - 10);
                    ctx.stroke();
                } else if (this.cosmetics.hat === 'halo') {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, screenY - 10, 15, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw sparkles effect
                if (this.cosmetics.effect === 'sparkles') {
                    ctx.fillStyle = '#FFFF00';
                    for (let i = 0; i < 5; i++) {
                        const angle = (Date.now() / 100 + i * 72) % 360;
                        const rad = angle * Math.PI / 180;
                        const sparkX = screenX + this.width / 2 + Math.cos(rad) * 30;
                        const sparkY = screenY + this.height / 2 + Math.sin(rad) * 30;
                        ctx.fillRect(sparkX - 2, sparkY - 2, 4, 4);
                    }
                }

                // Draw name
                if (showName && name) {
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(name, screenX + this.width / 2, screenY - 10);
                }
            }
        }

        // Initialize user data
        async function initUserData() {
            if (!currentUser) return;

            const userRef = database.ref('players/' + currentUser.uid);
            const snapshot = await userRef.once('value');
            const data = snapshot.val();

            if (data) {
                userCredits = data.credits || 0;
                userCosmetics = data.cosmetics || { skins: ['default_orange'], trails: ['none'], hats: ['none'], effects: ['none'] };
                equippedCosmetics = data.equippedCosmetics || { skin: 'default_orange', trail: 'none', hat: 'none', effect: 'none' };
                userStats = data.stats || { racesWon: 0, racesPlayed: 0, totalCreditsEarned: 0 };
            } else {
                // Initialize new user
                await userRef.set({
                    username: currentUsername,
                    credits: 0,
                    cosmetics: userCosmetics,
                    equippedCosmetics: equippedCosmetics,
                    stats: userStats
                });
            }
        }

        // Update credits in Firebase
        async function updateCredits(amount) {
            userCredits += amount;
            if (amount > 0) {
                userStats.totalCreditsEarned += amount;
            }
            await database.ref('players/' + currentUser.uid).update({
                credits: userCredits,
                stats: userStats
            });
        }

        // Main menu (interactive platformer)
        let menuPlayer = null;
        let menuKeys = {};
        let menuPlatforms = [];
        let menuCameraX = 0;
        let menuCameraY = 0;

        function initMainMenu() {
            const canvas = document.getElementById('menuCanvas');
            const ctx = canvas.getContext('2d');

            canvas.style.display = 'block';
            document.getElementById('menuHUD').style.display = 'block';
            document.getElementById('menuUserInfo').innerHTML = `
                ${currentUsername} | Credits: ${userCredits}
            `;

            // Create menu platforms with labels
            menuPlatforms = [
                { x: 100, y: 600, width: 200, height: 60, label: 'PRACTICE MODE', action: 'practice' },
                { x: 400, y: 500, width: 200, height: 60, label: 'CREATE PARTY', action: 'createParty' },
                { x: 700, y: 450, width: 200, height: 60, label: 'JOIN PARTY', action: 'joinParty' },
                { x: 250, y: 350, width: 200, height: 60, label: 'COSMETIC SHOP', action: 'shop' },
                { x: 600, y: 300, width: 180, height: 60, label: 'VIEW STATS', action: 'stats' },
                { x: 100, y: 200, width: 200, height: 60, label: 'LEVEL CREATOR', action: 'creator' },
                { x: 400, y: 150, width: 160, height: 60, label: 'BASE', action: 'base' },
                { x: 650, y: 100, width: 200, height: 60, label: 'LEADERBOARD', action: 'leaderboard' },
                { x: 0, y: 720, width: 1200, height: 80, label: '', action: 'none' }, // Ground
                // Left wall - 100 blocks high (4000px)
                { x: -40, y: -3280, width: 40, height: 4000, label: '', action: 'none' },
                // Right wall - 100 blocks high (4000px)
                { x: 1200, y: -3280, width: 40, height: 4000, label: '', action: 'none' }
            ];

            // Spawn player in center of screen on the ground platform
            menuPlayer = new Player(600 - 20, 720 - 40, equippedCosmetics);

            // Game loop with delta time
            let lastMenuFrameTime = performance.now();
            function menuLoop(currentTime) {
                if (canvas.style.display === 'none') return;

                // Calculate delta time (normalize to 60fps baseline)
                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastMenuFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1; // Clamp deltaTime
                lastMenuFrameTime = currentTime;

                // Update player physics
                updateMenuPlayer(deltaTime);

                // Render
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw platforms
                for (const platform of menuPlatforms) {
                    const screenX = platform.x - menuCameraX;
                    const screenY = platform.y - menuCameraY;

                    if (platform.label) {
                        // Gradient background for platform buttons
                        const gradient = ctx.createLinearGradient(screenX, screenY, screenX, screenY + platform.height);
                        gradient.addColorStop(0, 'rgba(79, 172, 254, 0.5)');
                        gradient.addColorStop(1, 'rgba(79, 172, 254, 0.2)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);

                        // Glowing border
                        ctx.shadowColor = '#4facfe';
                        ctx.shadowBlur = 15;
                        ctx.strokeStyle = '#4facfe';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(screenX, screenY, platform.width, platform.height);
                        ctx.shadowBlur = 0;

                        // Text with shadow
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = 'rgba(0,0,0,0.5)';
                        ctx.shadowBlur = 5;
                        ctx.fillText(platform.label, screenX + platform.width / 2, screenY + platform.height / 2 + 5);
                        ctx.shadowBlur = 0;
                    } else {
                        // Green platform
                        ctx.fillStyle = '#00AA00';
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);

                        // Draw 40x40 grid lines
                        ctx.strokeStyle = '#006600';
                        ctx.lineWidth = 1;
                        for (let gx = 0; gx < platform.width; gx += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX + gx, screenY);
                            ctx.lineTo(screenX + gx, screenY + platform.height);
                            ctx.stroke();
                        }
                        for (let gy = 0; gy < platform.height; gy += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY + gy);
                            ctx.lineTo(screenX + platform.width, screenY + gy);
                            ctx.stroke();
                        }
                    }
                }

                // Draw player
                menuPlayer.updateTrail();
                menuPlayer.draw(ctx, menuCameraX, menuCameraY, false);

                requestAnimationFrame(menuLoop);
            }

            menuLoop();
        }

        function updateMenuPlayer(deltaTime = 1) {
            // Check current grounded state BEFORE applying physics
            let isGrounded = false;
            for (const platform of menuPlatforms) {
                if (checkCollision(menuPlayer, platform)) {
                    const overlap = (menuPlayer.y + menuPlayer.height) - platform.y;
                    if (overlap > 0 && overlap < 10 && menuPlayer.velocityY >= 0) {
                        isGrounded = true;
                        break;
                    }
                }
            }

            // Apply gravity with fast fall
            if ((menuKeys['s'] || menuKeys['ArrowDown']) && !isGrounded) {
                menuPlayer.velocityY += GRAVITY * FAST_FALL_MULTIPLIER * deltaTime;
            } else {
                menuPlayer.velocityY += GRAVITY * deltaTime;
            }

            // Handle input
            if (menuKeys['a'] || menuKeys['ArrowLeft']) {
                menuPlayer.velocityX -= MOVE_SPEED * deltaTime;
            }
            if (menuKeys['d'] || menuKeys['ArrowRight']) {
                menuPlayer.velocityX += MOVE_SPEED * deltaTime;
            }

            // Jump with variable height (W or Up Arrow only, NOT space)
            if ((menuKeys['w'] || menuKeys['ArrowUp']) && isGrounded) {
                menuPlayer.velocityY = -JUMP_POWER;
                menuIsJumping = true;
            }

            // Cut jump short if button released (variable jump height)
            if (menuIsJumping && !menuKeys['w'] && !menuKeys['ArrowUp']) {
                if (menuPlayer.velocityY < 0) {
                    menuPlayer.velocityY *= 0.5;
                }
                menuIsJumping = false;
            }

            // Reset jump state when grounded
            if (isGrounded && menuPlayer.velocityY >= 0) {
                menuIsJumping = false;
            }

            // Apply friction using exponential decay
            if (isGrounded) {
                menuPlayer.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                menuPlayer.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Limit speed
            menuPlayer.velocityX = Math.max(-MAX_SPEED, Math.min(MAX_SPEED, menuPlayer.velocityX));

            // Update position HORIZONTALLY first, then check X collisions
            menuPlayer.x += menuPlayer.velocityX * deltaTime;

            // Check horizontal collisions
            for (const platform of menuPlatforms) {
                if (checkCollision(menuPlayer, platform)) {
                    if (menuPlayer.velocityX > 0) {
                        // Moving right, hit left side of platform
                        menuPlayer.x = platform.x - menuPlayer.width;
                    } else if (menuPlayer.velocityX < 0) {
                        // Moving left, hit right side of platform
                        menuPlayer.x = platform.x + platform.width;
                    }
                    menuPlayer.velocityX = 0;
                }
            }

            // Update position VERTICALLY, then check Y collisions
            menuPlayer.y += menuPlayer.velocityY * deltaTime;

            // Check vertical collisions
            for (const platform of menuPlatforms) {
                if (checkCollision(menuPlayer, platform)) {
                    if (menuPlayer.velocityY > 0) {
                        // Moving down, hit top of platform
                        menuPlayer.y = platform.y - menuPlayer.height;
                        menuPlayer.velocityY = 0;

                        // Check for platform interaction (space key)
                        if (platform.action && platform.action !== 'none' && menuKeys[' ']) {
                            executePlatformAction(platform.action);
                        }
                    } else if (menuPlayer.velocityY < 0) {
                        // Moving up, hit bottom of platform
                        menuPlayer.y = platform.y + platform.height;
                        menuPlayer.velocityY = 0;
                        menuIsJumping = false;
                    }
                }
            }

            // Keep player in bounds (but allow vertical movement)
            if (menuPlayer.x < 0) menuPlayer.x = 0;
            if (menuPlayer.x > 1200 - menuPlayer.width) menuPlayer.x = 1200 - menuPlayer.width;

            // Respawn if fall too far
            if (menuPlayer.y > 1500) {
                menuPlayer.x = 600 - 20;
                menuPlayer.y = 720 - 40;
                menuPlayer.velocityX = 0;
                menuPlayer.velocityY = 0;
            }

            // Update camera to follow player
            menuCameraX = menuPlayer.x - 600 + 20; // Center horizontally
            menuCameraY = menuPlayer.y - 400 + 20; // Center vertically
        }

        function checkCollision(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

        function executePlatformAction(action) {
            document.getElementById('menuCanvas').style.display = 'none';
            document.getElementById('menuHUD').style.display = 'none';

            switch(action) {
                case 'practice':
                    startPracticeMode();
                    break;
                case 'createParty':
                    createParty();
                    break;
                case 'joinParty':
                    showScreen('joinPartyScreen');
                    break;
                case 'shop':
                    showShop();
                    break;
                case 'stats':
                    showStats();
                    break;
                case 'creator':
                    window.location.href = 'creator.html';
                    break;
                case 'base':
                    showBase();
                    break;
                case 'leaderboard':
                    showLeaderboard();
                    break;
            }
        }

        // Practice mode (infinite runner with credit earning)
        let practiceMode = {
            active: false,
            player: null,
            platforms: [],
            platformsPassed: 0,
            lastPlatformX: 0,
            cameraX: 0,
            cameraY: 0,
            keys: {}
        };

        function startPracticeMode() {
            const canvas = document.getElementById('practiceCanvas');
            const ctx = canvas.getContext('2d');
            canvas.style.display = 'block';
            document.getElementById('hud').style.display = 'block';

            practiceMode.active = true;
            practiceMode.player = new Player(100, 300, equippedCosmetics);
            practiceMode.platforms = [];
            practiceMode.platformsPassed = 0;
            practiceMode.lastPlatformX = 0;

            // Generate initial platforms
            for (let i = 0; i < 20; i++) {
                generatePracticePlatform();
            }

            let lastPracticeFrameTime = performance.now();
            function practiceLoop(currentTime) {
                if (!practiceMode.active) return;

                // Calculate delta time
                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastPracticeFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                lastPracticeFrameTime = currentTime;

                // Update
                updatePracticePlayer(deltaTime);

                // Generate new platforms
                while (practiceMode.lastPlatformX < practiceMode.cameraX + 1500) {
                    generatePracticePlatform();
                }

                // Remove old platforms
                practiceMode.platforms = practiceMode.platforms.filter(p => p.x > practiceMode.cameraX - 200);

                // Update HUD
                document.getElementById('hud').innerHTML = `
                    Platforms: ${practiceMode.platformsPassed} | Credits: ${userCredits}
                `;

                // Render
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw platforms
                for (const platform of practiceMode.platforms) {
                    const screenX = platform.x - practiceMode.cameraX;
                    const screenY = platform.y - practiceMode.cameraY;

                    if (platform.isHazard) {
                        ctx.fillStyle = '#FF0000';
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);
                    } else {
                        // Green platform
                        ctx.fillStyle = '#00AA00';
                        ctx.fillRect(screenX, screenY, platform.width, platform.height);

                        // Draw 40x40 grid lines
                        ctx.strokeStyle = '#006600';
                        ctx.lineWidth = 1;
                        for (let gx = 0; gx < platform.width; gx += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX + gx, screenY);
                            ctx.lineTo(screenX + gx, screenY + platform.height);
                            ctx.stroke();
                        }
                        for (let gy = 0; gy < platform.height; gy += 40) {
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY + gy);
                            ctx.lineTo(screenX + platform.width, screenY + gy);
                            ctx.stroke();
                        }
                    }
                }

                // Draw player
                practiceMode.player.updateTrail();
                practiceMode.player.draw(ctx, practiceMode.cameraX, practiceMode.cameraY, false);

                requestAnimationFrame(practiceLoop);
            }

            practiceLoop();
        }

        function generatePracticePlatform() {
            const lastPlatform = practiceMode.platforms[practiceMode.platforms.length - 1];
            const baseX = lastPlatform ? lastPlatform.x + lastPlatform.width + Math.random() * 150 + 50 : 0;
            const baseY = lastPlatform ? lastPlatform.y + (Math.random() - 0.5) * 100 : 500;

            practiceMode.platforms.push({
                x: baseX,
                y: Math.max(200, Math.min(600, baseY)),
                width: 80 + Math.random() * 100,
                height: 40,
                isHazard: false
            });

            practiceMode.lastPlatformX = baseX;
        }

        function updatePracticePlayer(deltaTime = 1) {
            const player = practiceMode.player;

            // Check if grounded first
            let isGrounded = false;
            for (const platform of practiceMode.platforms) {
                if (checkCollision(player, platform)) {
                    if (player.velocityY > 0 && player.y + player.height <= platform.y + 10) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        isGrounded = true;

                        // Award credits every 20 platforms
                        if (!platform.counted) {
                            platform.counted = true;
                            practiceMode.platformsPassed++;
                            if (practiceMode.platformsPassed % 20 === 0) {
                                updateCredits(1);
                            }
                        }
                    }
                }
            }

            // Apply gravity with fast fall
            if ((practiceMode.keys['s'] || practiceMode.keys['ArrowDown']) && !isGrounded) {
                player.velocityY += GRAVITY * FAST_FALL_MULTIPLIER * deltaTime;
            } else {
                player.velocityY += GRAVITY * deltaTime;
            }

            // Handle input
            if (practiceMode.keys['a'] || practiceMode.keys['ArrowLeft']) {
                player.velocityX -= MOVE_SPEED * deltaTime;
            }
            if (practiceMode.keys['d'] || practiceMode.keys['ArrowRight']) {
                player.velocityX += MOVE_SPEED * deltaTime;
            }

            // Jump with variable height
            if ((practiceMode.keys['w'] || practiceMode.keys['ArrowUp'] || practiceMode.keys[' ']) && isGrounded) {
                player.velocityY = -JUMP_POWER;
                practiceIsJumping = true;
            }

            // Cut jump short if button released (variable jump height)
            if (practiceIsJumping && !practiceMode.keys['w'] && !practiceMode.keys['ArrowUp'] && !practiceMode.keys[' ']) {
                if (player.velocityY < 0) {
                    player.velocityY *= 0.5;
                }
                practiceIsJumping = false;
            }

            // Reset jump state when grounded
            if (isGrounded && player.velocityY >= 0) {
                practiceIsJumping = false;
            }

            // Apply friction using exponential decay
            if (isGrounded) {
                player.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                player.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Limit speed
            player.velocityX = Math.max(-MAX_SPEED, Math.min(MAX_SPEED, player.velocityX));

            // Update position
            player.x += player.velocityX * deltaTime;
            player.y += player.velocityY * deltaTime;

            // Die if fall off
            if (player.y > 1000) {
                player.x = 100;
                player.y = 300;
                player.velocityX = 0;
                player.velocityY = 0;
            }

            // Update camera
            practiceMode.cameraX = player.x - 300;
            practiceMode.cameraY = 0;
        }

        // Party system
        async function createParty() {
            const partyId = 'party_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            currentPartyId = partyId;

            await database.ref('parties/' + partyId).set({
                leaderId: currentUser.uid,
                members: {
                    [currentUser.uid]: {
                        username: currentUsername,
                        ready: false
                    }
                },
                invitations: {},
                createdAt: firebase.database.ServerValue.TIMESTAMP
            });

            listenToParty(partyId);
            showScreen('partyScreen');
        }

        function listenToParty(partyId) {
            database.ref('parties/' + partyId).on('value', (snapshot) => {
                const party = snapshot.val();
                if (!party) {
                    // Party was deleted
                    currentPartyId = null;
                    backToMainMenu();
                    return;
                }

                currentParty = party;
                updatePartyUI();
            });

            // Listen for invitations
            database.ref('parties/' + partyId + '/invitations/' + currentUser.uid).on('value', (snapshot) => {
                const invite = snapshot.val();
                if (invite && invite.status === 'pending') {
                    // Show invitation
                }
            });
        }

        function updatePartyUI() {
            if (!currentParty) return;

            const isLeader = currentParty.leaderId === currentUser.uid;

            document.getElementById('partyInfo').innerHTML = `
                <div style="font-size: 20px; color: #4facfe; margin-bottom: 10px;">
                    Party ID: <span style="color: #FFC107;">${currentPartyId}</span>
                </div>
                <div>Share this ID with friends to invite them!</div>
            `;

            let membersHTML = '<h3>Members:</h3>';
            for (const [uid, member] of Object.entries(currentParty.members || {})) {
                const readyBadge = member.ready ? ' [READY]' : '';
                const leaderBadge = uid === currentParty.leaderId ? ' [LEADER]' : '';
                membersHTML += `<div class="party-member ${member.ready ? 'ready' : ''}">${member.username}${leaderBadge}${readyBadge}</div>`;
            }
            document.getElementById('partyMembers').innerHTML = membersHTML;

            // Party controls
            if (isLeader) {
                const memberCount = Object.keys(currentParty.members || {}).length;
                const canStart = memberCount >= 2 && Object.values(currentParty.members).every(m => m.ready);
                document.getElementById('partyControls').innerHTML = `
                    <button onclick="toggleReady()">Toggle Ready</button>
                    <button onclick="startRaceLobby()" ${canStart ? '' : 'disabled'}>Start Race</button>
                `;
            } else {
                document.getElementById('partyControls').innerHTML = `
                    <button onclick="toggleReady()">Toggle Ready</button>
                `;
            }
        }

        async function sendInvite() {
            const username = document.getElementById('inviteUsername').value.trim();
            if (!username) return;

            // Find user by username
            const usersSnapshot = await database.ref('users').orderByChild('username').equalTo(username).once('value');
            const users = usersSnapshot.val();

            if (!users) {
                alert('User not found');
                return;
            }

            const userId = Object.keys(users)[0];

            await database.ref('parties/' + currentPartyId + '/invitations/' + userId).set({
                username: username,
                status: 'pending',
                from: currentUsername
            });

            document.getElementById('inviteUsername').value = '';
            alert('Invite sent!');
        }

        async function joinPartyById() {
            const partyId = document.getElementById('partyIdInput').value.trim();
            if (!partyId) return;

            const partySnapshot = await database.ref('parties/' + partyId).once('value');
            if (!partySnapshot.exists()) {
                alert('Party not found');
                return;
            }

            currentPartyId = partyId;
            await database.ref('parties/' + partyId + '/members/' + currentUser.uid).set({
                username: currentUsername,
                ready: false
            });

            listenToParty(partyId);
            showScreen('partyScreen');
        }

        async function toggleReady() {
            if (!currentPartyId) return;
            const currentReady = currentParty.members[currentUser.uid].ready;
            await database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid + '/ready').set(!currentReady);
        }

        async function leaveParty() {
            if (!currentPartyId) return;

            await database.ref('parties/' + currentPartyId + '/members/' + currentUser.uid).remove();

            // If leader, delete party
            if (currentParty.leaderId === currentUser.uid) {
                await database.ref('parties/' + currentPartyId).remove();
            }

            database.ref('parties/' + currentPartyId).off();
            currentPartyId = null;
            backToMainMenu();
        }

        // Lobby system
        async function startRaceLobby() {
            const lobbyId = 'lobby_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            currentLobbyId = lobbyId;

            // Move all party members to lobby
            const lobbyPlayers = {};
            for (const [uid, member] of Object.entries(currentParty.members)) {
                lobbyPlayers[uid] = {
                    username: member.username,
                    ready: false,
                    credits: 0 // Will be fetched
                };
            }

            await database.ref('lobbies/' + lobbyId).set({
                mapId: maps[0].id,
                betAmount: 0,
                players: lobbyPlayers,
                raceStarted: false,
                leaderId: currentParty.leaderId
            });

            // Notify all party members to join lobby
            for (const uid of Object.keys(currentParty.members)) {
                await database.ref('parties/' + currentPartyId + '/lobbyId').set(lobbyId);
            }

            listenToLobby(lobbyId);
            showScreen('lobbyScreen');
        }

        function listenToLobby(lobbyId) {
            database.ref('lobbies/' + lobbyId).on('value', (snapshot) => {
                const lobby = snapshot.val();
                if (!lobby) {
                    currentLobbyId = null;
                    backToMainMenu();
                    return;
                }

                currentLobby = lobby;

                if (lobby.raceStarted && lobby.raceStartTime) {
                    startMultiplayerRace();
                } else {
                    updateLobbyUI();
                }
            });
        }

        function updateLobbyUI() {
            if (!currentLobby) return;

            const isLeader = currentLobby.leaderId === currentUser.uid;

            // Map selection
            let mapOptions = '';
            for (const map of maps) {
                mapOptions += `<option value="${map.id}" ${currentLobby.mapId === map.id ? 'selected' : ''}>${map.name}</option>`;
            }

            document.getElementById('lobbyInfo').innerHTML = `
                <div>
                    <label>Map:</label>
                    <select id="lobbyMapSelect" onchange="updateLobbyMap()" ${isLeader ? '' : 'disabled'}>
                        ${mapOptions}
                    </select>
                </div>
                <div>
                    <label>Bet Amount:</label>
                    <input type="number" id="lobbyBetAmount" value="${currentLobby.betAmount}" min="0" max="1000" onchange="updateLobbyBet()" ${isLeader ? '' : 'readonly'}>
                </div>
            `;

            // Players
            let playersHTML = '<h3>Players:</h3>';
            for (const [uid, player] of Object.entries(currentLobby.players || {})) {
                const readyBadge = player.ready ? ' [READY]' : '';
                playersHTML += `<div class="party-member ${player.ready ? 'ready' : ''}">${player.username}${readyBadge}</div>`;
            }
            document.getElementById('lobbyPlayers').innerHTML = playersHTML;

            // Controls
            const allReady = Object.values(currentLobby.players).every(p => p.ready);
            if (isLeader) {
                document.getElementById('lobbyControls').innerHTML = `
                    <button onclick="toggleLobbyReady()">Toggle Ready</button>
                    <button onclick="startRace()" ${allReady ? '' : 'disabled'}>Start Race</button>
                `;
            } else {
                document.getElementById('lobbyControls').innerHTML = `
                    <button onclick="toggleLobbyReady()">Toggle Ready</button>
                `;
            }
        }

        async function updateLobbyMap() {
            const mapId = document.getElementById('lobbyMapSelect').value;
            await database.ref('lobbies/' + currentLobbyId + '/mapId').set(mapId);
        }

        async function updateLobbyBet() {
            const betAmount = parseInt(document.getElementById('lobbyBetAmount').value) || 0;
            await database.ref('lobbies/' + currentLobbyId + '/betAmount').set(betAmount);
        }

        async function toggleLobbyReady() {
            if (!currentLobbyId) return;
            const currentReady = currentLobby.players[currentUser.uid].ready;
            await database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid + '/ready').set(!currentReady);
        }

        async function startRace() {
            await database.ref('lobbies/' + currentLobbyId).update({
                raceStarted: true,
                raceStartTime: firebase.database.ServerValue.TIMESTAMP
            });
        }

        async function leaveLobby() {
            if (!currentLobbyId) return;
            database.ref('lobbies/' + currentLobbyId).off();
            await database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid).remove();
            currentLobbyId = null;
            backToMainMenu();
        }

        // Multiplayer racing
        let raceState = {
            active: false,
            player: null,
            opponents: {},
            map: null,
            startTime: 0,
            finishTime: 0,
            finished: false,
            cameraX: 0,
            cameraY: 0,
            keys: {},
            platforms: [],
            hazards: []
        };

        async function startMultiplayerRace() {
            const canvas = document.getElementById('raceCanvas');
            const ctx = canvas.getContext('2d');
            canvas.style.display = 'block';
            document.getElementById('timer').style.display = 'block';
            document.getElementById('racePositions').style.display = 'block';

            // Hide lobby screen
            document.getElementById('lobbyScreen').classList.remove('active');

            // Get map
            raceState.map = maps.find(m => m.id === currentLobby.mapId);
            raceState.platforms = raceState.map.platforms;
            raceState.hazards = raceState.map.hazards;

            // Create player at start position
            raceState.player = new Player(raceState.map.start.x, raceState.map.start.y, equippedCosmetics);
            raceState.active = true;
            raceState.finished = false;
            raceState.startTime = Date.now();

            // Countdown
            await showCountdown();

            // Listen for opponent positions
            database.ref('lobbies/' + currentLobbyId + '/players').on('value', (snapshot) => {
                const players = snapshot.val();
                raceState.opponents = {};
                for (const [uid, player] of Object.entries(players)) {
                    if (uid !== currentUser.uid && player.position) {
                        raceState.opponents[uid] = {
                            username: player.username,
                            player: new Player(player.position.x, player.position.y, player.equippedCosmetics || {}),
                            finished: player.finished || false
                        };
                    }
                }
            });

            // Start position sync
            const positionSyncInterval = setInterval(() => {
                if (!raceState.active || raceState.finished) {
                    clearInterval(positionSyncInterval);
                    return;
                }

                database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid).update({
                    position: { x: raceState.player.x, y: raceState.player.y },
                    velocity: { x: raceState.player.velocityX, y: raceState.player.velocityY },
                    equippedCosmetics: equippedCosmetics
                });
            }, 100);

            let lastRaceFrameTime = performance.now();
            function raceLoop(currentTime) {
                if (!raceState.active) return;

                // Calculate delta time
                if (!currentTime) currentTime = performance.now();
                let deltaTime = (currentTime - lastRaceFrameTime) / 16.67;
                if (deltaTime <= 0 || deltaTime > 10) deltaTime = 1;
                lastRaceFrameTime = currentTime;

                // Update
                updateRacePlayer(deltaTime);

                // Check finish
                if (!raceState.finished && checkCollision(raceState.player, raceState.map.finish)) {
                    finishRace();
                }

                // Update timer
                const elapsed = (Date.now() - raceState.startTime) / 1000;
                document.getElementById('timer').textContent = elapsed.toFixed(2);

                // Update positions
                updateRacePositions();

                // Render
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw platforms
                for (const platform of raceState.platforms) {
                    const screenX = platform.x - raceState.cameraX;
                    const screenY = platform.y - raceState.cameraY;

                    // Green platform
                    ctx.fillStyle = '#00AA00';
                    ctx.fillRect(screenX, screenY, platform.width, platform.height);

                    // Draw 40x40 grid lines
                    ctx.strokeStyle = '#006600';
                    ctx.lineWidth = 1;
                    for (let gx = 0; gx < platform.width; gx += 40) {
                        ctx.beginPath();
                        ctx.moveTo(screenX + gx, screenY);
                        ctx.lineTo(screenX + gx, screenY + platform.height);
                        ctx.stroke();
                    }
                    for (let gy = 0; gy < platform.height; gy += 40) {
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY + gy);
                        ctx.lineTo(screenX + platform.width, screenY + gy);
                        ctx.stroke();
                    }
                }

                // Draw hazards (red)
                for (const hazard of raceState.hazards) {
                    const screenX = hazard.x - raceState.cameraX;
                    const screenY = hazard.y - raceState.cameraY;
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(screenX, screenY, hazard.width, hazard.height);
                }

                // Draw finish line
                const finishScreenX = raceState.map.finish.x - raceState.cameraX;
                const finishScreenY = raceState.map.finish.y - raceState.cameraY;
                ctx.fillStyle = '#00FF00';
                ctx.fillRect(finishScreenX, finishScreenY, raceState.map.finish.width, raceState.map.finish.height);

                // Draw opponents
                for (const opponent of Object.values(raceState.opponents)) {
                    opponent.player.updateTrail();
                    opponent.player.draw(ctx, raceState.cameraX, raceState.cameraY, true, opponent.username);
                }

                // Draw local player
                raceState.player.updateTrail();
                raceState.player.draw(ctx, raceState.cameraX, raceState.cameraY, true, currentUsername);

                requestAnimationFrame(raceLoop);
            }

            raceLoop();
        }

        function updateRacePlayer(deltaTime = 1) {
            const player = raceState.player;

            // Check collisions first
            let isGrounded = false;
            for (const platform of raceState.platforms) {
                if (checkCollision(player, platform)) {
                    if (player.velocityY > 0 && player.y + player.height <= platform.y + 10) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        isGrounded = true;
                    }
                }
            }

            // Check hazards
            for (const hazard of raceState.hazards) {
                if (checkCollision(player, hazard)) {
                    // Reset to start
                    player.x = raceState.map.start.x;
                    player.y = raceState.map.start.y;
                    player.velocityX = 0;
                    player.velocityY = 0;
                    raceIsJumping = false;
                }
            }

            // Apply gravity with fast fall
            if ((raceState.keys['s'] || raceState.keys['ArrowDown']) && !isGrounded) {
                player.velocityY += GRAVITY * FAST_FALL_MULTIPLIER * deltaTime;
            } else {
                player.velocityY += GRAVITY * deltaTime;
            }

            // Handle input
            if (raceState.keys['a'] || raceState.keys['ArrowLeft']) {
                player.velocityX -= MOVE_SPEED * deltaTime;
            }
            if (raceState.keys['d'] || raceState.keys['ArrowRight']) {
                player.velocityX += MOVE_SPEED * deltaTime;
            }

            // Jump with variable height
            if ((raceState.keys['w'] || raceState.keys['ArrowUp'] || raceState.keys[' ']) && isGrounded) {
                player.velocityY = -JUMP_POWER;
                raceIsJumping = true;
            }

            // Cut jump short if button released (variable jump height)
            if (raceIsJumping && !raceState.keys['w'] && !raceState.keys['ArrowUp'] && !raceState.keys[' ']) {
                if (player.velocityY < 0) {
                    player.velocityY *= 0.5;
                }
                raceIsJumping = false;
            }

            // Reset jump state when grounded
            if (isGrounded && player.velocityY >= 0) {
                raceIsJumping = false;
            }

            // Apply friction using exponential decay
            if (isGrounded) {
                player.velocityX *= Math.pow(GROUND_FRICTION, deltaTime);
            } else {
                player.velocityX *= Math.pow(AIR_RESISTANCE, deltaTime);
            }

            // Limit speed
            player.velocityX = Math.max(-MAX_SPEED, Math.min(MAX_SPEED, player.velocityX));

            // Update position
            player.x += player.velocityX * deltaTime;
            player.y += player.velocityY * deltaTime;

            // Update camera
            raceState.cameraX = player.x - 400;
            raceState.cameraY = player.y - 300;
        }

        function updateRacePositions() {
            // Calculate positions based on distance to finish
            const finishX = raceState.map.finish.x;

            const positions = [
                { uid: currentUser.uid, username: currentUsername, distance: Math.abs(raceState.player.x - finishX), finished: raceState.finished }
            ];

            for (const [uid, opponent] of Object.entries(raceState.opponents)) {
                positions.push({
                    uid: uid,
                    username: opponent.username,
                    distance: Math.abs(opponent.player.x - finishX),
                    finished: opponent.finished
                });
            }

            positions.sort((a, b) => {
                if (a.finished && !b.finished) return -1;
                if (!a.finished && b.finished) return 1;
                return a.distance - b.distance;
            });

            let html = '<h3>Positions</h3>';
            for (let i = 0; i < positions.length; i++) {
                html += `<div>${i + 1}. ${positions[i].username}${positions[i].finished ? ' [FINISHED]' : ''}</div>`;
            }
            document.getElementById('racePositions').innerHTML = html;
        }

        async function finishRace() {
            raceState.finished = true;
            raceState.finishTime = Date.now() - raceState.startTime;

            await database.ref('lobbies/' + currentLobbyId + '/players/' + currentUser.uid).update({
                finished: true,
                finishTime: raceState.finishTime
            });

            // Check if all finished
            setTimeout(checkRaceComplete, 2000);
        }

        async function checkRaceComplete() {
            const snapshot = await database.ref('lobbies/' + currentLobbyId + '/players').once('value');
            const players = snapshot.val();

            const allFinished = Object.values(players).every(p => p.finished);

            if (allFinished) {
                // Calculate results
                const results = [];
                for (const [uid, player] of Object.entries(players)) {
                    results.push({
                        uid: uid,
                        username: player.username,
                        time: player.finishTime
                    });
                }

                results.sort((a, b) => a.time - b.time);

                // Award credits to winner
                if (results[0].uid === currentUser.uid) {
                    const pot = currentLobby.betAmount * Object.keys(players).length;
                    await updateCredits(pot);
                    userStats.racesWon++;
                }

                userStats.racesPlayed++;
                await database.ref('players/' + currentUser.uid + '/stats').set(userStats);

                // Show results
                showRaceResults(results);
            }
        }

        function showRaceResults(results) {
            let html = '';
            for (let i = 0; i < results.length; i++) {
                const isMe = results[i].uid === currentUser.uid;
                const isWinner = i === 0;
                html += `<div class="result-entry ${isWinner ? 'winner' : ''}" style="${isMe ? 'font-weight: bold; color: #4facfe;' : ''}">
                    ${i + 1}. ${results[i].username} - ${(results[i].time / 1000).toFixed(2)}s
                </div>`;
            }

            if (results[0].uid === currentUser.uid) {
                const pot = currentLobby.betAmount * results.length;
                html = `<div style="color: #FFD700; font-size: 24px; margin-bottom: 20px;">YOU WIN! +${pot} credits</div>` + html;
            }

            document.getElementById('resultsContent').innerHTML = html;
            document.getElementById('raceResults').style.display = 'block';
        }

        async function returnToParty() {
            document.getElementById('raceResults').style.display = 'none';
            document.getElementById('raceCanvas').style.display = 'none';
            document.getElementById('timer').style.display = 'none';
            document.getElementById('racePositions').style.display = 'none';

            raceState.active = false;
            database.ref('lobbies/' + currentLobbyId + '/players').off();

            await database.ref('lobbies/' + currentLobbyId).remove();

            showScreen('partyScreen');
        }

        async function showCountdown() {
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';

            for (let i = 3; i > 0; i--) {
                countdownEl.textContent = i;
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            countdownEl.textContent = 'GO!';
            await new Promise(resolve => setTimeout(resolve, 500));
            countdownEl.style.display = 'none';
        }

        // Cosmetic shop
        function showShop() {
            showScreen('shopScreen');
            updateShopUI();
        }

        function updateShopUI() {
            document.getElementById('shopCredits').textContent = `Credits: ${userCredits}`;

            let html = '';

            for (const [category, items] of Object.entries(cosmeticsCatalog)) {
                html += `<div class="shop-category">
                    <h2>${category.toUpperCase()}</h2>
                    <div class="cosmetics-grid">`;

                for (const item of items) {
                    const owned = userCosmetics[category].includes(item.id);
                    const equipped = equippedCosmetics[category === 'skins' ? 'skin' : category.slice(0, -1)] === item.id;

                    html += `<div class="cosmetic-item ${owned ? 'owned' : ''} ${equipped ? 'equipped' : ''}">
                        <div style="font-weight: bold;">${item.name}</div>
                        <div style="color: #FFC107;">${item.price} credits</div>`;

                    if (equipped) {
                        html += `<div style="color: #0f0; margin-top: 5px;">EQUIPPED</div>`;
                    } else if (owned) {
                        html += `<button onclick="equipCosmetic('${category}', '${item.id}')">Equip</button>`;
                    } else {
                        html += `<button onclick="buyCosmetic('${category}', '${item.id}', ${item.price})" ${userCredits >= item.price ? '' : 'disabled'}>Buy</button>`;
                    }

                    html += `</div>`;
                }

                html += `</div></div>`;
            }

            document.getElementById('shopContent').innerHTML = html;
        }

        async function buyCosmetic(category, itemId, price) {
            if (userCredits < price) {
                alert('Not enough credits!');
                return;
            }

            await updateCredits(-price);
            userCosmetics[category].push(itemId);
            await database.ref('players/' + currentUser.uid + '/cosmetics').set(userCosmetics);

            updateShopUI();
        }

        async function equipCosmetic(category, itemId) {
            const slot = category === 'skins' ? 'skin' : category.slice(0, -1);
            equippedCosmetics[slot] = itemId;
            await database.ref('players/' + currentUser.uid + '/equippedCosmetics').set(equippedCosmetics);

            updateShopUI();
        }

        // Stats screen
        function showStats() {
            showScreen('statsScreen');
            document.getElementById('statsContent').innerHTML = `
                <div style="margin: 20px 0;">Races Won: ${userStats.racesWon}</div>
                <div style="margin: 20px 0;">Races Played: ${userStats.racesPlayed}</div>
                <div style="margin: 20px 0;">Win Rate: ${userStats.racesPlayed > 0 ? ((userStats.racesWon / userStats.racesPlayed) * 100).toFixed(1) : 0}%</div>
                <div style="margin: 20px 0;">Total Credits Earned: ${userStats.totalCreditsEarned}</div>
            `;
        }

        // Base screen (build with credits)
        let baseBlocks = [];
        let baseCanvas, baseCtx;

        async function showBase() {
            showScreen('baseScreen');
            document.getElementById('baseCredits').textContent = `Credits: ${userCredits}`;

            baseCanvas = document.getElementById('baseCanvas');
            baseCtx = baseCanvas.getContext('2d');

            // Load base blocks from Firebase
            const baseSnapshot = await database.ref('players/' + currentUser.uid + '/baseBlocks').once('value');
            baseBlocks = baseSnapshot.val() || [];

            renderBase();

            // Add click handlers
            baseCanvas.onclick = handleBaseClick;
            baseCanvas.oncontextmenu = handleBaseRightClick;
        }

        function renderBase() {
            baseCtx.fillStyle = '#87CEEB';
            baseCtx.fillRect(0, 0, baseCanvas.width, baseCanvas.height);

            // Draw grid
            baseCtx.strokeStyle = '#ccc';
            baseCtx.lineWidth = 0.5;
            for (let x = 0; x <= baseCanvas.width; x += 40) {
                baseCtx.beginPath();
                baseCtx.moveTo(x, 0);
                baseCtx.lineTo(x, baseCanvas.height);
                baseCtx.stroke();
            }
            for (let y = 0; y <= baseCanvas.height; y += 40) {
                baseCtx.beginPath();
                baseCtx.moveTo(0, y);
                baseCtx.lineTo(baseCanvas.width, y);
                baseCtx.stroke();
            }

            // Draw placed blocks
            for (const block of baseBlocks) {
                baseCtx.fillStyle = '#00AA00';
                baseCtx.fillRect(block.x, block.y, 40, 40);
                baseCtx.strokeStyle = '#006600';
                baseCtx.lineWidth = 2;
                baseCtx.strokeRect(block.x, block.y, 40, 40);
            }
        }

        async function handleBaseClick(e) {
            const rect = baseCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Snap to grid
            const gridX = Math.floor(clickX / 40) * 40;
            const gridY = Math.floor(clickY / 40) * 40;

            // Check if block already exists
            const exists = baseBlocks.some(b => b.x === gridX && b.y === gridY);
            if (exists) {
                alert('Block already placed here!');
                return;
            }

            // Check if user has credits
            if (userCredits < 1) {
                alert('Not enough credits!');
                return;
            }

            // Place block
            baseBlocks.push({ x: gridX, y: gridY });
            await updateCredits(-1);
            await database.ref('players/' + currentUser.uid + '/baseBlocks').set(baseBlocks);

            document.getElementById('baseCredits').textContent = `Credits: ${userCredits}`;
            renderBase();
        }

        async function handleBaseRightClick(e) {
            e.preventDefault();

            const rect = baseCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Snap to grid
            const gridX = Math.floor(clickX / 40) * 40;
            const gridY = Math.floor(clickY / 40) * 40;

            // Find and remove block
            const index = baseBlocks.findIndex(b => b.x === gridX && b.y === gridY);
            if (index === -1) {
                alert('No block here!');
                return;
            }

            baseBlocks.splice(index, 1);
            await updateCredits(1);
            await database.ref('players/' + currentUser.uid + '/baseBlocks').set(baseBlocks);

            document.getElementById('baseCredits').textContent = `Credits: ${userCredits}`;
            renderBase();

            return false;
        }

        // Leaderboard screen
        async function showLeaderboard() {
            showScreen('leaderboardScreen');

            // Fetch all players with their credits
            const playersSnapshot = await database.ref('players').once('value');
            const playersData = playersSnapshot.val();

            if (!playersData) {
                document.getElementById('leaderboardContent').innerHTML = '<p>No players found.</p>';
                return;
            }

            // Create array of players with credits
            const leaderboard = [];
            for (const [uid, playerData] of Object.entries(playersData)) {
                if (playerData.username && playerData.credits !== undefined) {
                    leaderboard.push({
                        uid: uid,
                        username: playerData.username,
                        credits: playerData.credits || 0
                    });
                }
            }

            // Sort by credits descending
            leaderboard.sort((a, b) => b.credits - a.credits);

            // Build HTML
            let html = '<div style="background: rgba(0,0,0,0.3); border-radius: 10px; padding: 20px;">';
            html += '<h3 style="color: #4facfe; margin-bottom: 15px;">Top Players by Credits</h3>';

            for (let i = 0; i < Math.min(leaderboard.length, 50); i++) {
                const player = leaderboard[i];
                const isYou = player.uid === currentUser.uid;
                const rankColor = i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? '#cd7f32' : '#ccc';

                html += `<div style="display: flex; justify-content: space-between; padding: 10px; margin: 5px 0; background: rgba(255,255,255,${isYou ? '0.15' : '0.05'}); border-radius: 5px; border-left: 4px solid ${rankColor};">
                    <span style="color: white; ${isYou ? 'font-weight: bold;' : ''}">${i + 1}. ${player.username}${isYou ? ' (YOU)' : ''}</span>
                    <span style="color: #FFC107; font-weight: bold;">${player.credits} credits</span>
                </div>`;
            }

            html += '</div>';
            document.getElementById('leaderboardContent').innerHTML = html;
        }

        // Screen management
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        function backToMainMenu() {
            // Clean up listeners
            if (currentPartyId) {
                database.ref('parties/' + currentPartyId).off();
            }
            if (currentLobbyId) {
                database.ref('lobbies/' + currentLobbyId).off();
            }

            currentPartyId = null;
            currentLobbyId = null;
            practiceMode.active = false;
            raceState.active = false;

            // Hide all screens
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('practiceCanvas').style.display = 'none';
            document.getElementById('raceCanvas').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('timer').style.display = 'none';
            document.getElementById('racePositions').style.display = 'none';

            // Show main menu
            initMainMenu();
        }

        // Keyboard handling
        document.addEventListener('keydown', (e) => {
            // Store both original key and lowercase for compatibility
            menuKeys[e.key] = true;
            menuKeys[e.key.toLowerCase()] = true;
            practiceMode.keys[e.key] = true;
            raceState.keys[e.key] = true;

            if (e.key === 'Escape') {
                if (practiceMode.active) {
                    practiceMode.active = false;
                    backToMainMenu();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            menuKeys[e.key] = false;
            menuKeys[e.key.toLowerCase()] = false;
            delete practiceMode.keys[e.key];
            delete raceState.keys[e.key];
        });

        // Initialize on auth
        auth.onAuthStateChanged(async (user) => {
            if (!user) {
                window.location.href = 'index.html';
            } else {
                currentUser = user;

                // Get username
                const userSnapshot = await database.ref('users/' + user.uid).once('value');
                const userData = userSnapshot.val();

                if (userData && userData.username) {
                    currentUsername = userData.username;
                } else {
                    currentUsername = user.email.split('@')[0];
                    await database.ref('users/' + user.uid).set({
                        username: currentUsername,
                        createdAt: firebase.database.ServerValue.TIMESTAMP
                    });
                }

                await initUserData();
                initMainMenu();
            }
        });
    </script>
</body>
</html>