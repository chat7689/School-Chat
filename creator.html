<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level Creator - Speedrun Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #2c3e50;
            font-family: 'Arial', sans-serif;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 250px;
            background: #87CEEB;
            cursor: crosshair;
            pointer-events: auto;
        }

        #sidebar {
            position: absolute;
            top: 0;
            left: 0;
            width: 250px;
            height: 100vh;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px;
            overflow-y: auto;
            z-index: 100;
            pointer-events: auto;
        }

        #topbar {
            position: absolute;
            top: 0;
            left: 250px;
            right: 0;
            height: 60px;
            background: rgba(0,0,0,0.8);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            z-index: 100;
        }

        .section {
            margin-bottom: 25px;
        }

        .section h3 {
            color: #4facfe;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .slider-group {
            margin-bottom: 15px;
        }

        .slider-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: #ccc;
        }

        .slider-group input[type="range"] {
            width: 100%;
        }

        .slider-group .value {
            color: #4facfe;
            font-weight: bold;
            float: right;
        }

        .tool-button {
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(79, 172, 254, 0.2);
            color: white;
            border: 2px solid #4facfe;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .tool-button:hover {
            background: rgba(79, 172, 254, 0.4);
        }

        .tool-button.active {
            background: #4facfe;
            color: black;
        }

        .tool-button.delete {
            background: rgba(255, 68, 68, 0.2);
            border-color: #ff4444;
        }

        .tool-button.delete:hover {
            background: rgba(255, 68, 68, 0.4);
        }

        .tool-button.delete.active {
            background: #ff4444;
        }

        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        button:hover {
            background: #45a049;
        }

        button.secondary {
            background: #666;
        }

        button.secondary:hover {
            background: #555;
        }

        input[type="number"] {
            width: 80px;
            padding: 5px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid #4facfe;
            border-radius: 3px;
        }

        .info-text {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }

        #levelData, #importData {
            width: 100%;
            height: 150px;
            background: rgba(0,0,0,0.5);
            color: #4facfe;
            border: 1px solid #4facfe;
            border-radius: 5px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            resize: none;
            pointer-events: auto;
            position: relative;
            z-index: 200;
        }

        #importData:focus, #levelData:focus {
            outline: none;
            border-color: #FFC107;
            background: rgba(0,0,0,0.7);
        }

        .stats {
            font-size: 12px;
            color: #ccc;
        }

        .controls-info {
            background: rgba(79, 172, 254, 0.1);
            padding: 10px;
            border-radius: 5px;
            font-size: 11px;
            line-height: 1.6;
        }

        #importModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        #importModal.show {
            display: flex;
        }

        .modal-content {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #4facfe;
            width: 90%;
            max-width: 600px;
        }

        .modal-content h2 {
            color: #4facfe;
            margin-bottom: 20px;
        }

        .modal-content textarea {
            width: 100%;
            height: 300px;
            background: rgba(0,0,0,0.5);
            color: #4facfe;
            border: 1px solid #4facfe;
            border-radius: 5px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: none;
        }

        .modal-content textarea:focus {
            outline: none;
            border-color: #FFC107;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            flex: 1;
        }
    </style>
</head>
<body>
    <div id="topbar">
        <button onclick="testLevel()">‚ñ∂ Test Level</button>
        <button onclick="stopTest()" class="secondary">‚èπ Stop Test</button>
        <button onclick="undo()" title="Undo (Ctrl+Z)">‚Ü∂ Undo</button>
        <button onclick="redo()" title="Redo (Ctrl+Y)">‚Ü∑ Redo</button>
        <button onclick="clearAutoSave()" class="secondary">üóë New Level</button>
        <button onclick="copyLevelData()">üìã Copy Level Data</button>
        <button onclick="showImportDialog()" style="background: #9b59b6;">üì• Import Level</button>
        <span style="margin-left: auto; font-size: 12px; color: #999;" id="saveStatus">No auto-save</span>
        <span style="font-size: 12px; margin-left: 15px;" id="cameraInfo">Camera: 0, 0 | Zoom: 1.0x</span>
    </div>

    <div id="sidebar">
        <h2 style="color: #4facfe; margin-bottom: 20px;">Level Creator</h2>

        <div class="section">
            <h3>Tools <span style="font-size: 10px; color: #999;">(or press 1-6)</span></h3>
            <button class="tool-button active" onclick="setTool('platform')">üü¶ Platform <span style="float:right;color:#999;">1</span></button>
            <button class="tool-button" onclick="setTool('hazard')">üü• Hazard <span style="float:right;color:#999;">2</span></button>
            <button class="tool-button" onclick="setTool('shrinker')">üü™ Small Size (20px) <span style="float:right;color:#999;">3</span></button>
            <button class="tool-button" onclick="setTool('default')">üü® Default Size (40px) <span style="float:right;color:#999;">4</span></button>
            <button class="tool-button" onclick="setTool('grower')">üü© Large Size (80px)</button>
            <button class="tool-button" onclick="setTool('background')">üî≤ Background</button>
            <button class="tool-button" onclick="setTool('foreground')">‚¨ú Foreground</button>
            <button class="tool-button" onclick="setTool('start')">üü¢ Start Position</button>
            <button class="tool-button" onclick="setTool('finish')">üèÅ Finish Line</button>
            <button class="tool-button" onclick="setTool('player')">üë§ Preview Player</button>
            <button class="tool-button" onclick="setTool('select')">‚úã Select/Move <span style="float:right;color:#999;">5</span></button>
            <button class="tool-button" onclick="setTool('resize')">‚ÜîÔ∏è Resize <span style="float:right;color:#999;">6</span></button>
            <button class="tool-button delete" onclick="setTool('delete')">üóë Delete <span style="float:right;color:#999;">7</span></button>
            <button class="tool-button" onclick="setTool('void')" style="background: rgba(0,0,0,0.5);">‚¨õ Void (Cut)</button>
            <button class="tool-button" onclick="setTool('movement')" style="background: rgba(100,150,255,0.7);">üîÑ Add Movement</button>
            <button class="tool-button" onclick="setTool('editmovement')" style="background: rgba(255,150,100,0.7);">‚è±Ô∏è Edit Movement Time</button>
        </div>


        <div class="section">
            <h3>Elements <span style="font-size: 10px; color: #999;">(click to jump)</span></h3>
            <div id="elementsList" style="max-height: 300px; overflow-y: auto; font-size: 11px;">
                <!-- Elements will be populated here -->
            </div>
        </div>

        <div class="section">
            <h3>Grid Settings</h3>
            <div class="slider-group">
                <label>Grid Size: <span class="value" id="gridValue">20</span>px</label>
                <select id="gridSize" onchange="updateGrid()" style="width: 100%; padding: 8px; background: #2a2a3e; color: white; border: 1px solid #444; border-radius: 5px; margin-top: 5px;">
                    <option value="5">5px</option>
                    <option value="10">10px</option>
                    <option value="20" selected>20px</option>
                    <option value="40">40px</option>
                    <option value="80">80px</option>
                    <option value="160">160px</option>
                </select>
            </div>
            <div class="stats">Blocks: <span id="blockCount">0</span> | Hazards: <span id="hazardCount">0</span></div>
        </div>

        <div class="section">
            <h3>Camera Navigation</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <div style="flex: 1;">
                    <label style="font-size: 12px; color: #ccc; display: block; margin-bottom: 5px;">X:</label>
                    <input type="number" id="camX" value="0" placeholder="X">
                </div>
                <div style="flex: 1;">
                    <label style="font-size: 12px; color: #ccc; display: block; margin-bottom: 5px;">Y:</label>
                    <input type="number" id="camY" value="0" placeholder="Y">
                </div>
            </div>
            <button onclick="goToCoordinates()" style="width: 100%; padding: 8px; font-size: 12px;">Go to Coordinates</button>
        </div>

        <div class="section">
            <h3>Physics Info</h3>
            <div class="stats" style="line-height: 1.8;">
                <div>Gravity: <span style="color: #4facfe;">0.042</span></div>
                <div>Move Accel: <span style="color: #4facfe;">0.28</span></div>
                <div>Jump Power: <span style="color: #4facfe;">3.67</span></div>
                <div>Max Speed: <span style="color: #4facfe;">3.5</span></div>
                <div>Ground Friction: <span style="color: #4facfe;">0.94</span></div>
                <div>Air Resistance: <span style="color: #4facfe;">0.88</span></div>
                <div style="margin-top: 10px; color: #FFC107;">Jump Height: ~160px</div>
            </div>
        </div>

        <div class="section">
            <h3>Keyboard Shortcuts</h3>
            <div class="controls-info" style="font-size: 11px; line-height: 1.6;">
                <strong>Tools:</strong><br>
                ‚Ä¢ 1-7: Select tools<br>
                ‚Ä¢ G: Toggle grid<br>
                <br>
                <strong>Editing:</strong><br>
                ‚Ä¢ Ctrl+Z: Undo<br>
                ‚Ä¢ Ctrl+Y: Redo<br>
                ‚Ä¢ Ctrl+C: Copy block<br>
                ‚Ä¢ Ctrl+V: Paste block<br>
                ‚Ä¢ Delete: Delete selected<br>
                <br>
                <strong>Camera:</strong><br>
                ‚Ä¢ WASD: Pan camera<br>
                ‚Ä¢ Scroll: Zoom in/out<br>
                <br>
                <strong>Test Mode:</strong><br>
                ‚Ä¢ R: Restart<br>
                ‚Ä¢ ESC: Exit test
            </div>
        </div>

        <div class="section">
            <h3>Export Level</h3>
            <textarea id="levelData" readonly></textarea>
            <p class="info-text">Level data will appear here. Click "Copy Level Data" to copy.</p>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <!-- Import Modal -->
    <div id="importModal">
        <div class="modal-content">
            <h2>üì• Import Level</h2>
            <textarea id="importModalText" placeholder="Paste your level JSON here..."></textarea>
            <div class="modal-buttons">
                <button onclick="doImport()">Import</button>
                <button onclick="closeImportModal()" class="secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div id="movementModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000; align-items: center; justify-content: center;">
        <div class="modal-content" style="width: 400px;">
            <h2>‚è±Ô∏è Movement Cycle Time</h2>
            <div style="margin: 20px 0;">
                <div style="font-size: 14px; color: #aaa; margin-bottom: 10px;" id="movementModalBlockInfo"></div>
                <div class="slider-group">
                    <label>Cycle Time: <span class="value" id="movementModalValue">5</span>s</label>
                    <input type="range" min="1" max="10" value="5" id="movementModalSlider" oninput="updateMovementModalSlider()" style="width: 100%;">
                </div>
            </div>
            <div class="modal-buttons">
                <button onclick="saveMovementTime()">Save</button>
                <button onclick="closeMovementModal()" class="secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Canvas size
        canvas.width = window.innerWidth - 250;
        canvas.height = window.innerHeight;

        // Level data
        let platforms = [];
        let hazards = [];
        let growers = [];  // Large size blocks (80px)
        let shrinkers = [];  // Small size blocks (20px)
        let defaultSizeBlocks = [];  // Default size blocks (40px)
        let backgroundBlocks = [];  // Visual only, no collision
        let foregroundBlocks = [];  // Visual only, rendered on top
        let startPos = { x: 40, y: 520, width: 40, height: 40 };  // 40x40 grid
        let finishPos = { x: 700, y: 480, width: 40, height: 40 };  // Drag-able finish (40x40)

        // Tool state
        let currentTool = 'platform';
        let gridSize = 20;
        let startGrid = 40;  // Grid size for start/finish placement
        let isDrawing = false;
        let dragStart = null;
        let currentRect = null;
        let selectedBlock = null;
        let selectedBlocks = [];  // Multiple selected blocks
        let isMultiSelecting = false;  // Dragging selection box
        let selectionStart = null;
        let selectionBox = null;
        let isDraggingBlock = false;
        let dragOffset = { x: 0, y: 0 };
        let playerPreview = { x: 0, y: 0, visible: false };
        let isResizing = false;
        let resizeEdge = null;  // 'left', 'right', 'top', 'bottom'
        let resizeStartPos = { x: 0, y: 0 };
        let resizeOriginal = null;
        let isDeleting = false;  // Track if currently in delete-drag mode

        // Camera
        let cameraX = 0;
        let cameraY = 0;
        let zoom = 1;

        // Physics settings (fixed values matching main game)
        const physics = {
            gravity: 0.042,  // 150% of 0.028
            moveSpeed: 0.28,  // Faster ground movement: 0.21 * 1.33 ‚âà 0.28
            jumpPower: 3.67,  // Calculated to clear 160px: sqrt(160 * 2 * 0.042) ‚âà 3.67
            maxSpeed: 3.5,  // Faster max speed: 2.625 * 1.33 ‚âà 3.5
            friction: 0.94,  // Less friction, more slippery (was 0.80)
            airRes: 0.88,  // Higher air resistance (was 0.92)
            fastFallMultiplier: 2.0  // Down arrow fall speed (was 1.75)
        };

        // Test mode
        let testMode = false;
        let player = { x: 0, y: 0, width: 40, height: 40, velocityX: 0, velocityY: 0, baseSize: 40, currentSize: 40 };
        let keys = {};
        let isGrounded = false;
        let sizeTransitioning = false;
        let sizeTransitionProgress = 0;
        let targetSize = 40;
        let isJumping = false;

        // Undo/Redo system
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STEPS = 50;

        function saveState() {
            const state = {
                platforms: JSON.parse(JSON.stringify(platforms)),
                hazards: JSON.parse(JSON.stringify(hazards)),
                growers: JSON.parse(JSON.stringify(growers)),
                shrinkers: JSON.parse(JSON.stringify(shrinkers)),
                defaultSizeBlocks: JSON.parse(JSON.stringify(defaultSizeBlocks)),
                backgroundBlocks: JSON.parse(JSON.stringify(backgroundBlocks)),
                foregroundBlocks: JSON.parse(JSON.stringify(foregroundBlocks)),
                startPos: JSON.parse(JSON.stringify(startPos)),
                finishPos: JSON.parse(JSON.stringify(finishPos))
            };
            undoStack.push(state);
            if (undoStack.length > MAX_UNDO_STEPS) {
                undoStack.shift();
            }
            redoStack = []; // Clear redo stack on new action
        }

        function undo() {
            if (undoStack.length > 0) {
                const currentState = {
                    platforms: JSON.parse(JSON.stringify(platforms)),
                    hazards: JSON.parse(JSON.stringify(hazards)),
                    growers: JSON.parse(JSON.stringify(growers)),
                    shrinkers: JSON.parse(JSON.stringify(shrinkers)),
                    defaultSizeBlocks: JSON.parse(JSON.stringify(defaultSizeBlocks)),
                    backgroundBlocks: JSON.parse(JSON.stringify(backgroundBlocks)),
                    foregroundBlocks: JSON.parse(JSON.stringify(foregroundBlocks)),
                    startPos: JSON.parse(JSON.stringify(startPos)),
                    finishPos: JSON.parse(JSON.stringify(finishPos))
                };
                redoStack.push(currentState);

                const state = undoStack.pop();
                platforms = state.platforms;
                hazards = state.hazards;
                growers = state.growers;
                shrinkers = state.shrinkers;
                defaultSizeBlocks = state.defaultSizeBlocks || [];
                backgroundBlocks = state.backgroundBlocks;
                foregroundBlocks = state.foregroundBlocks;
                startPos = state.startPos;
                finishPos = state.finishPos;

                updateStats();
                updateLevelData();
                draw();
            }
        }

        function redo() {
            if (redoStack.length > 0) {
                const currentState = {
                    platforms: JSON.parse(JSON.stringify(platforms)),
                    hazards: JSON.parse(JSON.stringify(hazards)),
                    growers: JSON.parse(JSON.stringify(growers)),
                    shrinkers: JSON.parse(JSON.stringify(shrinkers)),
                    defaultSizeBlocks: JSON.parse(JSON.stringify(defaultSizeBlocks)),
                    backgroundBlocks: JSON.parse(JSON.stringify(backgroundBlocks)),
                    foregroundBlocks: JSON.parse(JSON.stringify(foregroundBlocks)),
                    startPos: JSON.parse(JSON.stringify(startPos)),
                    finishPos: JSON.parse(JSON.stringify(finishPos))
                };
                undoStack.push(currentState);

                const state = redoStack.pop();
                platforms = state.platforms;
                hazards = state.hazards;
                growers = state.growers;
                shrinkers = state.shrinkers;
                defaultSizeBlocks = state.defaultSizeBlocks || [];
                backgroundBlocks = state.backgroundBlocks;
                foregroundBlocks = state.foregroundBlocks;
                startPos = state.startPos;
                finishPos = state.finishPos;

                updateStats();
                updateLevelData();
                draw();
            }
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function setToolByName(toolName) {
            currentTool = toolName;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            const buttons = document.querySelectorAll('.tool-button');
            buttons.forEach(btn => {
                if (btn.onclick && btn.onclick.toString().includes(`'${toolName}'`)) {
                    btn.classList.add('active');
                }
            });
        }

        // Grid toggle
        let gridVisible = true;
        function toggleGrid() {
            gridVisible = !gridVisible;
            draw();
        }

        function updateGrid() {
            gridSize = parseInt(document.getElementById('gridSize').value);
            document.getElementById('gridValue').textContent = gridSize;
            draw();
        }

        // Movement system
        let movementCycleTime = 5;
        let movementSelectedBlock = null;
        let movementStep = 0; // 0 = select block, 1 = set point 1, 2 = set point 2
        let movementPoint1 = null;
        let movementPoint2 = null;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let isDraggingMovementNode = false;
        let draggingNodeBlock = null;
        let draggingNodeType = null; // 'point1' or 'point2'
        let selectedMovementPath = null; // For editing existing movement paths
        let editingMovementBlock = null; // Block being edited in modal

        function openMovementModal(block) {
            editingMovementBlock = block;
            const blockType = platforms.includes(block) ? 'Platform' : 'Hazard';
            const blockIndex = platforms.includes(block) ? platforms.indexOf(block) + 1 : hazards.indexOf(block) + 1;

            document.getElementById('movementModalBlockInfo').textContent = `${blockType} #${blockIndex}`;
            document.getElementById('movementModalSlider').value = block.movement.cycleTime;
            document.getElementById('movementModalValue').textContent = block.movement.cycleTime;
            document.getElementById('movementModal').style.display = 'flex';
        }

        function closeMovementModal() {
            document.getElementById('movementModal').style.display = 'none';
            editingMovementBlock = null;
        }

        function updateMovementModalSlider() {
            const value = document.getElementById('movementModalSlider').value;
            document.getElementById('movementModalValue').textContent = value;
        }

        function saveMovementTime() {
            if (editingMovementBlock) {
                const newTime = parseInt(document.getElementById('movementModalSlider').value);
                editingMovementBlock.movement.cycleTime = newTime;
                updateLevelData();
                updateElementsList();
            }
            closeMovementModal();
        }

        function updateElementsList() {
            const list = document.getElementById('elementsList');
            list.innerHTML = '';

            const elements = [];

            // Add platforms
            platforms.forEach((p, i) => {
                elements.push({
                    type: 'Platform',
                    index: i + 1,
                    obj: p,
                    color: '#4A90E2',
                    icon: 'üü¶',
                    hasMovement: !!p.movement
                });
            });

            // Add hazards
            hazards.forEach((h, i) => {
                elements.push({
                    type: 'Hazard',
                    index: i + 1,
                    obj: h,
                    color: '#E74C3C',
                    icon: 'üü•',
                    hasMovement: !!h.movement
                });
            });

            // Add size blocks
            shrinkers.forEach((s, i) => {
                elements.push({
                    type: 'Small Size',
                    index: i + 1,
                    obj: s,
                    color: '#9B59B6',
                    icon: 'üü™'
                });
            });

            defaultSizeBlocks.forEach((d, i) => {
                elements.push({
                    type: 'Default Size',
                    index: i + 1,
                    obj: d,
                    color: '#FFC107',
                    icon: 'üü®'
                });
            });

            growers.forEach((g, i) => {
                elements.push({
                    type: 'Large Size',
                    index: i + 1,
                    obj: g,
                    color: '#4CAF50',
                    icon: 'üü©'
                });
            });

            // Add background blocks
            backgroundBlocks.forEach((b, i) => {
                elements.push({
                    type: 'Background',
                    index: i + 1,
                    obj: b,
                    color: '#666',
                    icon: 'üî≤'
                });
            });

            // Add foreground blocks
            foregroundBlocks.forEach((f, i) => {
                elements.push({
                    type: 'Foreground',
                    index: i + 1,
                    obj: f,
                    color: '#999',
                    icon: '‚¨ú'
                });
            });

            // Add start and finish
            elements.push({
                type: 'Start',
                index: 1,
                obj: startPos,
                color: '#4CAF50',
                icon: 'üü¢'
            });

            elements.push({
                type: 'Finish',
                index: 1,
                obj: finishPos,
                color: '#FFC107',
                icon: 'üèÅ'
            });

            if (elements.length === 0) {
                list.innerHTML = '<div style="color: #666; padding: 10px;">No elements yet</div>';
                return;
            }

            elements.forEach(elem => {
                const div = document.createElement('div');
                div.style.cssText = `
                    padding: 8px;
                    margin: 4px 0;
                    background: rgba(255,255,255,0.05);
                    border-left: 3px solid ${elem.color};
                    border-radius: 3px;
                    cursor: pointer;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                `;
                div.innerHTML = `
                    <span>${elem.icon} ${elem.type} #${elem.index}</span>
                    ${elem.hasMovement ? '<span style="color: #6496FF;">üîÑ</span>' : ''}
                `;
                div.onclick = () => {
                    cameraX = elem.obj.x - canvas.width / (2 * zoom);
                    cameraY = elem.obj.y - canvas.height / (2 * zoom);
                    document.getElementById('cameraInfo').textContent =
                        `Camera: ${Math.round(cameraX)}, ${Math.round(cameraY)} | Zoom: ${zoom.toFixed(1)}x`;

                    // If it has movement, open the movement modal
                    if (elem.hasMovement) {
                        selectMovementPath(elem.obj);
                        openMovementModal(elem.obj);
                    }

                    draw();
                };
                list.appendChild(div);
            });
        }

        // Physics are now fixed, no need for update function

        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq !== 0) {
                param = dot / lenSq;
            }

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function snapToGrid(value, grid = gridSize) {
            return Math.floor(value / grid) * grid;
        }

        function screenToWorld(x, y) {
            return {
                x: (x / zoom) + cameraX,
                y: (y / zoom) + cameraY
            };
        }

        function getEdgeNearMouse(block, mouseX, mouseY, threshold = 10) {
            // Check if mouse is near any edge of the block
            const left = Math.abs(mouseX - block.x) < threshold && mouseY >= block.y && mouseY <= block.y + block.height;
            const right = Math.abs(mouseX - (block.x + block.width)) < threshold && mouseY >= block.y && mouseY <= block.y + block.height;
            const top = Math.abs(mouseY - block.y) < threshold && mouseX >= block.x && mouseX <= block.x + block.width;
            const bottom = Math.abs(mouseY - (block.y + block.height)) < threshold && mouseX >= block.x && mouseX <= block.x + block.width;

            if (left) return 'left';
            if (right) return 'right';
            if (top) return 'top';
            if (bottom) return 'bottom';
            return null;
        }

        function worldToScreen(x, y) {
            return {
                x: (x - cameraX) * zoom,
                y: (y - cameraY) * zoom
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            if (testMode) return;

            const rect = canvas.getBoundingClientRect();
            const worldPos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);

            if (currentTool === 'select') {
                // Check if clicking on an existing block
                selectedBlock = null;
                isResizing = false;
                resizeEdge = null;

                // Check all blocks (select tool doesn't resize anymore)
                const allBlocks = [
                    ...platforms.map((p, i) => ({ type: 'platform', index: i, obj: p, grid: gridSize })),
                    ...hazards.map((h, i) => ({ type: 'hazard', index: i, obj: h, grid: gridSize })),
                    ...growers.map((g, i) => ({ type: 'grower', index: i, obj: g, grid: gridSize })),
                    ...shrinkers.map((s, i) => ({ type: 'shrinker', index: i, obj: s, grid: gridSize })),
                    ...defaultSizeBlocks.map((d, i) => ({ type: 'default', index: i, obj: d, grid: gridSize })),
                    ...backgroundBlocks.map((b, i) => ({ type: 'background', index: i, obj: b, grid: gridSize })),
                    ...foregroundBlocks.map((f, i) => ({ type: 'foreground', index: i, obj: f, grid: gridSize }))
                ];

                // Check for movement nodes first, then regular dragging
                {
                    // Check if clicking on a movement node
                    const nodeRadius = 10 / zoom;
                    let foundNode = false;

                    for (const block of [...platforms, ...hazards]) {
                        if (block.movement) {
                            const { point1, point2 } = block.movement;

                            // Check point1
                            const dist1 = Math.sqrt(Math.pow(worldPos.x - point1.x, 2) + Math.pow(worldPos.y - point1.y, 2));
                            if (dist1 <= nodeRadius * 3) {
                                isDraggingMovementNode = true;
                                draggingNodeBlock = block;
                                draggingNodeType = 'point1';
                                foundNode = true;
                                break;
                            }

                            // Check point2
                            const dist2 = Math.sqrt(Math.pow(worldPos.x - point2.x, 2) + Math.pow(worldPos.y - point2.y, 2));
                            if (dist2 <= nodeRadius * 3) {
                                isDraggingMovementNode = true;
                                draggingNodeBlock = block;
                                draggingNodeType = 'point2';
                                foundNode = true;
                                break;
                            }
                        }
                    }

                    // If no movement node clicked, check for clicking movement paths
                    if (!foundNode) {
                        for (const block of [...platforms, ...hazards]) {
                            if (block.movement) {
                                const { point1, point2 } = block.movement;

                                // Check if clicking near the movement line
                                const lineDistThreshold = 15 / zoom;
                                const dist = pointToLineDistance(worldPos.x, worldPos.y, point1.x, point1.y, point2.x, point2.y);

                                if (dist <= lineDistThreshold) {
                                    selectMovementPath(block);
                                    foundNode = true;
                                    break;
                                }
                            }
                        }
                    }

                    // If no movement node or path clicked, check for regular dragging
                    if (!foundNode) {
                        let clickedBlock = false;

                        // Check finish block
                        if (worldPos.x >= finishPos.x && worldPos.x <= finishPos.x + finishPos.width &&
                            worldPos.y >= finishPos.y && worldPos.y <= finishPos.y + finishPos.height) {
                            selectedBlock = { type: 'finish', obj: finishPos, grid: startGrid };
                            isDraggingBlock = true;
                            clickedBlock = true;
                            selectedBlocks = [];  // Clear multi-selection
                        } else {
                            // Check if clicking on a block in the current selection
                            let clickedSelectedBlock = false;
                            if (selectedBlocks.length > 0) {
                                for (const block of selectedBlocks) {
                                    if (worldPos.x >= block.obj.x && worldPos.x <= block.obj.x + block.obj.width &&
                                        worldPos.y >= block.obj.y && worldPos.y <= block.obj.y + block.obj.height) {
                                        isDraggingBlock = true;
                                        clickedBlock = true;
                                        clickedSelectedBlock = true;
                                        selectionStart = { x: worldPos.x, y: worldPos.y };
                                        break;
                                    }
                                }
                            }

                            // If not clicking on selected block, check other blocks for dragging
                            if (!clickedSelectedBlock) {
                                for (const block of allBlocks) {
                                    if (worldPos.x >= block.obj.x && worldPos.x <= block.obj.x + block.obj.width &&
                                        worldPos.y >= block.obj.y && worldPos.y <= block.obj.y + block.obj.height) {

                                        // If block has movement, open modal instead of dragging
                                        if (block.obj.movement && (block.type === 'platform' || block.type === 'hazard')) {
                                            openMovementModal(block.obj);
                                            clickedBlock = true;
                                            return; // Don't start dragging
                                        }

                                        selectedBlock = block;
                                        isDraggingBlock = true;
                                        clickedBlock = true;
                                        selectedBlocks = [];  // Clear multi-selection
                                        break;
                                    }
                                }
                            }
                        }

                        // If clicked on empty space, start multi-selection box
                        if (!clickedBlock) {
                            isMultiSelecting = true;
                            selectionStart = { x: worldPos.x, y: worldPos.y };
                            selectionBox = { x: worldPos.x, y: worldPos.y, width: 0, height: 0 };
                            selectedBlock = null;
                            selectedBlocks = [];
                        }
                    }
                }
            } else if (currentTool === 'editmovement') {
                // Edit Movement tool - click on a block with movement to edit cycle time
                const movableBlocks = [
                    ...platforms.map((p, i) => ({ type: 'platform', index: i, obj: p })),
                    ...hazards.map((h, i) => ({ type: 'hazard', index: i, obj: h }))
                ];

                for (const block of movableBlocks) {
                    if (worldPos.x >= block.obj.x && worldPos.x <= block.obj.x + block.obj.width &&
                        worldPos.y >= block.obj.y && worldPos.y <= block.obj.y + block.obj.height) {
                        if (block.obj.movement) {
                            openMovementModal(block.obj);
                        } else {
                            alert('This block has no movement path. Use "Add Movement" tool first.');
                        }
                        break;
                    }
                }
            } else if (currentTool === 'movement') {
                // Movement tool - 3 step process
                if (movementStep === 0) {
                    // Step 1: Select a block (only platforms and hazards can move)
                    const movableBlocks = [
                        ...platforms.map((p, i) => ({ type: 'platform', index: i, obj: p })),
                        ...hazards.map((h, i) => ({ type: 'hazard', index: i, obj: h }))
                    ];

                    for (const block of movableBlocks) {
                        if (worldPos.x >= block.obj.x && worldPos.x <= block.obj.x + block.obj.width &&
                            worldPos.y >= block.obj.y && worldPos.y <= block.obj.y + block.obj.height) {
                            movementSelectedBlock = block;
                            movementStep = 1;
                            movementPoint1 = null;
                            movementPoint2 = null;
                            draw();
                            break;
                        }
                    }
                } else if (movementStep === 1) {
                    // Step 2: Set point 1 (must be on the block, snapped to grid center)
                    const blockCenterX = movementSelectedBlock.obj.x + movementSelectedBlock.obj.width / 2;
                    const blockCenterY = movementSelectedBlock.obj.y + movementSelectedBlock.obj.height / 2;

                    // Check if click is on the selected block
                    if (worldPos.x >= movementSelectedBlock.obj.x && worldPos.x <= movementSelectedBlock.obj.x + movementSelectedBlock.obj.width &&
                        worldPos.y >= movementSelectedBlock.obj.y && worldPos.y <= movementSelectedBlock.obj.y + movementSelectedBlock.obj.height) {

                        movementPoint1 = {
                            x: snapToGrid(blockCenterX),
                            y: snapToGrid(blockCenterY)
                        };
                        movementStep = 2;
                        draw();
                    }
                } else if (movementStep === 2) {
                    // Step 3: Set point 2 (can be anywhere, snapped to grid center)
                    movementPoint2 = {
                        x: snapToGrid(worldPos.x),
                        y: snapToGrid(worldPos.y)
                    };

                    // Save the movement data to the block
                    movementSelectedBlock.obj.movement = {
                        point1: movementPoint1,
                        point2: movementPoint2,
                        cycleTime: movementCycleTime
                    };

                    // Reset movement tool state
                    movementSelectedBlock = null;
                    movementStep = 0;
                    movementPoint1 = null;
                    movementPoint2 = null;
                    updateLevelData();
                    draw();
                }
            } else if (currentTool === 'resize') {
                // Resize tool - check for edges and start resizing
                selectedBlock = null;
                isResizing = false;
                resizeEdge = null;

                const allBlocks = [
                    ...platforms.map((p, i) => ({ type: 'platform', index: i, obj: p, grid: gridSize })),
                    ...hazards.map((h, i) => ({ type: 'hazard', index: i, obj: h, grid: gridSize })),
                    ...growers.map((g, i) => ({ type: 'grower', index: i, obj: g, grid: gridSize })),
                    ...shrinkers.map((s, i) => ({ type: 'shrinker', index: i, obj: s, grid: gridSize })),
                    ...defaultSizeBlocks.map((d, i) => ({ type: 'default', index: i, obj: d, grid: gridSize })),
                    ...backgroundBlocks.map((b, i) => ({ type: 'background', index: i, obj: b, grid: gridSize })),
                    ...foregroundBlocks.map((f, i) => ({ type: 'foreground', index: i, obj: f, grid: gridSize }))
                ];

                // Check for edge resizing
                for (const block of allBlocks) {
                    const edge = getEdgeNearMouse(block.obj, worldPos.x, worldPos.y);
                    if (edge) {
                        selectedBlock = block;
                        isResizing = true;
                        resizeEdge = edge;
                        resizeStartPos = { x: worldPos.x, y: worldPos.y };
                        resizeOriginal = {
                            x: block.obj.x,
                            y: block.obj.y,
                            width: block.obj.width,
                            height: block.obj.height
                        };
                        break;
                    }
                }
            } else if (currentTool === 'delete') {
                deleteAtPosition(worldPos.x, worldPos.y);
                isDeleting = true;  // Enable drag-delete
            } else if (currentTool === 'void') {
                // Start void dragging
                isDrawing = true;
                dragStart = {
                    x: snapToGrid(worldPos.x),
                    y: snapToGrid(worldPos.y)
                };
            } else if (currentTool === 'start') {
                startPos.x = snapToGrid(worldPos.x, startGrid);
                startPos.y = snapToGrid(worldPos.y, startGrid);
                draw();
            } else if (currentTool === 'finish') {
                // Finish is now drag-able, so start dragging
                isDrawing = true;
                dragStart = {
                    x: snapToGrid(worldPos.x, startGrid),
                    y: snapToGrid(worldPos.y, startGrid)
                };
            } else if (currentTool === 'player') {
                playerPreview.x = snapToGrid(worldPos.x);
                playerPreview.y = snapToGrid(worldPos.y);
                playerPreview.visible = true;
                draw();
            } else {
                // For drawing tools, allow both click-to-place and drag-to-draw
                isDrawing = true;
                dragStart = {
                    x: snapToGrid(worldPos.x),
                    y: snapToGrid(worldPos.y)
                };

                // Immediately create a single grid-sized block at click position
                const clickBlock = {
                    x: dragStart.x,
                    y: dragStart.y,
                    width: gridSize,
                    height: gridSize
                };

                // Show preview immediately
                currentRect = clickBlock;
                draw();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (testMode) return;

            const rect = canvas.getBoundingClientRect();
            lastMouseX = e.clientX - rect.left;
            lastMouseY = e.clientY - rect.top;
            const worldPos = screenToWorld(lastMouseX, lastMouseY);

            if (isDeleting) {
                // Continuously delete blocks while dragging
                deleteAtPosition(worldPos.x, worldPos.y);
            } else if (isResizing && selectedBlock) {
                // Handle resizing
                const grid = selectedBlock.grid || gridSize;
                const snappedX = snapToGrid(worldPos.x, grid);
                const snappedY = snapToGrid(worldPos.y, grid);

                if (resizeEdge === 'left') {
                    const newWidth = resizeOriginal.x + resizeOriginal.width - snappedX;
                    if (newWidth > grid) {
                        selectedBlock.obj.x = snappedX;
                        selectedBlock.obj.width = newWidth;
                    }
                } else if (resizeEdge === 'right') {
                    const newWidth = snappedX - selectedBlock.obj.x;
                    if (newWidth > grid) {
                        selectedBlock.obj.width = newWidth;
                    }
                } else if (resizeEdge === 'top') {
                    const newHeight = resizeOriginal.y + resizeOriginal.height - snappedY;
                    if (newHeight > grid) {
                        selectedBlock.obj.y = snappedY;
                        selectedBlock.obj.height = newHeight;
                    }
                } else if (resizeEdge === 'bottom') {
                    const newHeight = snappedY - selectedBlock.obj.y;
                    if (newHeight > grid) {
                        selectedBlock.obj.height = newHeight;
                    }
                }
                draw();
            } else if (isDraggingMovementNode && draggingNodeBlock) {
                // Drag movement node
                if (draggingNodeType === 'point1') {
                    draggingNodeBlock.movement.point1.x = snapToGrid(worldPos.x);
                    draggingNodeBlock.movement.point1.y = snapToGrid(worldPos.y);
                } else if (draggingNodeType === 'point2') {
                    draggingNodeBlock.movement.point2.x = snapToGrid(worldPos.x);
                    draggingNodeBlock.movement.point2.y = snapToGrid(worldPos.y);
                }
                draw();
            } else if (isMultiSelecting) {
                // Update selection box
                const minX = Math.min(selectionStart.x, worldPos.x);
                const minY = Math.min(selectionStart.y, worldPos.y);
                const maxX = Math.max(selectionStart.x, worldPos.x);
                const maxY = Math.max(selectionStart.y, worldPos.y);

                selectionBox = {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
                draw();
            } else if (isDraggingBlock && selectedBlocks.length > 0) {
                // Drag multiple selected blocks
                const deltaX = snapToGrid(worldPos.x) - snapToGrid(selectionStart.x);
                const deltaY = snapToGrid(worldPos.y) - snapToGrid(selectionStart.y);

                if (deltaX !== 0 || deltaY !== 0) {
                    for (const block of selectedBlocks) {
                        block.obj.x += deltaX;
                        block.obj.y += deltaY;

                        // Update movement points if present
                        if (block.obj.movement) {
                            block.obj.movement.point1.x += deltaX;
                            block.obj.movement.point1.y += deltaY;
                            block.obj.movement.point2.x += deltaX;
                            block.obj.movement.point2.y += deltaY;
                        }
                    }
                    selectionStart = { x: worldPos.x, y: worldPos.y };
                    draw();
                }
            } else if (isDraggingBlock && selectedBlock) {
                // Snap mouse position directly to grid
                const grid = selectedBlock.grid || gridSize;
                const oldX = selectedBlock.obj.x;
                const oldY = selectedBlock.obj.y;
                selectedBlock.obj.x = snapToGrid(worldPos.x, grid);
                selectedBlock.obj.y = snapToGrid(worldPos.y, grid);

                // If this block has movement, update its movement points
                if (selectedBlock.obj.movement) {
                    const deltaX = selectedBlock.obj.x - oldX;
                    const deltaY = selectedBlock.obj.y - oldY;
                    selectedBlock.obj.movement.point1.x += deltaX;
                    selectedBlock.obj.movement.point1.y += deltaY;
                    selectedBlock.obj.movement.point2.x += deltaX;
                    selectedBlock.obj.movement.point2.y += deltaY;
                }
                draw();
            } else if (isDrawing) {
                // Use appropriate grid based on tool
                const grid = currentTool === 'finish' ? startGrid : gridSize;

                // Calculate the raw drag rectangle (before snapping)
                const rawMinX = Math.min(dragStart.x, worldPos.x);
                const rawMaxX = Math.max(dragStart.x, worldPos.x);
                const rawMinY = Math.min(dragStart.y, worldPos.y);
                const rawMaxY = Math.max(dragStart.y, worldPos.y);

                // Find all grid cells that the raw rectangle touches
                const startCellX = Math.floor(rawMinX / grid) * grid;
                const endCellX = Math.floor(rawMaxX / grid) * grid;
                const startCellY = Math.floor(rawMinY / grid) * grid;
                const endCellY = Math.floor(rawMaxY / grid) * grid;

                // Create rectangle covering all touched cells
                currentRect = {
                    x: startCellX,
                    y: startCellY,
                    width: endCellX - startCellX + grid,
                    height: endCellY - startCellY + grid
                };

                draw();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isDeleting) {
                isDeleting = false;
            }

            if (isResizing) {
                isResizing = false;
                resizeEdge = null;
                selectedBlock = null;
                updateLevelData();
            }

            if (isMultiSelecting) {
                // Finalize multi-selection
                isMultiSelecting = false;

                if (selectionBox && (selectionBox.width > 0 || selectionBox.height > 0)) {
                    // Find all blocks within selection box
                    const allBlocks = [
                        ...platforms.map((p, i) => ({ type: 'platform', index: i, obj: p, grid: gridSize })),
                        ...hazards.map((h, i) => ({ type: 'hazard', index: i, obj: h, grid: gridSize })),
                        ...growers.map((g, i) => ({ type: 'grower', index: i, obj: g, grid: gridSize })),
                        ...shrinkers.map((s, i) => ({ type: 'shrinker', index: i, obj: s, grid: gridSize })),
                        ...defaultSizeBlocks.map((d, i) => ({ type: 'default', index: i, obj: d, grid: gridSize })),
                        ...backgroundBlocks.map((b, i) => ({ type: 'background', index: i, obj: b, grid: gridSize })),
                        ...foregroundBlocks.map((f, i) => ({ type: 'foreground', index: i, obj: f, grid: gridSize }))
                    ];

                    selectedBlocks = allBlocks.filter(block => {
                        return block.obj.x < selectionBox.x + selectionBox.width &&
                               block.obj.x + block.obj.width > selectionBox.x &&
                               block.obj.y < selectionBox.y + selectionBox.height &&
                               block.obj.y + block.obj.height > selectionBox.y;
                    });

                    // If we have selected blocks, prepare for dragging
                    if (selectedBlocks.length > 0) {
                        selectionStart = screenToWorld(lastMouseX, lastMouseY);
                    }
                }

                selectionBox = null;
                draw();
            }

            if (isDraggingBlock) {
                isDraggingBlock = false;
                if (selectedBlocks.length === 0) {
                    selectedBlock = null;
                }
                updateLevelData();
            }

            if (isDraggingMovementNode) {
                isDraggingMovementNode = false;
                draggingNodeBlock = null;
                draggingNodeType = null;
                updateLevelData();
            }

            if (!isDrawing || testMode) return;

            if (currentRect && currentRect.width > 0 && currentRect.height > 0) {
                saveState(); // Save for undo
                if (currentTool === 'void') {
                    // Cut out the void area from all blocks
                    cutVoid(currentRect);
                } else if (currentTool === 'platform') {
                    platforms.push({...currentRect});
                } else if (currentTool === 'hazard') {
                    hazards.push({...currentRect});
                } else if (currentTool === 'shrinker') {
                    shrinkers.push({...currentRect});
                } else if (currentTool === 'default') {
                    defaultSizeBlocks.push({...currentRect});
                } else if (currentTool === 'grower') {
                    growers.push({...currentRect});
                } else if (currentTool === 'background') {
                    backgroundBlocks.push({...currentRect});
                } else if (currentTool === 'foreground') {
                    foregroundBlocks.push({...currentRect});
                } else if (currentTool === 'finish') {
                    // Replace finish position with new drag-created one
                    finishPos.x = currentRect.x;
                    finishPos.y = currentRect.y;
                    finishPos.width = currentRect.width;
                    finishPos.height = currentRect.height;
                }
                updateStats();
                updateLevelData();
            }

            isDrawing = false;
            currentRect = null;
            draw();
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            // Get mouse position before zoom
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const worldPosBefore = screenToWorld(mouseX, mouseY);

            // Apply zoom
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(3, zoom * delta));

            // Adjust camera to keep mouse position fixed
            const zoomRatio = newZoom / zoom;
            cameraX = worldPosBefore.x - (mouseX / newZoom);
            cameraY = worldPosBefore.y - (mouseY / newZoom);

            zoom = newZoom;

            document.getElementById('cameraInfo').textContent =
                `Camera: ${Math.round(cameraX)}, ${Math.round(cameraY)} | Zoom: ${zoom.toFixed(1)}x`;
            draw();
        });

        function deleteAtPosition(x, y) {
            saveState(); // Save for undo
            platforms = platforms.filter(p => !(x >= p.x && x <= p.x + p.width && y >= p.y && y <= p.y + p.height));
            hazards = hazards.filter(h => !(x >= h.x && x <= h.x + h.width && y >= h.y && y <= h.y + h.height));
            growers = growers.filter(g => !(x >= g.x && x <= g.x + g.width && y >= g.y && y <= g.y + g.height));
            shrinkers = shrinkers.filter(s => !(x >= s.x && x <= s.x + s.width && y >= s.y && y <= s.y + s.height));
            defaultSizeBlocks = defaultSizeBlocks.filter(d => !(x >= d.x && x <= d.x + d.width && y >= d.y && y <= d.y + d.height));
            backgroundBlocks = backgroundBlocks.filter(b => !(x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height));
            foregroundBlocks = foregroundBlocks.filter(f => !(x >= f.x && x <= f.x + f.width && y >= f.y && y <= f.y + f.height));
            updateStats();
            updateLevelData();
            draw();
        }

        function cutVoid(voidRect) {
            // Cut void from all block types
            platforms = cutVoidFromBlocks(platforms, voidRect);
            hazards = cutVoidFromBlocks(hazards, voidRect);
            growers = cutVoidFromBlocks(growers, voidRect);
            shrinkers = cutVoidFromBlocks(shrinkers, voidRect);
            defaultSizeBlocks = cutVoidFromBlocks(defaultSizeBlocks, voidRect);
            backgroundBlocks = cutVoidFromBlocks(backgroundBlocks, voidRect);
            foregroundBlocks = cutVoidFromBlocks(foregroundBlocks, voidRect);
        }

        function cutVoidFromBlocks(blocks, voidRect) {
            const newBlocks = [];

            for (let block of blocks) {
                // Check if void overlaps with block
                if (!(block.x + block.width <= voidRect.x ||
                      voidRect.x + voidRect.width <= block.x ||
                      block.y + block.height <= voidRect.y ||
                      voidRect.y + voidRect.height <= block.y)) {

                    // Void overlaps - split the block into up to 4 pieces

                    // Top piece (above void)
                    if (block.y < voidRect.y) {
                        newBlocks.push({
                            x: block.x,
                            y: block.y,
                            width: block.width,
                            height: voidRect.y - block.y
                        });
                    }

                    // Bottom piece (below void)
                    if (block.y + block.height > voidRect.y + voidRect.height) {
                        newBlocks.push({
                            x: block.x,
                            y: voidRect.y + voidRect.height,
                            width: block.width,
                            height: (block.y + block.height) - (voidRect.y + voidRect.height)
                        });
                    }

                    // Left piece (left of void)
                    if (block.x < voidRect.x) {
                        const topY = Math.max(block.y, voidRect.y);
                        const bottomY = Math.min(block.y + block.height, voidRect.y + voidRect.height);
                        newBlocks.push({
                            x: block.x,
                            y: topY,
                            width: voidRect.x - block.x,
                            height: bottomY - topY
                        });
                    }

                    // Right piece (right of void)
                    if (block.x + block.width > voidRect.x + voidRect.width) {
                        const topY = Math.max(block.y, voidRect.y);
                        const bottomY = Math.min(block.y + block.height, voidRect.y + voidRect.height);
                        newBlocks.push({
                            x: voidRect.x + voidRect.width,
                            y: topY,
                            width: (block.x + block.width) - (voidRect.x + voidRect.width),
                            height: bottomY - topY
                        });
                    }
                } else {
                    // No overlap - keep block as is
                    newBlocks.push(block);
                }
            }

            return newBlocks;
        }


        function updateStats() {
            document.getElementById('blockCount').textContent = platforms.length;
            document.getElementById('hazardCount').textContent = hazards.length;
            updateElementsList();
        }

        function updateLevelData() {
            const data = {
                platforms: platforms,
                hazards: hazards,
                growers: growers,
                shrinkers: shrinkers,
                defaultSizeBlocks: defaultSizeBlocks,
                backgroundBlocks: backgroundBlocks,
                foregroundBlocks: foregroundBlocks,
                start: startPos,
                finish: finishPos,
                physics: physics
            };
            document.getElementById('levelData').value = JSON.stringify(data, null, 2);
            // Auto-save to localStorage
            autoSave();
        }

        // Auto-save system
        function autoSave() {
            const data = {
                platforms: platforms,
                hazards: hazards,
                growers: growers,
                shrinkers: shrinkers,
                defaultSizeBlocks: defaultSizeBlocks,
                backgroundBlocks: backgroundBlocks,
                foregroundBlocks: foregroundBlocks,
                start: startPos,
                finish: finishPos,
                physics: physics,
                camera: { x: cameraX, y: cameraY, zoom: zoom }
            };
            localStorage.setItem('levelCreator_autoSave', JSON.stringify(data));
            localStorage.setItem('levelCreator_lastSaved', new Date().toISOString());
            updateSaveStatus();
        }

        function updateSaveStatus() {
            const lastSaved = localStorage.getItem('levelCreator_lastSaved');
            if (lastSaved) {
                const date = new Date(lastSaved);
                const timeStr = date.toLocaleTimeString();
                document.getElementById('saveStatus').textContent = `Auto-saved at ${timeStr}`;
                document.getElementById('saveStatus').style.color = '#4facfe';
            }
        }

        function loadAutoSave() {
            const saved = localStorage.getItem('levelCreator_autoSave');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    platforms = data.platforms || [];
                    hazards = data.hazards || [];
                    growers = data.growers || [];
                    shrinkers = data.shrinkers || [];
                    defaultSizeBlocks = data.defaultSizeBlocks || [];
                    backgroundBlocks = data.backgroundBlocks || [];
                    foregroundBlocks = data.foregroundBlocks || [];
                    startPos = data.start || { x: 40, y: 520, width: 40, height: 40 };
                    finishPos = data.finish || { x: 700, y: 480, width: 40, height: 40 };
                    if (data.camera) {
                        cameraX = data.camera.x;
                        cameraY = data.camera.y;
                        zoom = data.camera.zoom;
                    }
                    updateStats();
                    updateLevelData();
                    updateSaveStatus();
                    draw();
                    return true;
                } catch (e) {
                    console.error('Failed to load auto-save:', e);
                }
            }
            return false;
        }

        function clearAutoSave() {
            if (confirm('Clear auto-saved level and start fresh?')) {
                localStorage.removeItem('levelCreator_autoSave');
                localStorage.removeItem('levelCreator_lastSaved');
                platforms = [];
                hazards = [];
                growers = [];
                shrinkers = [];
                defaultSizeBlocks = [];
                backgroundBlocks = [];
                foregroundBlocks = [];
                startPos = { x: 40, y: 520, width: 40, height: 40 };
                finishPos = { x: 700, y: 480, width: 40, height: 40 };
                cameraX = 0;
                cameraY = 0;
                zoom = 1;
                updateStats();
                updateLevelData();
                document.getElementById('saveStatus').textContent = 'No auto-save';
                document.getElementById('saveStatus').style.color = '#999';
                draw();
            }
        }

        function copyLevelData() {
            const textarea = document.getElementById('levelData');
            textarea.select();
            document.execCommand('copy');
            alert('Level data copied to clipboard!');
        }

        function clearLevel() {
            if (confirm('Are you sure you want to clear everything?')) {
                platforms = [];
                hazards = [];
                updateStats();
                updateLevelData();
                draw();
            }
        }

        function showImportDialog() {
            document.getElementById('importModal').classList.add('show');
            document.getElementById('importModalText').value = '';
            document.getElementById('importModalText').focus();
        }

        function closeImportModal() {
            document.getElementById('importModal').classList.remove('show');
        }

        function doImport() {
            const importText = document.getElementById('importModalText').value.trim();
            if (!importText) {
                alert('Please paste level data first');
                return;
            }

            importLevel(importText);
            closeImportModal();
        }

        function importLevel(importText) {
            if (!importText) {
                alert('Please paste level data first');
                return;
            }

            try {
                const data = JSON.parse(importText);

                // Validate data structure
                if (!data.platforms || !data.hazards || !data.start || !data.finish) {
                    alert('Invalid level data format');
                    return;
                }

                // Import the data
                platforms = data.platforms || [];
                hazards = data.hazards || [];
                growers = data.growers || [];
                shrinkers = data.shrinkers || [];
                defaultSizeBlocks = data.defaultSizeBlocks || [];
                backgroundBlocks = data.backgroundBlocks || [];
                foregroundBlocks = data.foregroundBlocks || [];
                startPos = data.start || { x: 40, y: 520, width: 40, height: 40 };
                finishPos = data.finish || { x: 700, y: 480, width: 40, height: 40 };

                // Ensure start and finish have width/height
                if (!startPos.width) startPos.width = 40;
                if (!startPos.height) startPos.height = 40;
                if (!finishPos.width) finishPos.width = 40;
                if (!finishPos.height) finishPos.height = 40;

                // Update UI
                updateStats();
                updateLevelData();
                draw();

                alert('Level imported successfully!');
            } catch (error) {
                alert('Error parsing level data. Please check your JSON format.');
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.scale(zoom, zoom);
            ctx.translate(-cameraX, -cameraY);

            // Coordinate plane axes
            ctx.strokeStyle = 'rgba(79, 172, 254, 0.5)';
            ctx.lineWidth = 2 / zoom;
            // X-axis (y=0)
            ctx.beginPath();
            ctx.moveTo(cameraX, 0);
            ctx.lineTo(cameraX + canvas.width / zoom, 0);
            ctx.stroke();
            // Y-axis (x=0)
            ctx.beginPath();
            ctx.moveTo(0, cameraY);
            ctx.lineTo(0, cameraY + canvas.height / zoom);
            ctx.stroke();

            // Grid (toggle with G key)
            if (gridVisible) {
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1 / zoom;
                const startGridX = Math.floor(cameraX / gridSize) * gridSize;
                const startGridY = Math.floor(cameraY / gridSize) * gridSize;
                const endGridX = startGridX + (canvas.width / zoom) + gridSize;
                const endGridY = startGridY + (canvas.height / zoom) + gridSize;

                for (let x = startGridX; x < endGridX; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, startGridY);
                    ctx.lineTo(x, endGridY);
                    ctx.stroke();
                }

                for (let y = startGridY; y < endGridY; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(startGridX, y);
                    ctx.lineTo(endGridX, y);
                    ctx.stroke();
                }
            }

            // Coordinate labels
            ctx.fillStyle = '#4facfe';
            ctx.font = `${12 / zoom}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            // X-axis labels
            for (let x = Math.ceil(cameraX / 100) * 100; x < cameraX + canvas.width / zoom; x += 100) {
                ctx.fillText(x.toString(), x, 0 - 5 / zoom);
            }
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            // Y-axis labels
            for (let y = Math.ceil(cameraY / 100) * 100; y < cameraY + canvas.height / zoom; y += 100) {
                ctx.fillText(y.toString(), 0 + 5 / zoom, y);
            }

            // Background blocks (visual only, rendered first)
            backgroundBlocks.forEach(b => {
                ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                ctx.fillRect(b.x, b.y, b.width, b.height);
                ctx.strokeStyle = 'rgba(80, 80, 80, 0.5)';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(b.x, b.y, b.width, b.height);
            });

            // Platforms
            platforms.forEach(p => {
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(p.x, p.y, p.width, p.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(p.x, p.y, p.width, p.height);
            });

            // Hazards
            hazards.forEach(h => {
                ctx.fillStyle = '#FF3333';
                ctx.fillRect(h.x, h.y, h.width, h.height);
                ctx.strokeStyle = '#CC0000';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(h.x, h.y, h.width, h.height);
            });

            // Growers (green pads - 2x size)
            growers.forEach(g => {
                ctx.fillStyle = '#00FF88';
                ctx.fillRect(g.x, g.y, g.width, g.height);
                ctx.strokeStyle = '#00CC66';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(g.x, g.y, g.width, g.height);
            });

            // Shrinkers (purple pads - 0.5x size)
            shrinkers.forEach(s => {
                ctx.fillStyle = '#BB66FF';
                ctx.fillRect(s.x, s.y, s.width, s.height);
                ctx.strokeStyle = '#9944DD';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(s.x, s.y, s.width, s.height);
            });

            // Default size blocks (yellow/orange - default 40px size)
            defaultSizeBlocks.forEach(d => {
                ctx.fillStyle = '#FFB84D';
                ctx.fillRect(d.x, d.y, d.width, d.height);
                ctx.strokeStyle = '#FF8800';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(d.x, d.y, d.width, d.height);
            });

            // Current drawing
            if (currentRect) {
                if (currentTool === 'platform') {
                    ctx.fillStyle = 'rgba(76, 175, 80, 0.5)';
                    ctx.strokeStyle = '#4CAF50';
                } else if (currentTool === 'hazard') {
                    ctx.fillStyle = 'rgba(255, 51, 51, 0.5)';
                    ctx.strokeStyle = '#FF3333';
                } else if (currentTool === 'grower') {
                    ctx.fillStyle = 'rgba(0, 255, 136, 0.5)';
                    ctx.strokeStyle = '#00FF88';
                } else if (currentTool === 'shrinker') {
                    ctx.fillStyle = 'rgba(187, 102, 255, 0.5)';
                    ctx.strokeStyle = '#BB66FF';
                } else if (currentTool === 'default') {
                    ctx.fillStyle = 'rgba(255, 184, 77, 0.5)';
                    ctx.strokeStyle = '#FFB84D';
                } else if (currentTool === 'background') {
                    ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                    ctx.strokeStyle = 'rgba(80, 80, 80, 0.5)';
                } else if (currentTool === 'foreground') {
                    ctx.fillStyle = 'rgba(200, 200, 200, 0.4)';
                    ctx.strokeStyle = 'rgba(180, 180, 180, 0.6)';
                } else if (currentTool === 'void') {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                } else if (currentTool === 'finish') {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                    ctx.strokeStyle = '#FFD700';
                }
                ctx.fillRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
            }

            // Start position
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(startPos.x, startPos.y, 40, 40);
            ctx.strokeStyle = '#00AA00';
            ctx.lineWidth = 2 / zoom;
            ctx.strokeRect(startPos.x, startPos.y, 40, 40);

            // Finish line
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(finishPos.x, finishPos.y, finishPos.width, finishPos.height);
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 2 / zoom;
            ctx.strokeRect(finishPos.x, finishPos.y, finishPos.width, finishPos.height);

            // Player preview (40x40 reference)
            if (playerPreview.visible) {
                ctx.fillStyle = 'rgba(255, 165, 0, 0.5)';
                ctx.fillRect(playerPreview.x, playerPreview.y, 40, 40);
                ctx.strokeStyle = '#FFA500';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(playerPreview.x, playerPreview.y, 40, 40);
            }

            // Multi-selection box
            if (isMultiSelecting && selectionBox) {
                ctx.strokeStyle = '#4facfe';
                ctx.fillStyle = 'rgba(79, 172, 254, 0.1)';
                ctx.lineWidth = 2 / zoom;
                ctx.setLineDash([5 / zoom, 5 / zoom]);
                ctx.fillRect(selectionBox.x, selectionBox.y, selectionBox.width, selectionBox.height);
                ctx.strokeRect(selectionBox.x, selectionBox.y, selectionBox.width, selectionBox.height);
                ctx.setLineDash([]);
            }

            // Selected blocks highlight
            if (selectedBlocks.length > 0) {
                ctx.strokeStyle = '#4facfe';
                ctx.lineWidth = 3 / zoom;
                ctx.setLineDash([10 / zoom, 5 / zoom]);
                for (const block of selectedBlocks) {
                    ctx.strokeRect(block.obj.x, block.obj.y, block.obj.width, block.obj.height);
                }
                ctx.setLineDash([]);
            }

            // Selected block highlight
            if (selectedBlock && isDraggingBlock && selectedBlocks.length === 0) {
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3 / zoom;
                ctx.setLineDash([10 / zoom, 5 / zoom]);
                ctx.strokeRect(selectedBlock.obj.x, selectedBlock.obj.y, selectedBlock.obj.width, selectedBlock.obj.height);
                ctx.setLineDash([]);
            }

            // Player in test mode
            if (testMode) {
                ctx.fillStyle = '#FF5722';
                ctx.fillRect(player.x, player.y, player.width, player.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(player.x, player.y, player.width, player.height);
            }

            // Draw movement paths for blocks with movement
            [...platforms, ...hazards].forEach(block => {
                if (block.movement) {
                    const { point1, point2 } = block.movement;

                    // Draw path line
                    ctx.strokeStyle = 'rgba(100, 150, 255, 0.6)';
                    ctx.lineWidth = 3 / zoom;
                    ctx.setLineDash([10 / zoom, 5 / zoom]);
                    ctx.beginPath();
                    ctx.moveTo(point1.x, point1.y);
                    ctx.lineTo(point2.x, point2.y);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw point1 (starting point - blue circle)
                    ctx.fillStyle = 'rgba(100, 150, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(point1.x, point1.y, 8 / zoom, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#6496FF';
                    ctx.lineWidth = 2 / zoom;
                    ctx.stroke();

                    // Draw point2 (end point - cyan circle)
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(point2.x, point2.y, 8 / zoom, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#00FFFF';
                    ctx.lineWidth = 2 / zoom;
                    ctx.stroke();
                }
            });

            // Movement tool visualization
            if (currentTool === 'movement') {
                // Highlight selected block
                if (movementSelectedBlock) {
                    ctx.strokeStyle = '#6496FF';
                    ctx.lineWidth = 4 / zoom;
                    ctx.setLineDash([10 / zoom, 5 / zoom]);
                    ctx.strokeRect(movementSelectedBlock.obj.x, movementSelectedBlock.obj.y,
                        movementSelectedBlock.obj.width, movementSelectedBlock.obj.height);
                    ctx.setLineDash([]);
                }

                // Show point 1 if set
                if (movementPoint1) {
                    ctx.fillStyle = 'rgba(100, 150, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(movementPoint1.x, movementPoint1.y, 10 / zoom, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Show line to mouse if in step 2
                if (movementStep === 2 && movementPoint1) {
                    const mouseWorld = screenToWorld(lastMouseX || 0, lastMouseY || 0);
                    ctx.strokeStyle = 'rgba(100, 150, 255, 0.4)';
                    ctx.lineWidth = 2 / zoom;
                    ctx.setLineDash([5 / zoom, 5 / zoom]);
                    ctx.beginPath();
                    ctx.moveTo(movementPoint1.x, movementPoint1.y);
                    ctx.lineTo(mouseWorld.x, mouseWorld.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // Foreground blocks (visual only, rendered on top)
            foregroundBlocks.forEach(f => {
                ctx.fillStyle = 'rgba(200, 200, 200, 0.4)';
                ctx.fillRect(f.x, f.y, f.width, f.height);
                ctx.strokeStyle = 'rgba(180, 180, 180, 0.6)';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(f.x, f.y, f.width, f.height);
            });

            ctx.restore();
        }

        function goToCoordinates() {
            const x = parseFloat(document.getElementById('camX').value) || 0;
            const y = parseFloat(document.getElementById('camY').value) || 0;
            cameraX = x;
            cameraY = y;
            document.getElementById('cameraInfo').textContent =
                `Camera: ${Math.round(cameraX)}, ${Math.round(cameraY)} | Zoom: ${zoom.toFixed(1)}x`;
            draw();
        }

        // Camera movement with WASD
        let cameraMoveSpeed = 10;
        setInterval(() => {
            if (testMode) return;

            if (keys['KeyW'] || keys['ArrowUp']) cameraY -= cameraMoveSpeed / zoom;
            if (keys['KeyS'] || keys['ArrowDown']) cameraY += cameraMoveSpeed / zoom;
            if (keys['KeyA'] || keys['ArrowLeft']) cameraX -= cameraMoveSpeed / zoom;
            if (keys['KeyD'] || keys['ArrowRight']) cameraX += cameraMoveSpeed / zoom;

            if (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'] ||
                keys['ArrowUp'] || keys['ArrowDown'] || keys['ArrowLeft'] || keys['ArrowRight']) {
                document.getElementById('cameraInfo').textContent =
                    `Camera: ${Math.round(cameraX)}, ${Math.round(cameraY)} | Zoom: ${zoom.toFixed(1)}x`;
                draw();
            }
        }, 16);

        // Test mode functions
        function testLevel() {
            testMode = true;
            zoom = 1; // Reset zoom to match actual game
            player.x = startPos.x;
            player.y = startPos.y;
            player.velocityX = 0;
            player.velocityY = 0;
            player.width = 40;
            player.height = 40;
            player.currentSize = 40;
            sizeTransitioning = false;
            lastFrameTime = performance.now(); // Reset frame time for delta calculation
            testStartTime = performance.now(); // Reset test start time for movement animations
            requestAnimationFrame(gameLoop);
        }

        function stopTest() {
            testMode = false;
            draw();
        }

        let lastFrameTime = performance.now();
        let testStartTime = 0;

        function gameLoop(currentTime) {
            if (!testMode) return;

            // Calculate delta time (normalize to 60fps baseline)
            const deltaTime = (currentTime - lastFrameTime) / 16.67;
            lastFrameTime = currentTime;

            // Update moving blocks
            const elapsed = (currentTime - testStartTime) / 1000; // Convert to seconds
            updateMovingBlocks(elapsed);

            updatePlayer(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        function updateMovingBlocks(elapsed) {
            // Update platform positions based on movement paths
            platforms.forEach(platform => {
                if (platform.movement) {
                    const { point1, point2, cycleTime } = platform.movement;
                    const progress = (elapsed % cycleTime) / cycleTime;

                    // Ping-pong between point1 and point2
                    let t;
                    if (progress < 0.5) {
                        t = progress * 2; // 0 to 1 (point1 to point2)
                    } else {
                        t = (1 - progress) * 2; // 1 to 0 (point2 to point1)
                    }

                    // Calculate center position
                    const centerX = point1.x + (point2.x - point1.x) * t;
                    const centerY = point1.y + (point2.y - point1.y) * t;

                    // Set block position (accounting for block size)
                    platform.x = centerX - platform.width / 2;
                    platform.y = centerY - platform.height / 2;
                }
            });

            // Update hazard positions
            hazards.forEach(hazard => {
                if (hazard.movement) {
                    const { point1, point2, cycleTime } = hazard.movement;
                    const progress = (elapsed % cycleTime) / cycleTime;

                    let t;
                    if (progress < 0.5) {
                        t = progress * 2;
                    } else {
                        t = (1 - progress) * 2;
                    }

                    const centerX = point1.x + (point2.x - point1.x) * t;
                    const centerY = point1.y + (point2.y - point1.y) * t;

                    hazard.x = centerX - hazard.width / 2;
                    hazard.y = centerY - hazard.height / 2;
                }
            });
        }

        function updatePlayer(deltaTime = 1) {
            // Update size transition
            updateSizeTransition(deltaTime);

            // If size changed, check for collisions and adjust position if needed
            if (sizeTransitioning) {
                // Simple collision correction during size transition
                for (let platform of platforms) {
                    if (player.x + player.width > platform.x &&
                        player.x < platform.x + platform.width &&
                        player.y + player.height > platform.y &&
                        player.y < platform.y + platform.height) {
                        // Push player out of collision
                        const overlapLeft = (player.x + player.width) - platform.x;
                        const overlapRight = (platform.x + platform.width) - player.x;
                        const overlapTop = (player.y + player.height) - platform.y;
                        const overlapBottom = (platform.y + platform.height) - player.y;
                        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                        if (minOverlap === overlapTop) {
                            player.y = platform.y - player.height;
                        } else if (minOverlap === overlapBottom) {
                            player.y = platform.y + platform.height;
                        } else if (minOverlap === overlapLeft) {
                            player.x = platform.x - player.width;
                        } else if (minOverlap === overlapRight) {
                            player.x = platform.x + platform.width;
                        }
                    }
                }
            }

            // Freeze movement during transition
            if (!sizeTransitioning) {
                // Scale factors based on player size (40 is base) - linear scaling
                const sizeScale = player.currentSize / 40;

                // Gravity (scaled by size for proportional physics)
                if ((keys['KeyS'] || keys['ArrowDown']) && !isGrounded) {
                    player.velocityY += physics.gravity * sizeScale * physics.fastFallMultiplier * deltaTime;  // Fall 1.75x faster
                } else {
                    player.velocityY += physics.gravity * sizeScale * deltaTime;
                }

                // Movement (scaled by size)
                const moveSpeed = physics.moveSpeed * sizeScale;
                if (keys['KeyA'] || keys['ArrowLeft']) {
                    player.velocityX -= moveSpeed * deltaTime;
                }
                if (keys['KeyD'] || keys['ArrowRight']) {
                    player.velocityX += moveSpeed * deltaTime;
                }

                // Jump - Variable height, scaled by size
                if ((keys['KeyW'] || keys['ArrowUp'] || keys['Space']) && isGrounded) {
                    player.velocityY = -physics.jumpPower * sizeScale;
                    isJumping = true;
                }

                // Cut jump short if button released (variable jump height)
                if (isJumping && !keys['KeyW'] && !keys['ArrowUp'] && !keys['Space']) {
                    if (player.velocityY < 0) {
                        player.velocityY *= 0.5;
                    }
                    isJumping = false;
                }

                // Reset jump state when grounded
                if (isGrounded && player.velocityY >= 0) {
                    isJumping = false;
                }

                // Apply friction (using exponential decay for frame-rate independence)
                if (isGrounded) {
                    player.velocityX *= Math.pow(physics.friction, deltaTime);
                } else {
                    player.velocityX *= Math.pow(physics.airRes, deltaTime);
                }

                player.velocityX = Math.max(-physics.maxSpeed * sizeScale, Math.min(physics.maxSpeed * sizeScale, player.velocityX));

                // Cap vertical velocity to prevent tunneling through platforms
                const maxFallSpeed = 8 * sizeScale; // Terminal velocity (reduced to prevent glitching)
                player.velocityY = Math.min(player.velocityY, maxFallSpeed);

                player.x += player.velocityX * deltaTime;
                player.y += player.velocityY * deltaTime;
            }

            checkCollision();
            checkHazards();
            checkGrowers();
            checkShrinkers();
            checkDefaultSize();
            checkFinish();

            // Keep camera centered on player
            cameraX = player.x - canvas.width / (2 * zoom);
            cameraY = player.y - canvas.height / (2 * zoom);

        }

        function canFitInGap(x, y, width, height) {
            // Add a small buffer (1px) to prevent phasing through tight gaps
            const buffer = 1;

            // Check if this position would collide with any platform
            for (let platform of platforms) {
                if (x + width - buffer > platform.x &&
                    x + buffer < platform.x + platform.width &&
                    y + height - buffer > platform.y &&
                    y + buffer < platform.y + platform.height) {
                    return false; // Collision found, can't fit
                }
            }
            return true; // No collision, can fit
        }

        function checkCollision() {
            isGrounded = false;

            for (let platform of platforms) {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {

                    const overlapLeft = (player.x + player.width) - platform.x;
                    const overlapRight = (platform.x + platform.width) - player.x;
                    const overlapTop = (player.y + player.height) - platform.y;
                    const overlapBottom = (platform.y + platform.height) - player.y;

                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    // Floor collision (landing on top)
                    // Extra check: if moving down fast and overlap is significant, it's definitely a floor collision
                    if ((minOverlap === overlapTop && player.velocityY >= 0) ||
                        (player.velocityY > 0 && overlapTop < overlapBottom && overlapTop <= Math.max(overlapLeft, overlapRight))) {
                        // Don't allow gap sliding - always stop at platform edges
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        isGrounded = true;
                    }
                    else if (minOverlap === overlapBottom && player.velocityY < 0) {
                        player.y = platform.y + platform.height;
                        player.velocityY = 0;
                    }
                    else if (minOverlap === overlapLeft) {
                        player.x = platform.x - player.width;
                        player.velocityX = 0;
                    }
                    else if (minOverlap === overlapRight) {
                        player.x = platform.x + platform.width;
                        player.velocityX = 0;
                    }
                }
            }
        }

        function checkHazards() {
            for (let hazard of hazards) {
                if (player.x + player.width > hazard.x &&
                    player.x < hazard.x + hazard.width &&
                    player.y + player.height > hazard.y &&
                    player.y < hazard.y + hazard.height) {
                    player.x = startPos.x;
                    player.y = startPos.y;
                    player.velocityX = 0;
                    player.velocityY = 0;
                    player.currentSize = 40;
                    player.width = 40;
                    player.height = 40;
                    return;
                }
            }
        }

        function checkGrowers() {
            for (let grower of growers) {
                if (player.x + player.width > grower.x &&
                    player.x < grower.x + grower.width &&
                    player.y + player.height > grower.y &&
                    player.y < grower.y + grower.height) {
                    if (player.currentSize !== 80 && !sizeTransitioning) {
                        startSizeTransition(80);
                    }
                    return;
                }
            }
        }

        function checkShrinkers() {
            for (let shrinker of shrinkers) {
                if (player.x + player.width > shrinker.x &&
                    player.x < shrinker.x + shrinker.width &&
                    player.y + player.height > shrinker.y &&
                    player.y < shrinker.y + shrinker.height) {
                    if (player.currentSize !== 20 && !sizeTransitioning) {
                        startSizeTransition(20);
                    }
                    return;
                }
            }
        }

        function checkDefaultSize() {
            for (let defaultBlock of defaultSizeBlocks) {
                if (player.x + player.width > defaultBlock.x &&
                    player.x < defaultBlock.x + defaultBlock.width &&
                    player.y + player.height > defaultBlock.y &&
                    player.y < defaultBlock.y + defaultBlock.height) {
                    // Default size block - sets to 40
                    if (player.currentSize !== 40 && !sizeTransitioning) {
                        startSizeTransition(40);
                    }
                    return;
                }
            }
        }

        function startSizeTransition(newSize) {
            sizeTransitioning = true;
            targetSize = newSize;
            sizeTransitionProgress = 0;
        }

        function updateSizeTransition(deltaTime) {
            if (!sizeTransitioning) return;

            sizeTransitionProgress += deltaTime * 0.1;  // Transition speed

            if (sizeTransitionProgress >= 1) {
                // Transition complete
                sizeTransitioning = false;
                player.currentSize = targetSize;
                player.width = targetSize;
                player.height = targetSize;
            } else {
                // Interpolate size from center
                const startSize = player.currentSize;
                const t = sizeTransitionProgress;
                const newSize = startSize + (targetSize - startSize) * t;

                // Calculate center point before resize
                const centerX = player.x + player.width / 2;
                const centerY = player.y + player.height / 2;

                // Update size
                player.width = newSize;
                player.height = newSize;

                // Reposition to keep center point fixed
                player.x = centerX - player.width / 2;
                player.y = centerY - player.height / 2;
            }
        }

        function checkFinish() {
            if (player.x + player.width > finishPos.x &&
                player.x < finishPos.x + finishPos.width &&
                player.y + player.height > finishPos.y &&
                player.y < finishPos.y + finishPos.height) {
                alert('Level Complete!');
                stopTest();
            }
        }

        // Copy/Paste for blocks
        let copiedBlock = null;

        // Keyboard events
        document.addEventListener('keydown', (e) => {
            // Don't capture keys when modal is open
            const modalOpen = document.getElementById('importModal').classList.contains('show');
            if (modalOpen) {
                if (e.code === 'Escape') {
                    closeImportModal();
                    e.preventDefault();
                }
                return;
            }

            keys[e.code] = true;

            // Undo/Redo shortcuts
            if (e.ctrlKey && e.code === 'KeyZ' && !testMode) {
                undo();
                e.preventDefault();
                return;
            }
            if (e.ctrlKey && e.code === 'KeyY' && !testMode) {
                redo();
                e.preventDefault();
                return;
            }

            // Copy selected block
            if (e.ctrlKey && e.code === 'KeyC' && selectedBlock && !testMode) {
                copiedBlock = JSON.parse(JSON.stringify(selectedBlock.obj));
                e.preventDefault();
                return;
            }

            // Paste block
            if (e.ctrlKey && e.code === 'KeyV' && copiedBlock && !testMode) {
                saveState();
                const newBlock = JSON.parse(JSON.stringify(copiedBlock));
                newBlock.x += 20;
                newBlock.y += 20;

                if (selectedBlock) {
                    if (selectedBlock.type === 'platform') platforms.push(newBlock);
                    else if (selectedBlock.type === 'hazard') hazards.push(newBlock);
                    else if (selectedBlock.type === 'grower') growers.push(newBlock);
                    else if (selectedBlock.type === 'shrinker') shrinkers.push(newBlock);
                    else if (selectedBlock.type === 'default') defaultSizeBlocks.push(newBlock);
                    else if (selectedBlock.type === 'background') backgroundBlocks.push(newBlock);
                    else if (selectedBlock.type === 'foreground') foregroundBlocks.push(newBlock);
                }
                updateStats();
                updateLevelData();
                draw();
                e.preventDefault();
                return;
            }

            // Delete selected block(s)
            if (e.code === 'Delete' && !testMode && (selectedBlock || selectedBlocks.length > 0)) {
                saveState();

                // Delete multiple selected blocks
                if (selectedBlocks.length > 0) {
                    for (const block of selectedBlocks) {
                        if (block.type === 'platform') {
                            const idx = platforms.indexOf(block.obj);
                            if (idx > -1) platforms.splice(idx, 1);
                        }
                        else if (block.type === 'hazard') {
                            const idx = hazards.indexOf(block.obj);
                            if (idx > -1) hazards.splice(idx, 1);
                        }
                        else if (block.type === 'grower') {
                            const idx = growers.indexOf(block.obj);
                            if (idx > -1) growers.splice(idx, 1);
                        }
                        else if (block.type === 'shrinker') {
                            const idx = shrinkers.indexOf(block.obj);
                            if (idx > -1) shrinkers.splice(idx, 1);
                        }
                        else if (block.type === 'default') {
                            const idx = defaultSizeBlocks.indexOf(block.obj);
                            if (idx > -1) defaultSizeBlocks.splice(idx, 1);
                        }
                        else if (block.type === 'background') {
                            const idx = backgroundBlocks.indexOf(block.obj);
                            if (idx > -1) backgroundBlocks.splice(idx, 1);
                        }
                        else if (block.type === 'foreground') {
                            const idx = foregroundBlocks.indexOf(block.obj);
                            if (idx > -1) foregroundBlocks.splice(idx, 1);
                        }
                    }
                    selectedBlocks = [];
                }
                // Delete single selected block
                else if (selectedBlock) {
                    if (selectedBlock.type === 'platform') platforms.splice(selectedBlock.index, 1);
                    else if (selectedBlock.type === 'hazard') hazards.splice(selectedBlock.index, 1);
                    else if (selectedBlock.type === 'grower') growers.splice(selectedBlock.index, 1);
                    else if (selectedBlock.type === 'shrinker') shrinkers.splice(selectedBlock.index, 1);
                    else if (selectedBlock.type === 'default') defaultSizeBlocks.splice(selectedBlock.index, 1);
                    else if (selectedBlock.type === 'background') backgroundBlocks.splice(selectedBlock.index, 1);
                    else if (selectedBlock.type === 'foreground') foregroundBlocks.splice(selectedBlock.index, 1);
                    selectedBlock = null;
                }

                updateStats();
                updateLevelData();
                draw();
                e.preventDefault();
                return;
            }

            // Tool shortcuts (1-9 keys)
            if (!testMode) {
                if (e.code === 'Digit1') setToolByName('platform');
                else if (e.code === 'Digit2') setToolByName('hazard');
                else if (e.code === 'Digit3') setToolByName('grower');
                else if (e.code === 'Digit4') setToolByName('shrinker');
                else if (e.code === 'Digit5') setToolByName('select');
                else if (e.code === 'Digit6') setToolByName('resize');
                else if (e.code === 'Digit7') setToolByName('delete');
                else if (e.code === 'KeyG') toggleGrid();
            }

            if (e.code === 'KeyR' && testMode) {
                player.x = startPos.x;
                player.y = startPos.y;
                player.velocityX = 0;
                player.velocityY = 0;
                player.currentSize = 40;
                player.width = 40;
                player.height = 40;
                testStartTime = performance.now(); // Reset moving platforms to starting position
            }

            if (e.code === 'Escape' && testMode) {
                stopTest();
            }

            if (e.code === 'Space' && !testMode) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            // Don't capture keys when modal is open
            const modalOpen = document.getElementById('importModal').classList.contains('show');
            if (modalOpen) {
                return;
            }

            keys[e.code] = false;
            e.preventDefault();
        });

        // Stop event propagation for import modal textarea
        const importTextarea = document.getElementById('importModalText');
        importTextarea.addEventListener('keydown', (e) => {
            e.stopPropagation();
        });
        importTextarea.addEventListener('keyup', (e) => {
            e.stopPropagation();
        });
        importTextarea.addEventListener('keypress', (e) => {
            e.stopPropagation();
        });

        // Window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth - 250;
            canvas.height = window.innerHeight;
            draw();
        });

        // Initial setup
        // Try to load auto-save on startup
        const hasAutoSave = loadAutoSave();
        if (!hasAutoSave) {
            updateLevelData();
            draw();
        }
    </script>
</body>
</html>
