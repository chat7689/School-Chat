<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level Creator - Speedrun Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #2c3e50;
            font-family: 'Arial', sans-serif;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 250px;
            background: #87CEEB;
            cursor: crosshair;
        }

        #sidebar {
            position: absolute;
            top: 0;
            left: 0;
            width: 250px;
            height: 100vh;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px;
            overflow-y: auto;
        }

        #topbar {
            position: absolute;
            top: 0;
            left: 250px;
            right: 0;
            height: 60px;
            background: rgba(0,0,0,0.8);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            z-index: 100;
        }

        .section {
            margin-bottom: 25px;
        }

        .section h3 {
            color: #4facfe;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .slider-group {
            margin-bottom: 15px;
        }

        .slider-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: #ccc;
        }

        .slider-group input[type="range"] {
            width: 100%;
        }

        .slider-group .value {
            color: #4facfe;
            font-weight: bold;
            float: right;
        }

        .tool-button {
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(79, 172, 254, 0.2);
            color: white;
            border: 2px solid #4facfe;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .tool-button:hover {
            background: rgba(79, 172, 254, 0.4);
        }

        .tool-button.active {
            background: #4facfe;
            color: black;
        }

        .tool-button.delete {
            background: rgba(255, 68, 68, 0.2);
            border-color: #ff4444;
        }

        .tool-button.delete:hover {
            background: rgba(255, 68, 68, 0.4);
        }

        .tool-button.delete.active {
            background: #ff4444;
        }

        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        button:hover {
            background: #45a049;
        }

        button.secondary {
            background: #666;
        }

        button.secondary:hover {
            background: #555;
        }

        input[type="number"] {
            width: 80px;
            padding: 5px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid #4facfe;
            border-radius: 3px;
        }

        .info-text {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }

        #levelData {
            width: 100%;
            height: 150px;
            background: rgba(0,0,0,0.5);
            color: #4facfe;
            border: 1px solid #4facfe;
            border-radius: 5px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            resize: none;
        }

        .stats {
            font-size: 12px;
            color: #ccc;
        }

        .controls-info {
            background: rgba(79, 172, 254, 0.1);
            padding: 10px;
            border-radius: 5px;
            font-size: 11px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div id="topbar">
        <button onclick="testLevel()">‚ñ∂ Test Level</button>
        <button onclick="stopTest()" class="secondary">‚èπ Stop Test</button>
        <button onclick="clearLevel()" class="secondary">üóë Clear All</button>
        <button onclick="copyLevelData()">üìã Copy Level Data</button>
        <span style="margin-left: auto; font-size: 12px;" id="cameraInfo">Camera: 0, 0 | Zoom: 1.0x</span>
    </div>

    <div id="sidebar">
        <h2 style="color: #4facfe; margin-bottom: 20px;">Level Creator</h2>

        <div class="section">
            <h3>Tools</h3>
            <button class="tool-button active" onclick="setTool('platform')">üü¶ Platform</button>
            <button class="tool-button" onclick="setTool('hazard')">üü• Hazard (Kill)</button>
            <button class="tool-button" onclick="setTool('start')">üü¢ Start Position</button>
            <button class="tool-button" onclick="setTool('finish')">üèÅ Finish Line</button>
            <button class="tool-button delete" onclick="setTool('delete')">üóë Delete</button>
        </div>

        <div class="section">
            <h3>Grid Settings</h3>
            <div class="slider-group">
                <label>Grid Size: <span class="value" id="gridValue">20</span>px</label>
                <input type="range" min="5" max="50" value="20" id="gridSize" oninput="updateGrid()">
            </div>
            <div class="stats">Blocks: <span id="blockCount">0</span> | Hazards: <span id="hazardCount">0</span></div>
        </div>

        <div class="section">
            <h3>Physics Testing</h3>
            <div class="slider-group">
                <label>Gravity: <span class="value" id="gravityValue">0.125</span></label>
                <input type="range" min="0" max="0.5" step="0.001" value="0.125" id="gravity" oninput="updatePhysics()">
            </div>
            <div class="slider-group">
                <label>Move Speed: <span class="value" id="moveSpeedValue">0.25</span></label>
                <input type="range" min="0.1" max="1" step="0.01" value="0.25" id="moveSpeed" oninput="updatePhysics()">
            </div>
            <div class="slider-group">
                <label>Jump Power: <span class="value" id="jumpPowerValue">5.9</span></label>
                <input type="range" min="3" max="10" step="0.1" value="5.9" id="jumpPower" oninput="updatePhysics()">
            </div>
            <div class="slider-group">
                <label>Max Speed: <span class="value" id="maxSpeedValue">2.5</span></label>
                <input type="range" min="1" max="5" step="0.1" value="2.5" id="maxSpeed" oninput="updatePhysics()">
            </div>
            <div class="slider-group">
                <label>Ground Friction: <span class="value" id="frictionValue">0.82</span></label>
                <input type="range" min="0.5" max="0.99" step="0.01" value="0.82" id="friction" oninput="updatePhysics()">
            </div>
            <div class="slider-group">
                <label>Air Resistance: <span class="value" id="airResValue">0.88</span></label>
                <input type="range" min="0.5" max="0.99" step="0.01" value="0.88" id="airRes" oninput="updatePhysics()">
            </div>
        </div>

        <div class="section">
            <h3>Controls</h3>
            <div class="controls-info">
                <strong>Creator Mode:</strong><br>
                ‚Ä¢ Mouse: Drag to create<br>
                ‚Ä¢ Scroll: Zoom in/out<br>
                ‚Ä¢ WASD: Pan camera<br>
                ‚Ä¢ Click: Place start/finish<br>
                <br>
                <strong>Test Mode:</strong><br>
                ‚Ä¢ Arrow Keys: Move<br>
                ‚Ä¢ WASD: Move<br>
                ‚Ä¢ Space: Boost<br>
                ‚Ä¢ R: Restart<br>
                ‚Ä¢ ESC: Exit test
            </div>
        </div>

        <div class="section">
            <h3>Export Level</h3>
            <textarea id="levelData" readonly></textarea>
            <p class="info-text">Level data will appear here. Click "Copy Level Data" to copy.</p>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Canvas size
        canvas.width = window.innerWidth - 250;
        canvas.height = window.innerHeight;

        // Level data
        let platforms = [];
        let hazards = [];
        let startPos = { x: 50, y: 520 };
        let finishPos = { x: 700, y: 470, width: 100, height: 50 };

        // Tool state
        let currentTool = 'platform';
        let gridSize = 20;
        let isDrawing = false;
        let dragStart = null;
        let currentRect = null;

        // Camera
        let cameraX = 0;
        let cameraY = 0;
        let zoom = 1;

        // Physics settings
        let physics = {
            gravity: 0.125,
            moveSpeed: 0.25,
            jumpPower: 5.9,
            maxSpeed: 2.5,
            friction: 0.82,
            airRes: 0.88
        };

        // Test mode
        let testMode = false;
        let player = { x: 0, y: 0, width: 40, height: 40, velocityX: 0, velocityY: 0 };
        let keys = {};
        let isGrounded = false;

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function updateGrid() {
            gridSize = parseInt(document.getElementById('gridSize').value);
            document.getElementById('gridValue').textContent = gridSize;
            draw();
        }

        function updatePhysics() {
            physics.gravity = parseFloat(document.getElementById('gravity').value);
            physics.moveSpeed = parseFloat(document.getElementById('moveSpeed').value);
            physics.jumpPower = parseFloat(document.getElementById('jumpPower').value);
            physics.maxSpeed = parseFloat(document.getElementById('maxSpeed').value);
            physics.friction = parseFloat(document.getElementById('friction').value);
            physics.airRes = parseFloat(document.getElementById('airRes').value);

            document.getElementById('gravityValue').textContent = physics.gravity.toFixed(3);
            document.getElementById('moveSpeedValue').textContent = physics.moveSpeed.toFixed(2);
            document.getElementById('jumpPowerValue').textContent = physics.jumpPower.toFixed(1);
            document.getElementById('maxSpeedValue').textContent = physics.maxSpeed.toFixed(1);
            document.getElementById('frictionValue').textContent = physics.friction.toFixed(2);
            document.getElementById('airResValue').textContent = physics.airRes.toFixed(2);
        }

        function snapToGrid(value) {
            return Math.round(value / gridSize) * gridSize;
        }

        function screenToWorld(x, y) {
            return {
                x: (x / zoom) + cameraX,
                y: (y / zoom) + cameraY
            };
        }

        function worldToScreen(x, y) {
            return {
                x: (x - cameraX) * zoom,
                y: (y - cameraY) * zoom
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            if (testMode) return;

            const rect = canvas.getBoundingClientRect();
            const worldPos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);

            if (currentTool === 'delete') {
                deleteAtPosition(worldPos.x, worldPos.y);
            } else if (currentTool === 'start') {
                startPos.x = snapToGrid(worldPos.x);
                startPos.y = snapToGrid(worldPos.y);
                draw();
            } else if (currentTool === 'finish') {
                finishPos.x = snapToGrid(worldPos.x);
                finishPos.y = snapToGrid(worldPos.y);
                draw();
            } else {
                isDrawing = true;
                dragStart = {
                    x: snapToGrid(worldPos.x),
                    y: snapToGrid(worldPos.y)
                };
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing || testMode) return;

            const rect = canvas.getBoundingClientRect();
            const worldPos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
            const endX = snapToGrid(worldPos.x);
            const endY = snapToGrid(worldPos.y);

            currentRect = {
                x: Math.min(dragStart.x, endX),
                y: Math.min(dragStart.y, endY),
                width: Math.abs(endX - dragStart.x) + gridSize,
                height: Math.abs(endY - dragStart.y) + gridSize
            };

            draw();
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!isDrawing || testMode) return;

            if (currentRect && currentRect.width > 0 && currentRect.height > 0) {
                if (currentTool === 'platform') {
                    platforms.push({...currentRect});
                } else if (currentTool === 'hazard') {
                    hazards.push({...currentRect});
                }
                updateStats();
                updateLevelData();
            }

            isDrawing = false;
            currentRect = null;
            draw();
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            zoom = Math.max(0.1, Math.min(3, zoom * delta));
            document.getElementById('cameraInfo').textContent =
                `Camera: ${Math.round(cameraX)}, ${Math.round(cameraY)} | Zoom: ${zoom.toFixed(1)}x`;
            draw();
        });

        function deleteAtPosition(x, y) {
            platforms = platforms.filter(p => !(x >= p.x && x <= p.x + p.width && y >= p.y && y <= p.y + p.height));
            hazards = hazards.filter(h => !(x >= h.x && x <= h.x + h.width && y >= h.y && y <= h.y + h.height));
            updateStats();
            updateLevelData();
            draw();
        }

        function updateStats() {
            document.getElementById('blockCount').textContent = platforms.length;
            document.getElementById('hazardCount').textContent = hazards.length;
        }

        function updateLevelData() {
            const data = {
                platforms: platforms,
                hazards: hazards,
                start: startPos,
                finish: finishPos,
                physics: physics
            };
            document.getElementById('levelData').value = JSON.stringify(data, null, 2);
        }

        function copyLevelData() {
            const textarea = document.getElementById('levelData');
            textarea.select();
            document.execCommand('copy');
            alert('Level data copied to clipboard!');
        }

        function clearLevel() {
            if (confirm('Are you sure you want to clear everything?')) {
                platforms = [];
                hazards = [];
                updateStats();
                updateLevelData();
                draw();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.scale(zoom, zoom);
            ctx.translate(-cameraX, -cameraY);

            // Grid
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1 / zoom;
            const startGridX = Math.floor(cameraX / gridSize) * gridSize;
            const startGridY = Math.floor(cameraY / gridSize) * gridSize;
            const endGridX = startGridX + (canvas.width / zoom) + gridSize;
            const endGridY = startGridY + (canvas.height / zoom) + gridSize;

            for (let x = startGridX; x < endGridX; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, startGridY);
                ctx.lineTo(x, endGridY);
                ctx.stroke();
            }

            for (let y = startGridY; y < endGridY; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(startGridX, y);
                ctx.lineTo(endGridX, y);
                ctx.stroke();
            }

            // Platforms
            platforms.forEach(p => {
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(p.x, p.y, p.width, p.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(p.x, p.y, p.width, p.height);
            });

            // Hazards
            hazards.forEach(h => {
                ctx.fillStyle = '#FF3333';
                ctx.fillRect(h.x, h.y, h.width, h.height);
                ctx.strokeStyle = '#CC0000';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(h.x, h.y, h.width, h.height);
            });

            // Current drawing
            if (currentRect) {
                ctx.fillStyle = currentTool === 'platform' ? 'rgba(76, 175, 80, 0.5)' : 'rgba(255, 51, 51, 0.5)';
                ctx.fillRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
                ctx.strokeStyle = currentTool === 'platform' ? '#4CAF50' : '#FF3333';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
            }

            // Start position
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(startPos.x, startPos.y, 40, 40);
            ctx.strokeStyle = '#00AA00';
            ctx.lineWidth = 2 / zoom;
            ctx.strokeRect(startPos.x, startPos.y, 40, 40);

            // Finish line
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(finishPos.x, finishPos.y, finishPos.width, finishPos.height);
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 2 / zoom;
            ctx.strokeRect(finishPos.x, finishPos.y, finishPos.width, finishPos.height);

            // Player in test mode
            if (testMode) {
                ctx.fillStyle = '#FF5722';
                ctx.fillRect(player.x, player.y, player.width, player.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(player.x, player.y, player.width, player.height);
            }

            ctx.restore();
        }

        // Camera movement with WASD
        let cameraMoveSpeed = 10;
        setInterval(() => {
            if (testMode) return;

            if (keys['KeyW'] || keys['ArrowUp']) cameraY -= cameraMoveSpeed / zoom;
            if (keys['KeyS'] || keys['ArrowDown']) cameraY += cameraMoveSpeed / zoom;
            if (keys['KeyA'] || keys['ArrowLeft']) cameraX -= cameraMoveSpeed / zoom;
            if (keys['KeyD'] || keys['ArrowRight']) cameraX += cameraMoveSpeed / zoom;

            if (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'] ||
                keys['ArrowUp'] || keys['ArrowDown'] || keys['ArrowLeft'] || keys['ArrowRight']) {
                document.getElementById('cameraInfo').textContent =
                    `Camera: ${Math.round(cameraX)}, ${Math.round(cameraY)} | Zoom: ${zoom.toFixed(1)}x`;
                draw();
            }
        }, 16);

        // Test mode functions
        function testLevel() {
            testMode = true;
            player.x = startPos.x;
            player.y = startPos.y;
            player.velocityX = 0;
            player.velocityY = 0;
            requestAnimationFrame(gameLoop);
        }

        function stopTest() {
            testMode = false;
            draw();
        }

        function gameLoop() {
            if (!testMode) return;

            updatePlayer();
            draw();

            requestAnimationFrame(gameLoop);
        }

        function updatePlayer() {
            // Gravity
            player.velocityY += physics.gravity;

            // Movement
            if (keys['KeyA'] || keys['ArrowLeft']) {
                player.velocityX -= physics.moveSpeed;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                player.velocityX += physics.moveSpeed;
            }

            // Jump
            if ((keys['KeyW'] || keys['ArrowUp'] || keys['Space']) && isGrounded) {
                player.velocityY = -physics.jumpPower;
            }

            // Friction
            if (isGrounded) {
                player.velocityX *= physics.friction;
            } else {
                player.velocityX *= physics.airRes;
            }

            player.velocityX = Math.max(-physics.maxSpeed, Math.min(physics.maxSpeed, player.velocityX));

            player.x += player.velocityX;
            player.y += player.velocityY;

            checkCollision();
            checkHazards();
            checkFinish();

            // Keep camera centered on player
            cameraX = player.x - canvas.width / (2 * zoom);
            cameraY = player.y - canvas.height / (2 * zoom);
        }

        function checkCollision() {
            isGrounded = false;

            for (let platform of platforms) {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {

                    const overlapLeft = (player.x + player.width) - platform.x;
                    const overlapRight = (platform.x + platform.width) - player.x;
                    const overlapTop = (player.y + player.height) - platform.y;
                    const overlapBottom = (platform.y + platform.height) - player.y;

                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    if (minOverlap === overlapTop && player.velocityY >= 0) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        isGrounded = true;
                    }
                    else if (minOverlap === overlapBottom && player.velocityY < 0) {
                        player.y = platform.y + platform.height;
                        player.velocityY = 0;
                    }
                    else if (minOverlap === overlapLeft) {
                        player.x = platform.x - player.width;
                        player.velocityX = 0;
                    }
                    else if (minOverlap === overlapRight) {
                        player.x = platform.x + platform.width;
                        player.velocityX = 0;
                    }
                }
            }
        }

        function checkHazards() {
            for (let hazard of hazards) {
                if (player.x + player.width > hazard.x &&
                    player.x < hazard.x + hazard.width &&
                    player.y + player.height > hazard.y &&
                    player.y < hazard.y + hazard.height) {
                    player.x = startPos.x;
                    player.y = startPos.y;
                    player.velocityX = 0;
                    player.velocityY = 0;
                    return;
                }
            }
        }

        function checkFinish() {
            if (player.x + player.width > finishPos.x &&
                player.x < finishPos.x + finishPos.width &&
                player.y + player.height > finishPos.y &&
                player.y < finishPos.y + finishPos.height) {
                alert('Level Complete!');
                stopTest();
            }
        }

        // Keyboard events
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;

            if (e.code === 'KeyR' && testMode) {
                player.x = startPos.x;
                player.y = startPos.y;
                player.velocityX = 0;
                player.velocityY = 0;
            }

            if (e.code === 'Escape' && testMode) {
                stopTest();
            }

            e.preventDefault();
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            e.preventDefault();
        });

        // Window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth - 250;
            canvas.height = window.innerHeight;
            draw();
        });

        // Initial draw
        updatePhysics();
        updateLevelData();
        draw();
    </script>
</body>
</html>
