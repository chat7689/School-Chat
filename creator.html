<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level Creator - Speedrun Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #2c3e50;
            font-family: 'Arial', sans-serif;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 250px;
            background: #87CEEB;
            cursor: crosshair;
            pointer-events: auto;
        }

        #sidebar {
            position: absolute;
            top: 0;
            left: 0;
            width: 250px;
            height: 100vh;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px;
            overflow-y: auto;
            z-index: 100;
            pointer-events: auto;
        }

        #topbar {
            position: absolute;
            top: 0;
            left: 250px;
            right: 0;
            height: 60px;
            background: rgba(0,0,0,0.8);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            z-index: 100;
        }

        .section {
            margin-bottom: 25px;
        }

        .section h3 {
            color: #4facfe;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .slider-group {
            margin-bottom: 15px;
        }

        .slider-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: #ccc;
        }

        .slider-group input[type="range"] {
            width: 100%;
        }

        .slider-group .value {
            color: #4facfe;
            font-weight: bold;
            float: right;
        }

        .tool-button {
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(79, 172, 254, 0.2);
            color: white;
            border: 2px solid #4facfe;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .tool-button:hover {
            background: rgba(79, 172, 254, 0.4);
        }

        .tool-button.active {
            background: #4facfe;
            color: black;
        }

        .tool-button.delete {
            background: rgba(255, 68, 68, 0.2);
            border-color: #ff4444;
        }

        .tool-button.delete:hover {
            background: rgba(255, 68, 68, 0.4);
        }

        .tool-button.delete.active {
            background: #ff4444;
        }

        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        button:hover {
            background: #45a049;
        }

        button.secondary {
            background: #666;
        }

        button.secondary:hover {
            background: #555;
        }

        input[type="number"] {
            width: 80px;
            padding: 5px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid #4facfe;
            border-radius: 3px;
        }

        .info-text {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }

        #levelData, #importData {
            width: 100%;
            height: 150px;
            background: rgba(0,0,0,0.5);
            color: #4facfe;
            border: 1px solid #4facfe;
            border-radius: 5px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            resize: none;
            pointer-events: auto;
            position: relative;
            z-index: 200;
        }

        #importData:focus, #levelData:focus {
            outline: none;
            border-color: #FFC107;
            background: rgba(0,0,0,0.7);
        }

        .stats {
            font-size: 12px;
            color: #ccc;
        }

        .controls-info {
            background: rgba(79, 172, 254, 0.1);
            padding: 10px;
            border-radius: 5px;
            font-size: 11px;
            line-height: 1.6;
        }

        #importModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        #importModal.show {
            display: flex;
        }

        .modal-content {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #4facfe;
            width: 90%;
            max-width: 600px;
        }

        .modal-content h2 {
            color: #4facfe;
            margin-bottom: 20px;
        }

        .modal-content textarea {
            width: 100%;
            height: 300px;
            background: rgba(0,0,0,0.5);
            color: #4facfe;
            border: 1px solid #4facfe;
            border-radius: 5px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: none;
        }

        .modal-content textarea:focus {
            outline: none;
            border-color: #FFC107;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            flex: 1;
        }
    </style>
</head>
<body>
    <div id="topbar">
        <button onclick="testLevel()">‚ñ∂ Test Level</button>
        <button onclick="stopTest()" class="secondary">‚èπ Stop Test</button>
        <button onclick="undo()" title="Undo (Ctrl+Z)">‚Ü∂ Undo</button>
        <button onclick="redo()" title="Redo (Ctrl+Y)">‚Ü∑ Redo</button>
        <button onclick="clearAutoSave()" class="secondary">üóë New Level</button>
        <button onclick="copyLevelData()">üìã Copy Level Data</button>
        <button onclick="showImportDialog()" style="background: #9b59b6;">üì• Import Level</button>
        <span style="margin-left: auto; font-size: 12px; color: #999;" id="saveStatus">No auto-save</span>
        <span style="font-size: 12px; margin-left: 15px;" id="cameraInfo">Camera: 0, 0 | Zoom: 1.0x</span>
    </div>

    <div id="sidebar">
        <h2 style="color: #4facfe; margin-bottom: 20px;">Level Creator</h2>

        <div class="section">
            <h3>Tools <span style="font-size: 10px; color: #999;">(or press 1-6)</span></h3>
            <button class="tool-button active" onclick="setTool('platform')">üü¶ Platform <span style="float:right;color:#999;">1</span></button>
            <button class="tool-button" onclick="setTool('hazard')">üü• Hazard <span style="float:right;color:#999;">2</span></button>
            <button class="tool-button" onclick="setTool('grower')">üü© Grower (2x) <span style="float:right;color:#999;">3</span></button>
            <button class="tool-button" onclick="setTool('shrinker')">üü™ Shrinker (0.5x) <span style="float:right;color:#999;">4</span></button>
            <button class="tool-button" onclick="setTool('background')">üî≤ Background</button>
            <button class="tool-button" onclick="setTool('foreground')">‚¨ú Foreground</button>
            <button class="tool-button" onclick="setTool('start')">üü¢ Start Position</button>
            <button class="tool-button" onclick="setTool('finish')">üèÅ Finish Line</button>
            <button class="tool-button" onclick="setTool('player')">üë§ Preview Player</button>
            <button class="tool-button" onclick="setTool('select')">‚úã Select/Move <span style="float:right;color:#999;">5</span></button>
            <button class="tool-button delete" onclick="setTool('delete')">üóë Delete <span style="float:right;color:#999;">6</span></button>
        </div>

        <div class="section">
            <h3>Grid Settings</h3>
            <div class="slider-group">
                <label>Grid Size: <span class="value" id="gridValue">20</span>px</label>
                <select id="gridSize" onchange="updateGrid()" style="width: 100%; padding: 8px; background: #2a2a3e; color: white; border: 1px solid #444; border-radius: 5px; margin-top: 5px;">
                    <option value="10">10px</option>
                    <option value="20" selected>20px</option>
                    <option value="40">40px</option>
                    <option value="80">80px</option>
                    <option value="160">160px</option>
                </select>
            </div>
            <div class="stats">Blocks: <span id="blockCount">0</span> | Hazards: <span id="hazardCount">0</span></div>
        </div>

        <div class="section">
            <h3>Camera Navigation</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <div style="flex: 1;">
                    <label style="font-size: 12px; color: #ccc; display: block; margin-bottom: 5px;">X:</label>
                    <input type="number" id="camX" value="0" placeholder="X">
                </div>
                <div style="flex: 1;">
                    <label style="font-size: 12px; color: #ccc; display: block; margin-bottom: 5px;">Y:</label>
                    <input type="number" id="camY" value="0" placeholder="Y">
                </div>
            </div>
            <button onclick="goToCoordinates()" style="width: 100%; padding: 8px; font-size: 12px;">Go to Coordinates</button>
        </div>

        <div class="section">
            <h3>Physics Info</h3>
            <div class="stats" style="line-height: 1.8;">
                <div>Gravity: <span style="color: #4facfe;">0.028</span></div>
                <div>Move Speed: <span style="color: #4facfe;">1.0</span></div>
                <div>Jump Power: <span style="color: #4facfe;">3.0</span></div>
                <div>Max Speed: <span style="color: #4facfe;">1.0</span></div>
                <div>Ground Friction: <span style="color: #4facfe;">0.94</span></div>
                <div>Air Resistance: <span style="color: #4facfe;">0.99</span></div>
                <div style="margin-top: 10px; color: #FFC107;">Jump Height: ~160px</div>
            </div>
        </div>

        <div class="section">
            <h3>Keyboard Shortcuts</h3>
            <div class="controls-info" style="font-size: 11px; line-height: 1.6;">
                <strong>Tools:</strong><br>
                ‚Ä¢ 1-6: Select tools<br>
                ‚Ä¢ G: Toggle grid<br>
                <br>
                <strong>Editing:</strong><br>
                ‚Ä¢ Ctrl+Z: Undo<br>
                ‚Ä¢ Ctrl+Y: Redo<br>
                ‚Ä¢ Ctrl+C: Copy block<br>
                ‚Ä¢ Ctrl+V: Paste block<br>
                ‚Ä¢ Delete: Delete selected<br>
                <br>
                <strong>Camera:</strong><br>
                ‚Ä¢ WASD: Pan camera<br>
                ‚Ä¢ Scroll: Zoom in/out<br>
                <br>
                <strong>Test Mode:</strong><br>
                ‚Ä¢ R: Restart<br>
                ‚Ä¢ ESC: Exit test
            </div>
        </div>

        <div class="section">
            <h3>Export Level</h3>
            <textarea id="levelData" readonly></textarea>
            <p class="info-text">Level data will appear here. Click "Copy Level Data" to copy.</p>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <!-- Import Modal -->
    <div id="importModal">
        <div class="modal-content">
            <h2>üì• Import Level</h2>
            <textarea id="importModalText" placeholder="Paste your level JSON here..."></textarea>
            <div class="modal-buttons">
                <button onclick="doImport()">Import</button>
                <button onclick="closeImportModal()" class="secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Canvas size
        canvas.width = window.innerWidth - 250;
        canvas.height = window.innerHeight;

        // Level data
        let platforms = [];
        let hazards = [];
        let growers = [];  // 2x size pads
        let shrinkers = [];  // 0.5x size pads
        let backgroundBlocks = [];  // Visual only, no collision
        let foregroundBlocks = [];  // Visual only, rendered on top
        let startPos = { x: 40, y: 520, width: 40, height: 40 };  // 40x40 grid
        let finishPos = { x: 700, y: 480, width: 40, height: 40 };  // Drag-able finish (40x40)

        // Tool state
        let currentTool = 'platform';
        let gridSize = 20;
        let startGrid = 40;  // Grid size for start/finish placement
        let isDrawing = false;
        let dragStart = null;
        let currentRect = null;
        let selectedBlock = null;
        let isDraggingBlock = false;
        let dragOffset = { x: 0, y: 0 };
        let playerPreview = { x: 0, y: 0, visible: false };
        let isResizing = false;
        let resizeEdge = null;  // 'left', 'right', 'top', 'bottom'
        let resizeStartPos = { x: 0, y: 0 };
        let resizeOriginal = null;
        let isDeleting = false;  // Track if currently in delete-drag mode

        // Camera
        let cameraX = 0;
        let cameraY = 0;
        let zoom = 1;

        // Physics settings (fixed values matching main game)
        const physics = {
            gravity: 0.042,  // 150% of 0.028
            moveSpeed: 0.12,  // Acceleration per frame (reduced for more gradual control)
            jumpPower: 3.67,  // Calculated to clear 160px: sqrt(160 * 2 * 0.042) ‚âà 3.67
            maxSpeed: 1.5,  // 150% of 1
            friction: 0.88,  // Less drag on ground (was 0.94)
            airRes: 0.96,  // More drag in air (was 0.99)
            fastFallMultiplier: 1.75  // Down arrow fall speed
        };

        // Test mode
        let testMode = false;
        let player = { x: 0, y: 0, width: 40, height: 40, velocityX: 0, velocityY: 0, baseSize: 40, currentSize: 40 };
        let keys = {};
        let isGrounded = false;
        let sizeTransitioning = false;
        let sizeTransitionProgress = 0;
        let targetSize = 40;
        let isJumping = false;

        // Undo/Redo system
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STEPS = 50;

        function saveState() {
            const state = {
                platforms: JSON.parse(JSON.stringify(platforms)),
                hazards: JSON.parse(JSON.stringify(hazards)),
                growers: JSON.parse(JSON.stringify(growers)),
                shrinkers: JSON.parse(JSON.stringify(shrinkers)),
                backgroundBlocks: JSON.parse(JSON.stringify(backgroundBlocks)),
                foregroundBlocks: JSON.parse(JSON.stringify(foregroundBlocks)),
                startPos: JSON.parse(JSON.stringify(startPos)),
                finishPos: JSON.parse(JSON.stringify(finishPos))
            };
            undoStack.push(state);
            if (undoStack.length > MAX_UNDO_STEPS) {
                undoStack.shift();
            }
            redoStack = []; // Clear redo stack on new action
        }

        function undo() {
            if (undoStack.length > 0) {
                const currentState = {
                    platforms: JSON.parse(JSON.stringify(platforms)),
                    hazards: JSON.parse(JSON.stringify(hazards)),
                    growers: JSON.parse(JSON.stringify(growers)),
                    shrinkers: JSON.parse(JSON.stringify(shrinkers)),
                    backgroundBlocks: JSON.parse(JSON.stringify(backgroundBlocks)),
                    foregroundBlocks: JSON.parse(JSON.stringify(foregroundBlocks)),
                    startPos: JSON.parse(JSON.stringify(startPos)),
                    finishPos: JSON.parse(JSON.stringify(finishPos))
                };
                redoStack.push(currentState);

                const state = undoStack.pop();
                platforms = state.platforms;
                hazards = state.hazards;
                growers = state.growers;
                shrinkers = state.shrinkers;
                backgroundBlocks = state.backgroundBlocks;
                foregroundBlocks = state.foregroundBlocks;
                startPos = state.startPos;
                finishPos = state.finishPos;

                updateStats();
                updateLevelData();
                draw();
            }
        }

        function redo() {
            if (redoStack.length > 0) {
                const currentState = {
                    platforms: JSON.parse(JSON.stringify(platforms)),
                    hazards: JSON.parse(JSON.stringify(hazards)),
                    growers: JSON.parse(JSON.stringify(growers)),
                    shrinkers: JSON.parse(JSON.stringify(shrinkers)),
                    backgroundBlocks: JSON.parse(JSON.stringify(backgroundBlocks)),
                    foregroundBlocks: JSON.parse(JSON.stringify(foregroundBlocks)),
                    startPos: JSON.parse(JSON.stringify(startPos)),
                    finishPos: JSON.parse(JSON.stringify(finishPos))
                };
                undoStack.push(currentState);

                const state = redoStack.pop();
                platforms = state.platforms;
                hazards = state.hazards;
                growers = state.growers;
                shrinkers = state.shrinkers;
                backgroundBlocks = state.backgroundBlocks;
                foregroundBlocks = state.foregroundBlocks;
                startPos = state.startPos;
                finishPos = state.finishPos;

                updateStats();
                updateLevelData();
                draw();
            }
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function setToolByName(toolName) {
            currentTool = toolName;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            const buttons = document.querySelectorAll('.tool-button');
            buttons.forEach(btn => {
                if (btn.onclick && btn.onclick.toString().includes(`'${toolName}'`)) {
                    btn.classList.add('active');
                }
            });
        }

        // Grid toggle
        let gridVisible = true;
        function toggleGrid() {
            gridVisible = !gridVisible;
            draw();
        }

        function updateGrid() {
            gridSize = parseInt(document.getElementById('gridSize').value);
            document.getElementById('gridValue').textContent = gridSize;
            draw();
        }

        // Physics are now fixed, no need for update function

        function snapToGrid(value, grid = gridSize) {
            return Math.round(value / grid) * grid;
        }

        function screenToWorld(x, y) {
            return {
                x: (x / zoom) + cameraX,
                y: (y / zoom) + cameraY
            };
        }

        function getEdgeNearMouse(block, mouseX, mouseY, threshold = 10) {
            // Check if mouse is near any edge of the block
            const left = Math.abs(mouseX - block.x) < threshold && mouseY >= block.y && mouseY <= block.y + block.height;
            const right = Math.abs(mouseX - (block.x + block.width)) < threshold && mouseY >= block.y && mouseY <= block.y + block.height;
            const top = Math.abs(mouseY - block.y) < threshold && mouseX >= block.x && mouseX <= block.x + block.width;
            const bottom = Math.abs(mouseY - (block.y + block.height)) < threshold && mouseX >= block.x && mouseX <= block.x + block.width;

            if (left) return 'left';
            if (right) return 'right';
            if (top) return 'top';
            if (bottom) return 'bottom';
            return null;
        }

        function worldToScreen(x, y) {
            return {
                x: (x - cameraX) * zoom,
                y: (y - cameraY) * zoom
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            if (testMode) return;

            const rect = canvas.getBoundingClientRect();
            const worldPos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);

            if (currentTool === 'select') {
                // Check if clicking on an existing block
                selectedBlock = null;
                isResizing = false;
                resizeEdge = null;

                // Check all blocks for edge resizing first (prioritize edges)
                const allBlocks = [
                    ...platforms.map((p, i) => ({ type: 'platform', index: i, obj: p, grid: gridSize })),
                    ...hazards.map((h, i) => ({ type: 'hazard', index: i, obj: h, grid: gridSize })),
                    ...growers.map((g, i) => ({ type: 'grower', index: i, obj: g, grid: gridSize })),
                    ...shrinkers.map((s, i) => ({ type: 'shrinker', index: i, obj: s, grid: gridSize })),
                    ...backgroundBlocks.map((b, i) => ({ type: 'background', index: i, obj: b, grid: gridSize })),
                    ...foregroundBlocks.map((f, i) => ({ type: 'foreground', index: i, obj: f, grid: gridSize }))
                ];

                // Check for edge resizing
                for (const block of allBlocks) {
                    const edge = getEdgeNearMouse(block.obj, worldPos.x, worldPos.y);
                    if (edge) {
                        selectedBlock = block;
                        isResizing = true;
                        resizeEdge = edge;
                        resizeStartPos = { x: worldPos.x, y: worldPos.y };
                        resizeOriginal = {
                            x: block.obj.x,
                            y: block.obj.y,
                            width: block.obj.width,
                            height: block.obj.height
                        };
                        break;
                    }
                }

                // If not resizing, check for regular dragging
                if (!isResizing) {
                    // Check finish block
                    if (worldPos.x >= finishPos.x && worldPos.x <= finishPos.x + finishPos.width &&
                        worldPos.y >= finishPos.y && worldPos.y <= finishPos.y + finishPos.height) {
                        selectedBlock = { type: 'finish', obj: finishPos, grid: startGrid };
                        isDraggingBlock = true;
                    } else {
                        // Check other blocks for dragging
                        for (const block of allBlocks) {
                            if (worldPos.x >= block.obj.x && worldPos.x <= block.obj.x + block.obj.width &&
                                worldPos.y >= block.obj.y && worldPos.y <= block.obj.y + block.obj.height) {
                                selectedBlock = block;
                                isDraggingBlock = true;
                                break;
                            }
                        }
                    }
                }
            } else if (currentTool === 'delete') {
                deleteAtPosition(worldPos.x, worldPos.y);
                isDeleting = true;  // Enable drag-delete
            } else if (currentTool === 'start') {
                startPos.x = snapToGrid(worldPos.x, startGrid);
                startPos.y = snapToGrid(worldPos.y, startGrid);
                draw();
            } else if (currentTool === 'finish') {
                // Finish is now drag-able, so start dragging
                isDrawing = true;
                dragStart = {
                    x: snapToGrid(worldPos.x, startGrid),
                    y: snapToGrid(worldPos.y, startGrid)
                };
            } else if (currentTool === 'player') {
                playerPreview.x = snapToGrid(worldPos.x);
                playerPreview.y = snapToGrid(worldPos.y);
                playerPreview.visible = true;
                draw();
            } else {
                isDrawing = true;
                dragStart = {
                    x: snapToGrid(worldPos.x),
                    y: snapToGrid(worldPos.y)
                };
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (testMode) return;

            const rect = canvas.getBoundingClientRect();
            const worldPos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);

            if (isDeleting) {
                // Continuously delete blocks while dragging
                deleteAtPosition(worldPos.x, worldPos.y);
            } else if (isResizing && selectedBlock) {
                // Handle resizing
                const grid = selectedBlock.grid || gridSize;
                const snappedX = snapToGrid(worldPos.x, grid);
                const snappedY = snapToGrid(worldPos.y, grid);

                if (resizeEdge === 'left') {
                    const newWidth = resizeOriginal.x + resizeOriginal.width - snappedX;
                    if (newWidth > grid) {
                        selectedBlock.obj.x = snappedX;
                        selectedBlock.obj.width = newWidth;
                    }
                } else if (resizeEdge === 'right') {
                    const newWidth = snappedX - selectedBlock.obj.x;
                    if (newWidth > grid) {
                        selectedBlock.obj.width = newWidth;
                    }
                } else if (resizeEdge === 'top') {
                    const newHeight = resizeOriginal.y + resizeOriginal.height - snappedY;
                    if (newHeight > grid) {
                        selectedBlock.obj.y = snappedY;
                        selectedBlock.obj.height = newHeight;
                    }
                } else if (resizeEdge === 'bottom') {
                    const newHeight = snappedY - selectedBlock.obj.y;
                    if (newHeight > grid) {
                        selectedBlock.obj.height = newHeight;
                    }
                }
                draw();
            } else if (isDraggingBlock && selectedBlock) {
                // Snap mouse position directly to grid
                const grid = selectedBlock.grid || gridSize;
                selectedBlock.obj.x = snapToGrid(worldPos.x, grid);
                selectedBlock.obj.y = snapToGrid(worldPos.y, grid);
                draw();
            } else if (isDrawing) {
                // Use appropriate grid based on tool
                const grid = currentTool === 'finish' ? startGrid : gridSize;
                const endX = snapToGrid(worldPos.x, grid);
                const endY = snapToGrid(worldPos.y, grid);

                currentRect = {
                    x: Math.min(dragStart.x, endX),
                    y: Math.min(dragStart.y, endY),
                    width: Math.abs(endX - dragStart.x) + grid,
                    height: Math.abs(endY - dragStart.y) + grid
                };

                draw();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isDeleting) {
                isDeleting = false;
            }

            if (isResizing) {
                isResizing = false;
                resizeEdge = null;
                selectedBlock = null;
                updateLevelData();
            }

            if (isDraggingBlock) {
                isDraggingBlock = false;
                selectedBlock = null;
                updateLevelData();
            }

            if (!isDrawing || testMode) return;

            if (currentRect && currentRect.width > 0 && currentRect.height > 0) {
                saveState(); // Save for undo
                if (currentTool === 'platform') {
                    platforms.push({...currentRect});
                } else if (currentTool === 'hazard') {
                    hazards.push({...currentRect});
                } else if (currentTool === 'grower') {
                    growers.push({...currentRect});
                } else if (currentTool === 'shrinker') {
                    shrinkers.push({...currentRect});
                } else if (currentTool === 'background') {
                    backgroundBlocks.push({...currentRect});
                } else if (currentTool === 'foreground') {
                    foregroundBlocks.push({...currentRect});
                } else if (currentTool === 'finish') {
                    // Replace finish position with new drag-created one
                    finishPos.x = currentRect.x;
                    finishPos.y = currentRect.y;
                    finishPos.width = currentRect.width;
                    finishPos.height = currentRect.height;
                }
                updateStats();
                updateLevelData();
            }

            isDrawing = false;
            currentRect = null;
            draw();
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            // Get mouse position before zoom
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const worldPosBefore = screenToWorld(mouseX, mouseY);

            // Apply zoom
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(3, zoom * delta));

            // Adjust camera to keep mouse position fixed
            const zoomRatio = newZoom / zoom;
            cameraX = worldPosBefore.x - (mouseX / newZoom);
            cameraY = worldPosBefore.y - (mouseY / newZoom);

            zoom = newZoom;

            document.getElementById('cameraInfo').textContent =
                `Camera: ${Math.round(cameraX)}, ${Math.round(cameraY)} | Zoom: ${zoom.toFixed(1)}x`;
            draw();
        });

        function deleteAtPosition(x, y) {
            saveState(); // Save for undo
            platforms = platforms.filter(p => !(x >= p.x && x <= p.x + p.width && y >= p.y && y <= p.y + p.height));
            hazards = hazards.filter(h => !(x >= h.x && x <= h.x + h.width && y >= h.y && y <= h.y + h.height));
            growers = growers.filter(g => !(x >= g.x && x <= g.x + g.width && y >= g.y && y <= g.y + g.height));
            shrinkers = shrinkers.filter(s => !(x >= s.x && x <= s.x + s.width && y >= s.y && y <= s.y + s.height));
            backgroundBlocks = backgroundBlocks.filter(b => !(x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height));
            foregroundBlocks = foregroundBlocks.filter(f => !(x >= f.x && x <= f.x + f.width && y >= f.y && y <= f.y + f.height));
            updateStats();
            updateLevelData();
            draw();
        }


        function updateStats() {
            document.getElementById('blockCount').textContent = platforms.length;
            document.getElementById('hazardCount').textContent = hazards.length;
        }

        function updateLevelData() {
            const data = {
                platforms: platforms,
                hazards: hazards,
                growers: growers,
                shrinkers: shrinkers,
                backgroundBlocks: backgroundBlocks,
                foregroundBlocks: foregroundBlocks,
                start: startPos,
                finish: finishPos,
                physics: physics
            };
            document.getElementById('levelData').value = JSON.stringify(data, null, 2);
            // Auto-save to localStorage
            autoSave();
        }

        // Auto-save system
        function autoSave() {
            const data = {
                platforms: platforms,
                hazards: hazards,
                growers: growers,
                shrinkers: shrinkers,
                backgroundBlocks: backgroundBlocks,
                foregroundBlocks: foregroundBlocks,
                start: startPos,
                finish: finishPos,
                physics: physics,
                camera: { x: cameraX, y: cameraY, zoom: zoom }
            };
            localStorage.setItem('levelCreator_autoSave', JSON.stringify(data));
            localStorage.setItem('levelCreator_lastSaved', new Date().toISOString());
            updateSaveStatus();
        }

        function updateSaveStatus() {
            const lastSaved = localStorage.getItem('levelCreator_lastSaved');
            if (lastSaved) {
                const date = new Date(lastSaved);
                const timeStr = date.toLocaleTimeString();
                document.getElementById('saveStatus').textContent = `Auto-saved at ${timeStr}`;
                document.getElementById('saveStatus').style.color = '#4facfe';
            }
        }

        function loadAutoSave() {
            const saved = localStorage.getItem('levelCreator_autoSave');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    platforms = data.platforms || [];
                    hazards = data.hazards || [];
                    growers = data.growers || [];
                    shrinkers = data.shrinkers || [];
                    backgroundBlocks = data.backgroundBlocks || [];
                    foregroundBlocks = data.foregroundBlocks || [];
                    startPos = data.start || { x: 40, y: 520, width: 40, height: 40 };
                    finishPos = data.finish || { x: 700, y: 480, width: 40, height: 40 };
                    if (data.camera) {
                        cameraX = data.camera.x;
                        cameraY = data.camera.y;
                        zoom = data.camera.zoom;
                    }
                    updateStats();
                    updateLevelData();
                    updateSaveStatus();
                    draw();
                    return true;
                } catch (e) {
                    console.error('Failed to load auto-save:', e);
                }
            }
            return false;
        }

        function clearAutoSave() {
            if (confirm('Clear auto-saved level and start fresh?')) {
                localStorage.removeItem('levelCreator_autoSave');
                localStorage.removeItem('levelCreator_lastSaved');
                platforms = [];
                hazards = [];
                growers = [];
                shrinkers = [];
                backgroundBlocks = [];
                foregroundBlocks = [];
                startPos = { x: 40, y: 520, width: 40, height: 40 };
                finishPos = { x: 700, y: 480, width: 40, height: 40 };
                cameraX = 0;
                cameraY = 0;
                zoom = 1;
                updateStats();
                updateLevelData();
                document.getElementById('saveStatus').textContent = 'No auto-save';
                document.getElementById('saveStatus').style.color = '#999';
                draw();
            }
        }

        function copyLevelData() {
            const textarea = document.getElementById('levelData');
            textarea.select();
            document.execCommand('copy');
            alert('Level data copied to clipboard!');
        }

        function clearLevel() {
            if (confirm('Are you sure you want to clear everything?')) {
                platforms = [];
                hazards = [];
                updateStats();
                updateLevelData();
                draw();
            }
        }

        function showImportDialog() {
            document.getElementById('importModal').classList.add('show');
            document.getElementById('importModalText').value = '';
            document.getElementById('importModalText').focus();
        }

        function closeImportModal() {
            document.getElementById('importModal').classList.remove('show');
        }

        function doImport() {
            const importText = document.getElementById('importModalText').value.trim();
            if (!importText) {
                alert('Please paste level data first');
                return;
            }

            importLevel(importText);
            closeImportModal();
        }

        function importLevel(importText) {
            if (!importText) {
                alert('Please paste level data first');
                return;
            }

            try {
                const data = JSON.parse(importText);

                // Validate data structure
                if (!data.platforms || !data.hazards || !data.start || !data.finish) {
                    alert('Invalid level data format');
                    return;
                }

                // Import the data
                platforms = data.platforms || [];
                hazards = data.hazards || [];
                growers = data.growers || [];
                shrinkers = data.shrinkers || [];
                backgroundBlocks = data.backgroundBlocks || [];
                foregroundBlocks = data.foregroundBlocks || [];
                startPos = data.start || { x: 40, y: 520, width: 40, height: 40 };
                finishPos = data.finish || { x: 700, y: 480, width: 40, height: 40 };

                // Ensure start and finish have width/height
                if (!startPos.width) startPos.width = 40;
                if (!startPos.height) startPos.height = 40;
                if (!finishPos.width) finishPos.width = 40;
                if (!finishPos.height) finishPos.height = 40;

                // Update UI
                updateStats();
                updateLevelData();
                draw();

                alert('Level imported successfully!');
            } catch (error) {
                alert('Error parsing level data. Please check your JSON format.');
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.scale(zoom, zoom);
            ctx.translate(-cameraX, -cameraY);

            // Coordinate plane axes
            ctx.strokeStyle = 'rgba(79, 172, 254, 0.5)';
            ctx.lineWidth = 2 / zoom;
            // X-axis (y=0)
            ctx.beginPath();
            ctx.moveTo(cameraX, 0);
            ctx.lineTo(cameraX + canvas.width / zoom, 0);
            ctx.stroke();
            // Y-axis (x=0)
            ctx.beginPath();
            ctx.moveTo(0, cameraY);
            ctx.lineTo(0, cameraY + canvas.height / zoom);
            ctx.stroke();

            // Grid (toggle with G key)
            if (gridVisible) {
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1 / zoom;
                const startGridX = Math.floor(cameraX / gridSize) * gridSize;
                const startGridY = Math.floor(cameraY / gridSize) * gridSize;
                const endGridX = startGridX + (canvas.width / zoom) + gridSize;
                const endGridY = startGridY + (canvas.height / zoom) + gridSize;

                for (let x = startGridX; x < endGridX; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, startGridY);
                    ctx.lineTo(x, endGridY);
                    ctx.stroke();
                }

                for (let y = startGridY; y < endGridY; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(startGridX, y);
                    ctx.lineTo(endGridX, y);
                    ctx.stroke();
                }
            }

            // Coordinate labels
            ctx.fillStyle = '#4facfe';
            ctx.font = `${12 / zoom}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            // X-axis labels
            for (let x = Math.ceil(cameraX / 100) * 100; x < cameraX + canvas.width / zoom; x += 100) {
                ctx.fillText(x.toString(), x, 0 - 5 / zoom);
            }
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            // Y-axis labels
            for (let y = Math.ceil(cameraY / 100) * 100; y < cameraY + canvas.height / zoom; y += 100) {
                ctx.fillText(y.toString(), 0 + 5 / zoom, y);
            }

            // Background blocks (visual only, rendered first)
            backgroundBlocks.forEach(b => {
                ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                ctx.fillRect(b.x, b.y, b.width, b.height);
                ctx.strokeStyle = 'rgba(80, 80, 80, 0.5)';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(b.x, b.y, b.width, b.height);
            });

            // Platforms
            platforms.forEach(p => {
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(p.x, p.y, p.width, p.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(p.x, p.y, p.width, p.height);
            });

            // Hazards
            hazards.forEach(h => {
                ctx.fillStyle = '#FF3333';
                ctx.fillRect(h.x, h.y, h.width, h.height);
                ctx.strokeStyle = '#CC0000';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(h.x, h.y, h.width, h.height);
            });

            // Growers (green pads - 2x size)
            growers.forEach(g => {
                ctx.fillStyle = '#00FF88';
                ctx.fillRect(g.x, g.y, g.width, g.height);
                ctx.strokeStyle = '#00CC66';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(g.x, g.y, g.width, g.height);
            });

            // Shrinkers (purple pads - 0.5x size)
            shrinkers.forEach(s => {
                ctx.fillStyle = '#BB66FF';
                ctx.fillRect(s.x, s.y, s.width, s.height);
                ctx.strokeStyle = '#9944DD';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(s.x, s.y, s.width, s.height);
            });

            // Current drawing
            if (currentRect) {
                if (currentTool === 'platform') {
                    ctx.fillStyle = 'rgba(76, 175, 80, 0.5)';
                    ctx.strokeStyle = '#4CAF50';
                } else if (currentTool === 'hazard') {
                    ctx.fillStyle = 'rgba(255, 51, 51, 0.5)';
                    ctx.strokeStyle = '#FF3333';
                } else if (currentTool === 'grower') {
                    ctx.fillStyle = 'rgba(0, 255, 136, 0.5)';
                    ctx.strokeStyle = '#00FF88';
                } else if (currentTool === 'shrinker') {
                    ctx.fillStyle = 'rgba(187, 102, 255, 0.5)';
                    ctx.strokeStyle = '#BB66FF';
                } else if (currentTool === 'background') {
                    ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                    ctx.strokeStyle = 'rgba(80, 80, 80, 0.5)';
                } else if (currentTool === 'foreground') {
                    ctx.fillStyle = 'rgba(200, 200, 200, 0.4)';
                    ctx.strokeStyle = 'rgba(180, 180, 180, 0.6)';
                } else if (currentTool === 'finish') {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                    ctx.strokeStyle = '#FFD700';
                }
                ctx.fillRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
            }

            // Start position
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(startPos.x, startPos.y, 40, 40);
            ctx.strokeStyle = '#00AA00';
            ctx.lineWidth = 2 / zoom;
            ctx.strokeRect(startPos.x, startPos.y, 40, 40);

            // Finish line
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(finishPos.x, finishPos.y, finishPos.width, finishPos.height);
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 2 / zoom;
            ctx.strokeRect(finishPos.x, finishPos.y, finishPos.width, finishPos.height);

            // Player preview (40x40 reference)
            if (playerPreview.visible) {
                ctx.fillStyle = 'rgba(255, 165, 0, 0.5)';
                ctx.fillRect(playerPreview.x, playerPreview.y, 40, 40);
                ctx.strokeStyle = '#FFA500';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(playerPreview.x, playerPreview.y, 40, 40);
            }

            // Selected block highlight
            if (selectedBlock && isDraggingBlock) {
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3 / zoom;
                ctx.setLineDash([10 / zoom, 5 / zoom]);
                ctx.strokeRect(selectedBlock.obj.x, selectedBlock.obj.y, selectedBlock.obj.width, selectedBlock.obj.height);
                ctx.setLineDash([]);
            }

            // Player in test mode
            if (testMode) {
                ctx.fillStyle = '#FF5722';
                ctx.fillRect(player.x, player.y, player.width, player.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(player.x, player.y, player.width, player.height);
            }

            // Foreground blocks (visual only, rendered on top)
            foregroundBlocks.forEach(f => {
                ctx.fillStyle = 'rgba(200, 200, 200, 0.4)';
                ctx.fillRect(f.x, f.y, f.width, f.height);
                ctx.strokeStyle = 'rgba(180, 180, 180, 0.6)';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(f.x, f.y, f.width, f.height);
            });

            ctx.restore();
        }

        function goToCoordinates() {
            const x = parseFloat(document.getElementById('camX').value) || 0;
            const y = parseFloat(document.getElementById('camY').value) || 0;
            cameraX = x;
            cameraY = y;
            document.getElementById('cameraInfo').textContent =
                `Camera: ${Math.round(cameraX)}, ${Math.round(cameraY)} | Zoom: ${zoom.toFixed(1)}x`;
            draw();
        }

        // Camera movement with WASD
        let cameraMoveSpeed = 10;
        setInterval(() => {
            if (testMode) return;

            if (keys['KeyW'] || keys['ArrowUp']) cameraY -= cameraMoveSpeed / zoom;
            if (keys['KeyS'] || keys['ArrowDown']) cameraY += cameraMoveSpeed / zoom;
            if (keys['KeyA'] || keys['ArrowLeft']) cameraX -= cameraMoveSpeed / zoom;
            if (keys['KeyD'] || keys['ArrowRight']) cameraX += cameraMoveSpeed / zoom;

            if (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'] ||
                keys['ArrowUp'] || keys['ArrowDown'] || keys['ArrowLeft'] || keys['ArrowRight']) {
                document.getElementById('cameraInfo').textContent =
                    `Camera: ${Math.round(cameraX)}, ${Math.round(cameraY)} | Zoom: ${zoom.toFixed(1)}x`;
                draw();
            }
        }, 16);

        // Test mode functions
        function testLevel() {
            testMode = true;
            zoom = 1; // Reset zoom to match actual game
            player.x = startPos.x;
            player.y = startPos.y;
            player.velocityX = 0;
            player.velocityY = 0;
            player.width = 40;
            player.height = 40;
            player.currentSize = 40;
            sizeTransitioning = false;
            lastFrameTime = performance.now(); // Reset frame time for delta calculation
            requestAnimationFrame(gameLoop);
        }

        function stopTest() {
            testMode = false;
            draw();
        }

        let lastFrameTime = performance.now();
        function gameLoop(currentTime) {
            if (!testMode) return;

            // Calculate delta time (normalize to 60fps baseline)
            const deltaTime = (currentTime - lastFrameTime) / 16.67;
            lastFrameTime = currentTime;

            updatePlayer(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        function updatePlayer(deltaTime = 1) {
            // Update size transition
            updateSizeTransition(deltaTime);

            // Freeze movement during transition
            if (!sizeTransitioning) {
                // Scale factors based on player size (40 is base)
                const sizeScale = player.currentSize / 40;

                // Gravity (with fast fall)
                if ((keys['KeyS'] || keys['ArrowDown']) && !isGrounded) {
                    player.velocityY += physics.gravity * physics.fastFallMultiplier * deltaTime;  // Fall 1.75x faster
                } else {
                    player.velocityY += physics.gravity * deltaTime;
                }

                // Movement (scaled by size)
                const moveSpeed = physics.moveSpeed * sizeScale;
                if (keys['KeyA'] || keys['ArrowLeft']) {
                    player.velocityX -= moveSpeed * deltaTime;
                }
                if (keys['KeyD'] || keys['ArrowRight']) {
                    player.velocityX += moveSpeed * deltaTime;
                }

                // Jump - Variable height, scaled by size
                if ((keys['KeyW'] || keys['ArrowUp'] || keys['Space']) && isGrounded) {
                    player.velocityY = -physics.jumpPower * sizeScale;
                    isJumping = true;
                }

                // Cut jump short if button released (variable jump height)
                if (isJumping && !keys['KeyW'] && !keys['ArrowUp'] && !keys['Space']) {
                    if (player.velocityY < 0) {
                        player.velocityY *= 0.5;
                    }
                    isJumping = false;
                }

                // Reset jump state when grounded
                if (isGrounded && player.velocityY >= 0) {
                    isJumping = false;
                }

                // Apply friction (using exponential decay for frame-rate independence)
                if (isGrounded) {
                    player.velocityX *= Math.pow(physics.friction, deltaTime);
                } else {
                    player.velocityX *= Math.pow(physics.airRes, deltaTime);
                }

                player.velocityX = Math.max(-physics.maxSpeed * sizeScale, Math.min(physics.maxSpeed * sizeScale, player.velocityX));

                player.x += player.velocityX * deltaTime;
                player.y += player.velocityY * deltaTime;
            }

            checkCollision();
            checkHazards();
            checkGrowers();
            checkShrinkers();
            checkFinish();

            // Keep camera centered on player
            cameraX = player.x - canvas.width / (2 * zoom);
            cameraY = player.y - canvas.height / (2 * zoom);
        }

        function checkCollision() {
            isGrounded = false;

            for (let platform of platforms) {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {

                    const overlapLeft = (player.x + player.width) - platform.x;
                    const overlapRight = (platform.x + platform.width) - player.x;
                    const overlapTop = (player.y + player.height) - platform.y;
                    const overlapBottom = (platform.y + platform.height) - player.y;

                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    if (minOverlap === overlapTop && player.velocityY >= 0) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        isGrounded = true;
                    }
                    else if (minOverlap === overlapBottom && player.velocityY < 0) {
                        player.y = platform.y + platform.height;
                        player.velocityY = 0;
                    }
                    else if (minOverlap === overlapLeft) {
                        player.x = platform.x - player.width;
                        player.velocityX = 0;
                    }
                    else if (minOverlap === overlapRight) {
                        player.x = platform.x + platform.width;
                        player.velocityX = 0;
                    }
                }
            }
        }

        function checkHazards() {
            for (let hazard of hazards) {
                if (player.x + player.width > hazard.x &&
                    player.x < hazard.x + hazard.width &&
                    player.y + player.height > hazard.y &&
                    player.y < hazard.y + hazard.height) {
                    player.x = startPos.x;
                    player.y = startPos.y;
                    player.velocityX = 0;
                    player.velocityY = 0;
                    player.currentSize = 40;
                    player.width = 40;
                    player.height = 40;
                    return;
                }
            }
        }

        function checkGrowers() {
            for (let grower of growers) {
                if (player.x + player.width > grower.x &&
                    player.x < grower.x + grower.width &&
                    player.y + player.height > grower.y &&
                    player.y < grower.y + grower.height) {
                    if (player.currentSize !== 80 && !sizeTransitioning) {
                        startSizeTransition(80);
                    }
                    return;
                }
            }
        }

        function checkShrinkers() {
            for (let shrinker of shrinkers) {
                if (player.x + player.width > shrinker.x &&
                    player.x < shrinker.x + shrinker.width &&
                    player.y + player.height > shrinker.y &&
                    player.y < shrinker.y + shrinker.height) {
                    if (player.currentSize !== 20 && !sizeTransitioning) {
                        startSizeTransition(20);
                    }
                    return;
                }
            }
        }

        function startSizeTransition(newSize) {
            sizeTransitioning = true;
            targetSize = newSize;
            sizeTransitionProgress = 0;
        }

        function updateSizeTransition(deltaTime) {
            if (!sizeTransitioning) return;

            sizeTransitionProgress += deltaTime * 0.1;  // Transition speed

            if (sizeTransitionProgress >= 1) {
                // Transition complete
                sizeTransitioning = false;
                player.currentSize = targetSize;
                player.width = targetSize;
                player.height = targetSize;
            } else {
                // Interpolate size
                const startSize = player.currentSize;
                const t = sizeTransitionProgress;
                const newSize = startSize + (targetSize - startSize) * t;
                player.width = newSize;
                player.height = newSize;
            }
        }

        function checkFinish() {
            if (player.x + player.width > finishPos.x &&
                player.x < finishPos.x + finishPos.width &&
                player.y + player.height > finishPos.y &&
                player.y < finishPos.y + finishPos.height) {
                alert('Level Complete!');
                stopTest();
            }
        }

        // Copy/Paste for blocks
        let copiedBlock = null;

        // Keyboard events
        document.addEventListener('keydown', (e) => {
            // Don't capture keys when modal is open
            const modalOpen = document.getElementById('importModal').classList.contains('show');
            if (modalOpen) {
                if (e.code === 'Escape') {
                    closeImportModal();
                    e.preventDefault();
                }
                return;
            }

            keys[e.code] = true;

            // Undo/Redo shortcuts
            if (e.ctrlKey && e.code === 'KeyZ' && !testMode) {
                undo();
                e.preventDefault();
                return;
            }
            if (e.ctrlKey && e.code === 'KeyY' && !testMode) {
                redo();
                e.preventDefault();
                return;
            }

            // Copy selected block
            if (e.ctrlKey && e.code === 'KeyC' && selectedBlock && !testMode) {
                copiedBlock = JSON.parse(JSON.stringify(selectedBlock.obj));
                e.preventDefault();
                return;
            }

            // Paste block
            if (e.ctrlKey && e.code === 'KeyV' && copiedBlock && !testMode) {
                saveState();
                const newBlock = JSON.parse(JSON.stringify(copiedBlock));
                newBlock.x += 20;
                newBlock.y += 20;

                if (selectedBlock) {
                    if (selectedBlock.type === 'platform') platforms.push(newBlock);
                    else if (selectedBlock.type === 'hazard') hazards.push(newBlock);
                    else if (selectedBlock.type === 'grower') growers.push(newBlock);
                    else if (selectedBlock.type === 'shrinker') shrinkers.push(newBlock);
                    else if (selectedBlock.type === 'background') backgroundBlocks.push(newBlock);
                    else if (selectedBlock.type === 'foreground') foregroundBlocks.push(newBlock);
                }
                updateStats();
                updateLevelData();
                draw();
                e.preventDefault();
                return;
            }

            // Delete selected block
            if (e.code === 'Delete' && selectedBlock && !testMode) {
                saveState();
                if (selectedBlock.type === 'platform') platforms.splice(selectedBlock.index, 1);
                else if (selectedBlock.type === 'hazard') hazards.splice(selectedBlock.index, 1);
                else if (selectedBlock.type === 'grower') growers.splice(selectedBlock.index, 1);
                else if (selectedBlock.type === 'shrinker') shrinkers.splice(selectedBlock.index, 1);
                else if (selectedBlock.type === 'background') backgroundBlocks.splice(selectedBlock.index, 1);
                else if (selectedBlock.type === 'foreground') foregroundBlocks.splice(selectedBlock.index, 1);
                selectedBlock = null;
                updateStats();
                updateLevelData();
                draw();
                e.preventDefault();
                return;
            }

            // Tool shortcuts (1-9 keys)
            if (!testMode) {
                if (e.code === 'Digit1') setToolByName('platform');
                else if (e.code === 'Digit2') setToolByName('hazard');
                else if (e.code === 'Digit3') setToolByName('grower');
                else if (e.code === 'Digit4') setToolByName('shrinker');
                else if (e.code === 'Digit5') setToolByName('select');
                else if (e.code === 'Digit6') setToolByName('delete');
                else if (e.code === 'KeyG') toggleGrid();
            }

            if (e.code === 'KeyR' && testMode) {
                player.x = startPos.x;
                player.y = startPos.y;
                player.velocityX = 0;
                player.velocityY = 0;
            }

            if (e.code === 'Escape' && testMode) {
                stopTest();
            }

            if (e.code === 'Space' && !testMode) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            // Don't capture keys when modal is open
            const modalOpen = document.getElementById('importModal').classList.contains('show');
            if (modalOpen) {
                return;
            }

            keys[e.code] = false;
            e.preventDefault();
        });

        // Stop event propagation for import modal textarea
        const importTextarea = document.getElementById('importModalText');
        importTextarea.addEventListener('keydown', (e) => {
            e.stopPropagation();
        });
        importTextarea.addEventListener('keyup', (e) => {
            e.stopPropagation();
        });
        importTextarea.addEventListener('keypress', (e) => {
            e.stopPropagation();
        });

        // Window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth - 250;
            canvas.height = window.innerHeight;
            draw();
        });

        // Initial setup
        // Try to load auto-save on startup
        const hasAutoSave = loadAutoSave();
        if (!hasAutoSave) {
            updateLevelData();
            draw();
        }
    </script>
</body>
</html>
