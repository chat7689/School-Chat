<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level Creator - Speedrun Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #2c3e50;
            font-family: 'Arial', sans-serif;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 250px;
            background: #87CEEB;
            cursor: crosshair;
            pointer-events: auto;
        }

        #sidebar {
            position: absolute;
            top: 0;
            left: 0;
            width: 250px;
            height: 100vh;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px;
            overflow-y: auto;
            z-index: 100;
            pointer-events: auto;
        }

        #topbar {
            position: absolute;
            top: 0;
            left: 250px;
            right: 0;
            height: 60px;
            background: rgba(0,0,0,0.8);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            z-index: 100;
        }

        .section {
            margin-bottom: 25px;
        }

        .section h3 {
            color: #4facfe;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .slider-group {
            margin-bottom: 15px;
        }

        .slider-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: #ccc;
        }

        .slider-group input[type="range"] {
            width: 100%;
        }

        .slider-group .value {
            color: #4facfe;
            font-weight: bold;
            float: right;
        }

        .tool-button {
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(79, 172, 254, 0.2);
            color: white;
            border: 2px solid #4facfe;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .tool-button:hover {
            background: rgba(79, 172, 254, 0.4);
        }

        .tool-button.active {
            background: #4facfe;
            color: black;
        }

        .tool-button.delete {
            background: rgba(255, 68, 68, 0.2);
            border-color: #ff4444;
        }

        .tool-button.delete:hover {
            background: rgba(255, 68, 68, 0.4);
        }

        .tool-button.delete.active {
            background: #ff4444;
        }

        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        button:hover {
            background: #45a049;
        }

        button.secondary {
            background: #666;
        }

        button.secondary:hover {
            background: #555;
        }

        input[type="number"] {
            width: 80px;
            padding: 5px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid #4facfe;
            border-radius: 3px;
        }

        .info-text {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }

        #levelData, #importData {
            width: 100%;
            height: 150px;
            background: rgba(0,0,0,0.5);
            color: #4facfe;
            border: 1px solid #4facfe;
            border-radius: 5px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            resize: none;
            pointer-events: auto;
            position: relative;
            z-index: 200;
        }

        #importData:focus, #levelData:focus {
            outline: none;
            border-color: #FFC107;
            background: rgba(0,0,0,0.7);
        }

        .stats {
            font-size: 12px;
            color: #ccc;
        }

        .controls-info {
            background: rgba(79, 172, 254, 0.1);
            padding: 10px;
            border-radius: 5px;
            font-size: 11px;
            line-height: 1.6;
        }

        #importModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        #importModal.show {
            display: flex;
        }

        .modal-content {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #4facfe;
            width: 90%;
            max-width: 600px;
        }

        .modal-content h2 {
            color: #4facfe;
            margin-bottom: 20px;
        }

        .modal-content textarea {
            width: 100%;
            height: 300px;
            background: rgba(0,0,0,0.5);
            color: #4facfe;
            border: 1px solid #4facfe;
            border-radius: 5px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: none;
        }

        .modal-content textarea:focus {
            outline: none;
            border-color: #FFC107;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            flex: 1;
        }
    </style>
</head>
<body>
    <div id="topbar">
        <button onclick="testLevel()">‚ñ∂ Test Level</button>
        <button onclick="stopTest()" class="secondary">‚èπ Stop Test</button>
        <button onclick="clearLevel()" class="secondary">üóë Clear All</button>
        <button onclick="copyLevelData()">üìã Copy Level Data</button>
        <button onclick="showImportDialog()" style="background: #9b59b6;">üì• Import Level</button>
        <span style="margin-left: auto; font-size: 12px;" id="cameraInfo">Camera: 0, 0 | Zoom: 1.0x</span>
    </div>

    <div id="sidebar">
        <h2 style="color: #4facfe; margin-bottom: 20px;">Level Creator</h2>

        <div class="section">
            <h3>Tools</h3>
            <button class="tool-button active" onclick="setTool('platform')">üü¶ Platform</button>
            <button class="tool-button" onclick="setTool('hazard')">üü• Hazard (Kill)</button>
            <button class="tool-button" onclick="setTool('start')">üü¢ Start Position</button>
            <button class="tool-button" onclick="setTool('finish')">üèÅ Finish Line</button>
            <button class="tool-button" onclick="setTool('player')">üë§ Player (40x40)</button>
            <button class="tool-button" onclick="setTool('select')">‚úã Select/Move</button>
            <button class="tool-button delete" onclick="setTool('delete')">üóë Delete</button>
        </div>

        <div class="section">
            <h3>Grid Settings</h3>
            <div class="slider-group">
                <label>Grid Size: <span class="value" id="gridValue">20</span>px</label>
                <input type="range" min="5" max="50" value="20" id="gridSize" oninput="updateGrid()">
            </div>
            <div class="stats">Blocks: <span id="blockCount">0</span> | Hazards: <span id="hazardCount">0</span></div>
        </div>

        <div class="section">
            <h3>Camera Navigation</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <div style="flex: 1;">
                    <label style="font-size: 12px; color: #ccc; display: block; margin-bottom: 5px;">X:</label>
                    <input type="number" id="camX" value="0" placeholder="X">
                </div>
                <div style="flex: 1;">
                    <label style="font-size: 12px; color: #ccc; display: block; margin-bottom: 5px;">Y:</label>
                    <input type="number" id="camY" value="0" placeholder="Y">
                </div>
            </div>
            <button onclick="goToCoordinates()" style="width: 100%; padding: 8px; font-size: 12px;">Go to Coordinates</button>
        </div>

        <div class="section">
            <h3>Physics Info</h3>
            <div class="stats" style="line-height: 1.8;">
                <div>Gravity: <span style="color: #4facfe;">0.028</span></div>
                <div>Move Speed: <span style="color: #4facfe;">1.0</span></div>
                <div>Jump Power: <span style="color: #4facfe;">3.0</span></div>
                <div>Max Speed: <span style="color: #4facfe;">1.0</span></div>
                <div>Ground Friction: <span style="color: #4facfe;">0.94</span></div>
                <div>Air Resistance: <span style="color: #4facfe;">0.99</span></div>
                <div style="margin-top: 10px; color: #FFC107;">Jump Height: ~160px</div>
            </div>
        </div>

        <div class="section">
            <h3>Controls</h3>
            <div class="controls-info">
                <strong>Creator Mode:</strong><br>
                ‚Ä¢ Mouse: Drag to create<br>
                ‚Ä¢ Scroll: Zoom in/out<br>
                ‚Ä¢ WASD: Pan camera<br>
                ‚Ä¢ Click: Place start/finish<br>
                <br>
                <strong>Test Mode:</strong><br>
                ‚Ä¢ Arrow Keys: Move<br>
                ‚Ä¢ WASD: Move<br>
                ‚Ä¢ Space: Boost<br>
                ‚Ä¢ R: Restart<br>
                ‚Ä¢ ESC: Exit test
            </div>
        </div>

        <div class="section">
            <h3>Export Level</h3>
            <textarea id="levelData" readonly></textarea>
            <p class="info-text">Level data will appear here. Click "Copy Level Data" to copy.</p>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <!-- Import Modal -->
    <div id="importModal">
        <div class="modal-content">
            <h2>üì• Import Level</h2>
            <textarea id="importModalText" placeholder="Paste your level JSON here..."></textarea>
            <div class="modal-buttons">
                <button onclick="doImport()">Import</button>
                <button onclick="closeImportModal()" class="secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Canvas size
        canvas.width = window.innerWidth - 250;
        canvas.height = window.innerHeight;

        // Level data
        let platforms = [];
        let hazards = [];
        let startPos = { x: 50, y: 520 };
        let finishPos = { x: 700, y: 470, width: 100, height: 50 };

        // Tool state
        let currentTool = 'platform';
        let gridSize = 20;
        let isDrawing = false;
        let dragStart = null;
        let currentRect = null;
        let selectedBlock = null;
        let isDraggingBlock = false;
        let dragOffset = { x: 0, y: 0 };
        let playerPreview = { x: 0, y: 0, visible: false };

        // Camera
        let cameraX = 0;
        let cameraY = 0;
        let zoom = 1;

        // Physics settings (fixed values)
        const physics = {
            gravity: 0.028,
            moveSpeed: 1,
            jumpPower: 3,
            maxSpeed: 1,
            friction: 0.94,
            airRes: 0.99
        };

        // Test mode
        let testMode = false;
        let player = { x: 0, y: 0, width: 40, height: 40, velocityX: 0, velocityY: 0 };
        let keys = {};
        let isGrounded = false;

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function updateGrid() {
            gridSize = parseInt(document.getElementById('gridSize').value);
            document.getElementById('gridValue').textContent = gridSize;
            draw();
        }

        // Physics are now fixed, no need for update function

        function snapToGrid(value) {
            return Math.round(value / gridSize) * gridSize;
        }

        function screenToWorld(x, y) {
            return {
                x: (x / zoom) + cameraX,
                y: (y / zoom) + cameraY
            };
        }

        function worldToScreen(x, y) {
            return {
                x: (x - cameraX) * zoom,
                y: (y - cameraY) * zoom
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            if (testMode) return;

            const rect = canvas.getBoundingClientRect();
            const worldPos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);

            if (currentTool === 'select') {
                // Check if clicking on an existing block
                selectedBlock = null;
                for (let i = platforms.length - 1; i >= 0; i--) {
                    const p = platforms[i];
                    if (worldPos.x >= p.x && worldPos.x <= p.x + p.width &&
                        worldPos.y >= p.y && worldPos.y <= p.y + p.height) {
                        selectedBlock = { type: 'platform', index: i, obj: p };
                        isDraggingBlock = true;
                        dragOffset.x = worldPos.x - p.x;
                        dragOffset.y = worldPos.y - p.y;
                        break;
                    }
                }
                if (!selectedBlock) {
                    for (let i = hazards.length - 1; i >= 0; i--) {
                        const h = hazards[i];
                        if (worldPos.x >= h.x && worldPos.x <= h.x + h.width &&
                            worldPos.y >= h.y && worldPos.y <= h.y + h.height) {
                            selectedBlock = { type: 'hazard', index: i, obj: h };
                            isDraggingBlock = true;
                            dragOffset.x = worldPos.x - h.x;
                            dragOffset.y = worldPos.y - h.y;
                            break;
                        }
                    }
                }
            } else if (currentTool === 'delete') {
                deleteAtPosition(worldPos.x, worldPos.y);
            } else if (currentTool === 'start') {
                startPos.x = snapToGrid(worldPos.x);
                startPos.y = snapToGrid(worldPos.y);
                draw();
            } else if (currentTool === 'finish') {
                finishPos.x = snapToGrid(worldPos.x);
                finishPos.y = snapToGrid(worldPos.y);
                draw();
            } else if (currentTool === 'player') {
                playerPreview.x = snapToGrid(worldPos.x);
                playerPreview.y = snapToGrid(worldPos.y);
                playerPreview.visible = true;
                draw();
            } else {
                isDrawing = true;
                dragStart = {
                    x: snapToGrid(worldPos.x),
                    y: snapToGrid(worldPos.y)
                };
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (testMode) return;

            const rect = canvas.getBoundingClientRect();
            const worldPos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);

            if (isDraggingBlock && selectedBlock) {
                const newX = snapToGrid(worldPos.x - dragOffset.x);
                const newY = snapToGrid(worldPos.y - dragOffset.y);
                selectedBlock.obj.x = newX;
                selectedBlock.obj.y = newY;
                draw();
            } else if (isDrawing) {
                const endX = snapToGrid(worldPos.x);
                const endY = snapToGrid(worldPos.y);

                currentRect = {
                    x: Math.min(dragStart.x, endX),
                    y: Math.min(dragStart.y, endY),
                    width: Math.abs(endX - dragStart.x) + gridSize,
                    height: Math.abs(endY - dragStart.y) + gridSize
                };

                draw();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isDraggingBlock) {
                isDraggingBlock = false;
                selectedBlock = null;
                updateLevelData();
            }

            if (!isDrawing || testMode) return;

            if (currentRect && currentRect.width > 0 && currentRect.height > 0) {
                if (currentTool === 'platform') {
                    platforms.push({...currentRect});
                } else if (currentTool === 'hazard') {
                    hazards.push({...currentRect});
                }
                updateStats();
                updateLevelData();
            }

            isDrawing = false;
            currentRect = null;
            draw();
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            // Get mouse position before zoom
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const worldPosBefore = screenToWorld(mouseX, mouseY);

            // Apply zoom
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(3, zoom * delta));

            // Adjust camera to keep mouse position fixed
            const zoomRatio = newZoom / zoom;
            cameraX = worldPosBefore.x - (mouseX / newZoom);
            cameraY = worldPosBefore.y - (mouseY / newZoom);

            zoom = newZoom;

            document.getElementById('cameraInfo').textContent =
                `Camera: ${Math.round(cameraX)}, ${Math.round(cameraY)} | Zoom: ${zoom.toFixed(1)}x`;
            draw();
        });

        function deleteAtPosition(x, y) {
            platforms = platforms.filter(p => !(x >= p.x && x <= p.x + p.width && y >= p.y && y <= p.y + p.height));
            hazards = hazards.filter(h => !(x >= h.x && x <= h.x + h.width && y >= h.y && y <= h.y + h.height));
            updateStats();
            updateLevelData();
            draw();
        }

        function updateStats() {
            document.getElementById('blockCount').textContent = platforms.length;
            document.getElementById('hazardCount').textContent = hazards.length;
        }

        function updateLevelData() {
            const data = {
                platforms: platforms,
                hazards: hazards,
                start: startPos,
                finish: finishPos,
                physics: physics
            };
            document.getElementById('levelData').value = JSON.stringify(data, null, 2);
        }

        function copyLevelData() {
            const textarea = document.getElementById('levelData');
            textarea.select();
            document.execCommand('copy');
            alert('Level data copied to clipboard!');
        }

        function clearLevel() {
            if (confirm('Are you sure you want to clear everything?')) {
                platforms = [];
                hazards = [];
                updateStats();
                updateLevelData();
                draw();
            }
        }

        function showImportDialog() {
            document.getElementById('importModal').classList.add('show');
            document.getElementById('importModalText').value = '';
            document.getElementById('importModalText').focus();
        }

        function closeImportModal() {
            document.getElementById('importModal').classList.remove('show');
        }

        function doImport() {
            const importText = document.getElementById('importModalText').value.trim();
            if (!importText) {
                alert('Please paste level data first');
                return;
            }

            importLevel(importText);
            closeImportModal();
        }

        function importLevel(importText) {
            if (!importText) {
                alert('Please paste level data first');
                return;
            }

            try {
                const data = JSON.parse(importText);

                // Validate data structure
                if (!data.platforms || !data.hazards || !data.start || !data.finish) {
                    alert('Invalid level data format');
                    return;
                }

                // Import the data
                platforms = data.platforms || [];
                hazards = data.hazards || [];
                startPos = data.start || { x: 50, y: 520 };
                finishPos = data.finish || { x: 700, y: 470, width: 100, height: 50 };

                // Update UI
                updateStats();
                updateLevelData();
                draw();

                alert('Level imported successfully!');
            } catch (error) {
                alert('Error parsing level data: ' + error.message);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.scale(zoom, zoom);
            ctx.translate(-cameraX, -cameraY);

            // Coordinate plane axes
            ctx.strokeStyle = 'rgba(79, 172, 254, 0.5)';
            ctx.lineWidth = 2 / zoom;
            // X-axis (y=0)
            ctx.beginPath();
            ctx.moveTo(cameraX, 0);
            ctx.lineTo(cameraX + canvas.width / zoom, 0);
            ctx.stroke();
            // Y-axis (x=0)
            ctx.beginPath();
            ctx.moveTo(0, cameraY);
            ctx.lineTo(0, cameraY + canvas.height / zoom);
            ctx.stroke();

            // Grid
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1 / zoom;
            const startGridX = Math.floor(cameraX / gridSize) * gridSize;
            const startGridY = Math.floor(cameraY / gridSize) * gridSize;
            const endGridX = startGridX + (canvas.width / zoom) + gridSize;
            const endGridY = startGridY + (canvas.height / zoom) + gridSize;

            for (let x = startGridX; x < endGridX; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, startGridY);
                ctx.lineTo(x, endGridY);
                ctx.stroke();
            }

            for (let y = startGridY; y < endGridY; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(startGridX, y);
                ctx.lineTo(endGridX, y);
                ctx.stroke();
            }

            // Coordinate labels
            ctx.fillStyle = '#4facfe';
            ctx.font = `${12 / zoom}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            // X-axis labels
            for (let x = Math.ceil(cameraX / 100) * 100; x < cameraX + canvas.width / zoom; x += 100) {
                ctx.fillText(x.toString(), x, 0 - 5 / zoom);
            }
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            // Y-axis labels
            for (let y = Math.ceil(cameraY / 100) * 100; y < cameraY + canvas.height / zoom; y += 100) {
                ctx.fillText(y.toString(), 0 + 5 / zoom, y);
            }

            // Platforms
            platforms.forEach(p => {
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(p.x, p.y, p.width, p.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(p.x, p.y, p.width, p.height);
            });

            // Hazards
            hazards.forEach(h => {
                ctx.fillStyle = '#FF3333';
                ctx.fillRect(h.x, h.y, h.width, h.height);
                ctx.strokeStyle = '#CC0000';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(h.x, h.y, h.width, h.height);
            });

            // Current drawing
            if (currentRect) {
                ctx.fillStyle = currentTool === 'platform' ? 'rgba(76, 175, 80, 0.5)' : 'rgba(255, 51, 51, 0.5)';
                ctx.fillRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
                ctx.strokeStyle = currentTool === 'platform' ? '#4CAF50' : '#FF3333';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
            }

            // Start position
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(startPos.x, startPos.y, 40, 40);
            ctx.strokeStyle = '#00AA00';
            ctx.lineWidth = 2 / zoom;
            ctx.strokeRect(startPos.x, startPos.y, 40, 40);

            // Finish line
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(finishPos.x, finishPos.y, finishPos.width, finishPos.height);
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 2 / zoom;
            ctx.strokeRect(finishPos.x, finishPos.y, finishPos.width, finishPos.height);

            // Player preview (40x40 reference)
            if (playerPreview.visible) {
                ctx.fillStyle = 'rgba(255, 165, 0, 0.5)';
                ctx.fillRect(playerPreview.x, playerPreview.y, 40, 40);
                ctx.strokeStyle = '#FFA500';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(playerPreview.x, playerPreview.y, 40, 40);
            }

            // Selected block highlight
            if (selectedBlock && isDraggingBlock) {
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3 / zoom;
                ctx.setLineDash([10 / zoom, 5 / zoom]);
                ctx.strokeRect(selectedBlock.obj.x, selectedBlock.obj.y, selectedBlock.obj.width, selectedBlock.obj.height);
                ctx.setLineDash([]);
            }

            // Player in test mode
            if (testMode) {
                ctx.fillStyle = '#FF5722';
                ctx.fillRect(player.x, player.y, player.width, player.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(player.x, player.y, player.width, player.height);
            }

            ctx.restore();
        }

        function goToCoordinates() {
            const x = parseFloat(document.getElementById('camX').value) || 0;
            const y = parseFloat(document.getElementById('camY').value) || 0;
            cameraX = x;
            cameraY = y;
            document.getElementById('cameraInfo').textContent =
                `Camera: ${Math.round(cameraX)}, ${Math.round(cameraY)} | Zoom: ${zoom.toFixed(1)}x`;
            draw();
        }

        // Camera movement with WASD
        let cameraMoveSpeed = 10;
        setInterval(() => {
            if (testMode) return;

            if (keys['KeyW'] || keys['ArrowUp']) cameraY -= cameraMoveSpeed / zoom;
            if (keys['KeyS'] || keys['ArrowDown']) cameraY += cameraMoveSpeed / zoom;
            if (keys['KeyA'] || keys['ArrowLeft']) cameraX -= cameraMoveSpeed / zoom;
            if (keys['KeyD'] || keys['ArrowRight']) cameraX += cameraMoveSpeed / zoom;

            if (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'] ||
                keys['ArrowUp'] || keys['ArrowDown'] || keys['ArrowLeft'] || keys['ArrowRight']) {
                document.getElementById('cameraInfo').textContent =
                    `Camera: ${Math.round(cameraX)}, ${Math.round(cameraY)} | Zoom: ${zoom.toFixed(1)}x`;
                draw();
            }
        }, 16);

        // Test mode functions
        function testLevel() {
            testMode = true;
            player.x = startPos.x;
            player.y = startPos.y;
            player.velocityX = 0;
            player.velocityY = 0;
            requestAnimationFrame(gameLoop);
        }

        function stopTest() {
            testMode = false;
            draw();
        }

        function gameLoop() {
            if (!testMode) return;

            updatePlayer();
            draw();

            requestAnimationFrame(gameLoop);
        }

        function updatePlayer() {
            // Gravity
            player.velocityY += physics.gravity;

            // Movement
            if (keys['KeyA'] || keys['ArrowLeft']) {
                player.velocityX -= physics.moveSpeed;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                player.velocityX += physics.moveSpeed;
            }

            // Jump
            if ((keys['KeyW'] || keys['ArrowUp'] || keys['Space']) && isGrounded) {
                player.velocityY = -physics.jumpPower;
            }

            // Friction
            if (isGrounded) {
                player.velocityX *= physics.friction;
            } else {
                player.velocityX *= physics.airRes;
            }

            player.velocityX = Math.max(-physics.maxSpeed, Math.min(physics.maxSpeed, player.velocityX));

            player.x += player.velocityX;
            player.y += player.velocityY;

            checkCollision();
            checkHazards();
            checkFinish();

            // Keep camera centered on player
            cameraX = player.x - canvas.width / (2 * zoom);
            cameraY = player.y - canvas.height / (2 * zoom);
        }

        function checkCollision() {
            isGrounded = false;

            for (let platform of platforms) {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {

                    const overlapLeft = (player.x + player.width) - platform.x;
                    const overlapRight = (platform.x + platform.width) - player.x;
                    const overlapTop = (player.y + player.height) - platform.y;
                    const overlapBottom = (platform.y + platform.height) - player.y;

                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    if (minOverlap === overlapTop && player.velocityY >= 0) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        isGrounded = true;
                    }
                    else if (minOverlap === overlapBottom && player.velocityY < 0) {
                        player.y = platform.y + platform.height;
                        player.velocityY = 0;
                    }
                    else if (minOverlap === overlapLeft) {
                        player.x = platform.x - player.width;
                        player.velocityX = 0;
                    }
                    else if (minOverlap === overlapRight) {
                        player.x = platform.x + platform.width;
                        player.velocityX = 0;
                    }
                }
            }
        }

        function checkHazards() {
            for (let hazard of hazards) {
                if (player.x + player.width > hazard.x &&
                    player.x < hazard.x + hazard.width &&
                    player.y + player.height > hazard.y &&
                    player.y < hazard.y + hazard.height) {
                    player.x = startPos.x;
                    player.y = startPos.y;
                    player.velocityX = 0;
                    player.velocityY = 0;
                    return;
                }
            }
        }

        function checkFinish() {
            if (player.x + player.width > finishPos.x &&
                player.x < finishPos.x + finishPos.width &&
                player.y + player.height > finishPos.y &&
                player.y < finishPos.y + finishPos.height) {
                alert('Level Complete!');
                stopTest();
            }
        }

        // Keyboard events
        document.addEventListener('keydown', (e) => {
            // Don't capture keys when modal is open
            const modalOpen = document.getElementById('importModal').classList.contains('show');
            if (modalOpen) {
                if (e.code === 'Escape') {
                    closeImportModal();
                    e.preventDefault();
                }
                return;
            }

            keys[e.code] = true;

            if (e.code === 'KeyR' && testMode) {
                player.x = startPos.x;
                player.y = startPos.y;
                player.velocityX = 0;
                player.velocityY = 0;
            }

            if (e.code === 'Escape' && testMode) {
                stopTest();
            }

            e.preventDefault();
        });

        document.addEventListener('keyup', (e) => {
            // Don't capture keys when modal is open
            const modalOpen = document.getElementById('importModal').classList.contains('show');
            if (modalOpen) {
                return;
            }

            keys[e.code] = false;
            e.preventDefault();
        });

        // Window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth - 250;
            canvas.height = window.innerHeight;
            draw();
        });

        // Initial draw
        updateLevelData();
        draw();
    </script>
</body>
</html>
