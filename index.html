<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale Plus Blooket</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #2d1b69 100%);
            color: white;
            overflow: hidden;
        }

        .game-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .name-prompt {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #2d1b69 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .name-card {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
            padding: 3rem;
            border-radius: 20px;
            text-align: center;
            border: 2px solid rgba(0, 245, 255, 0.3);
            min-width: 400px;
        }

        .name-title {
            font-size: 2rem;
            font-weight: 800;
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 2rem;
        }

        .input-group {
            margin: 1rem 0;
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #00f5ff;
            font-weight: 600;
        }

        .input-group input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        .input-group input:focus {
            outline: none;
            border-color: #00f5ff;
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
        }

        .connection-status {
            margin: 1rem 0;
            padding: 0.5rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-connected {
            color: #4ade80;
            background: rgba(74, 222, 128, 0.1);
        }

        .status-disconnected {
            color: #f87171;
            background: rgba(248, 113, 113, 0.1);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00f5ff;
            animation: blink 2s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            position: relative;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stats {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem 1rem;
            border-radius: 25px;
            backdrop-filter: blur(5px);
        }

        .stat-value {
            font-weight: 700;
            color: #00f5ff;
        }

        #gameCanvas {
            display: block;
            background: radial-gradient(circle, #1a2332 0%, #0f1419 100%);
        }

        .game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .tower-menu {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            pointer-events: auto;
        }

        .tower-btn {
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            min-width: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            pointer-events: auto;
        }

        .tower-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .tower-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .tower-btn.basic {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
        }

        .tower-btn.sniper {
            background: linear-gradient(135deg, #5cb85c, #449d44);
            color: white;
        }

        .tower-btn.splash {
            background: linear-gradient(135deg, #f0ad4e, #ec971f);
            color: white;
        }

        .tower-btn.slow {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
        }

        .tower-btn.selected {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
        }

        .tower-cost {
            font-size: 0.7rem;
            opacity: 0.9;
        }

        .wave-info {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            min-width: 200px;
            pointer-events: auto;
        }

        .wave-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin: 0.5rem 0;
            overflow: hidden;
        }

        .wave-fill {
            height: 100%;
            background: linear-gradient(90deg, #00f5ff, #0066ff);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .leaderboard {
            position: fixed;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            min-width: 250px;
            max-height: 400px;
            overflow-y: auto;
            pointer-events: auto;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            margin: 0.25rem 0;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .leaderboard-entry:hover {
            background: rgba(0, 245, 255, 0.1);
            transform: translateX(5px);
        }

        .leaderboard-entry.current-player {
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
        }

        .player-rank {
            font-weight: bold;
            color: #00f5ff;
            min-width: 30px;
        }

        .player-info {
            flex: 1;
            margin: 0 0.5rem;
        }

        .player-stats {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .crown {
            color: #ffd700;
            margin-right: 0.25rem;
        }

        .medal {
            color: #c0c0c0;
            margin-right: 0.25rem;
        }

        .bronze {
            color: #cd7f32;
            margin-right: 0.25rem;
        }

        .camera-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 0.5rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            pointer-events: auto;
        }

        .speed-controls {
            position: fixed;
            top: 100px;
            right: 250px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            pointer-events: auto;
        }

        .speed-btn {
            padding: 0.5rem 0.75rem;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0.25rem;
            display: inline-block;
            min-width: 45px;
            font-size: 0.8rem;
        }

        .speed-btn:hover {
            background: rgba(0, 245, 255, 0.2);
        }

        .speed-btn.active {
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
        }

        .free-cam-instructions {
            position: fixed;
            bottom: 150px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 0.75rem;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            font-size: 0.7rem;
            opacity: 0.8;
            max-width: 200px;
            display: none;
        }

        .camera-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0.25rem;
            display: block;
            width: 100%;
        }

        .camera-btn:hover {
            background: rgba(0, 245, 255, 0.2);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            pointer-events: auto;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .notification {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            border-radius: 15px;
            text-align: center;
            z-index: 1001;
            animation: notification-appear 0.3s ease-out;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }

        @keyframes notification-appear {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .game-over h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: #e74c3c;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00f5ff;
            font-size: 1.2rem;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <!-- Name Prompt Screen -->
    <div class="name-prompt" id="namePrompt">
        <div class="name-card">
            <h1 class="name-title">CLASH ROYALE PLUS BLOOKET</h1>
            <p style="margin-bottom: 2rem; opacity: 0.8;">Multiplayer Strategy Defense</p>

            <div class="connection-status" id="connectionStatus">
                <div class="status-dot"></div>
                <span>Connecting...</span>
            </div>

            <div class="input-group">
                <label for="playerName">Player Name</label>
                <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
            </div>

            <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                <button class="btn btn-primary" id="joinGameBtn" disabled>Join Game</button>
            </div>

            <div id="nameError" style="color: #f87171; margin-top: 1rem; display: none;"></div>
        </div>
    </div>

    <!-- Game Screen -->
    <div class="game-container" id="gameContainer" style="display: none;">
        <div class="header">
            <div class="logo">CLASH ROYALE PLUS BLOOKET</div>
            <div class="stats">
                <div class="stat-item">
                    <span>💰</span>
                    <span class="stat-value" id="playerGold">100</span>
                </div>
                <div class="stat-item">
                    <span>❤️</span>
                    <span class="stat-value" id="playerLives">20</span>
                </div>
                <div class="stat-item">
                    <span>Wave:</span>
                    <span class="stat-value" id="currentWave">1</span>
                </div>
                <div class="stat-item">
                    <span>Score:</span>
                    <span class="stat-value" id="playerScore">0</span>
                </div>
                <div class="connection-status">
                    <div class="status-dot"></div>
                    <span>Online</span>
                </div>
            </div>
        </div>

        <div style="position: relative; flex: 1;">
            <canvas id="gameCanvas"></canvas>
            <div class="loading" id="loadingText">Loading 3D assets...</div>

            <div class="game-ui">
                <div class="tower-menu">
                    <button class="tower-btn basic" id="basicTowerBtn">
                        <span>🔫 Basic</span>
                        <span class="tower-cost">$10</span>
                    </button>
                    <button class="tower-btn sniper" id="sniperTowerBtn">
                        <span>🎯 Sniper</span>
                        <span class="tower-cost">$25</span>
                    </button>
                    <button class="tower-btn splash" id="splashTowerBtn">
                        <span>💥 Splash</span>
                        <span class="tower-cost">$40</span>
                    </button>
                    <button class="tower-btn slow" id="slowTowerBtn">
                        <span>❄️ Slow</span>
                        <span class="tower-cost">$30</span>
                    </button>
                </div>

                <div class="wave-info">
                    <h3 style="margin-bottom: 0.5rem; color: #00f5ff;">Wave Progress</h3>
                    <div class="wave-progress">
                        <div class="wave-fill" id="waveFill" style="width: 0%;"></div>
                    </div>
                    <div style="font-size: 0.9rem; margin-top: 0.5rem;">
                        <div>Enemies: <span id="enemiesLeft">0</span></div>
                        <div>Next Wave: <span id="nextWaveTime">30s</span></div>
                    </div>
                    <button class="btn btn-primary" id="startWaveBtn" style="margin-top: 1rem; width: 100%;">Start Wave</button>
                </div>

                <div class="leaderboard">
                    <h3 style="margin-bottom: 0.5rem; color: #00f5ff;">🏆 Leaderboard</h3>
                    <div id="leaderboardList">
                        <!-- Leaderboard entries will be populated here -->
                    </div>
                </div>

                <div class="speed-controls">
                    <h4 style="margin-bottom: 0.5rem; color: #00f5ff; font-size: 0.9rem;">⚡ Game Speed</h4>
                    <div>
                        <button class="speed-btn active" id="speed1x">1x</button>
                        <button class="speed-btn" id="speed2x">2x</button>
                        <button class="speed-btn" id="speed3x">3x</button>
                        <button class="speed-btn" id="speed5x">5x</button>
                        <button class="speed-btn" id="speed10x">10x</button>
                    </div>
                </div>

                <div class="camera-controls">
                    <button class="camera-btn" id="topViewBtn">Top View</button>
                    <button class="camera-btn" id="angleViewBtn">Angle View</button>
                    <button class="camera-btn" id="freeViewBtn">Free Camera</button>
                </div>

                <div class="free-cam-instructions" id="freeCamInstructions">
                    <div style="color: #00f5ff; font-weight: bold; margin-bottom: 0.25rem;">Free Camera:</div>
                    <div>WASD/Arrows: Move</div>
                    <div>Mouse: Look around</div>
                    <div>Scroll: Zoom</div>
                    <div>+/-: Change FOV</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Firebase SDKs -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, onValue, push, remove, onDisconnect, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBLkFMipRS631fDNr8uwgozmxXBnqLd5_o",
            authDomain: "base-control-b391e.firebaseapp.com",
            databaseURL: "https://base-control-b391e-default-rtdb.firebaseio.com/",
            projectId: "base-control-b391e",
            storageBucket: "base-control-b391e.firebasestorage.app",
            messagingSenderId: "116375376675",
            appId: "1:116375376675:web:cdc8688222c7c35accf296",
            measurementId: "G-JY7P6D49HM"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        class TowerDefense3D {
            constructor() {
                this.playerId = this.generatePlayerId();
                this.playerName = '';
                this.roomCode = 'tower-defense-3d';
                this.gameState = null;
                this.isConnected = false;

                // Game state
                this.gold = 100;
                this.lives = 20;
                this.wave = 1;
                this.currentScore = 0;
                this.selectedTowerType = null;
                this.isWaveActive = false;
                this.enemiesInWave = 0;
                this.enemiesSpawned = 0;
                this.nextWaveTimer = 30;
                this.leaderboard = [];

                // 3D Objects
                this.towers = new Map();
                this.enemies = new Map();
                this.projectiles = new Map();

                // Tower types
                this.towerTypes = {
                    basic: { cost: 10, damage: 15, range: 3, fireRate: 1000, color: 0x4a90e2 },
                    sniper: { cost: 25, damage: 40, range: 6, fireRate: 2000, color: 0x5cb85c },
                    splash: { cost: 40, damage: 25, range: 2.5, fireRate: 1500, color: 0xf0ad4e, splash: 1.5 },
                    slow: { cost: 30, damage: 10, range: 3, fireRate: 800, color: 0x9b59b6, slow: 0.5 }
                };

                // Enemy types (slower base speeds)
                this.enemyTypes = {
                    basic: { health: 50, speed: 0.005, reward: 5, color: 0xe74c3c },
                    fast: { health: 30, speed: 0.008, reward: 8, color: 0xf39c12 },
                    tank: { health: 150, speed: 0.003, reward: 15, color: 0x34495e },
                    boss: { health: 300, speed: 0.004, reward: 50, color: 0x8e44ad }
                };

                // Game speed and camera controls
                this.gameSpeed = 1;
                this.isFreeCam = false;
                this.cameraKeys = new Set();
                this.cameraVelocity = { x: 0, y: 0, z: 0 };
                this.mouseDown = false;
                this.lastMouse = { x: 0, y: 0 };
                this.cameraRotation = { x: 0, y: 0 };

                // Grid system
                this.gridSize = 1;
                this.placementGrid = [];
                this.gridTiles = [];
                this.hoveredTile = null;

                // Path waypoints (3D coordinates)
                this.pathPoints = [
                    { x: -8, z: 0, y: 0 },
                    { x: -6, z: 2, y: 0 },
                    { x: -4, z: 3, y: 0 },
                    { x: -2, z: 2, y: 0 },
                    { x: 0, z: 0, y: 0 },
                    { x: 2, z: -2, y: 0 },
                    { x: 4, z: -3, y: 0 },
                    { x: 6, z: -2, y: 0 },
                    { x: 8, z: 0, y: 0 }
                ];

                this.init();
            }

            generatePlayerId() {
                return 'player_' + Math.random().toString(36).substr(2, 9);
            }

            init() {
                this.initializeElements();
                this.bindEvents();
                this.checkConnection();
                this.setupThreeJS();
            }

            initializeElements() {
                this.namePrompt = document.getElementById('namePrompt');
                this.gameContainer = document.getElementById('gameContainer');
                this.connectionStatus = document.getElementById('connectionStatus');
                this.playerNameInput = document.getElementById('playerName');
                this.joinGameBtn = document.getElementById('joinGameBtn');
                this.playerGoldDisplay = document.getElementById('playerGold');
                this.playerLivesDisplay = document.getElementById('playerLives');
                this.currentWaveDisplay = document.getElementById('currentWave');
                this.playerScoreDisplay = document.getElementById('playerScore');
                this.waveFill = document.getElementById('waveFill');
                this.enemiesLeft = document.getElementById('enemiesLeft');
                this.nextWaveTime = document.getElementById('nextWaveTime');
                this.startWaveBtn = document.getElementById('startWaveBtn');
                this.nameError = document.getElementById('nameError');
                this.leaderboardList = document.getElementById('leaderboardList');
                this.loadingText = document.getElementById('loadingText');

                this.basicTowerBtn = document.getElementById('basicTowerBtn');
                this.sniperTowerBtn = document.getElementById('sniperTowerBtn');
                this.splashTowerBtn = document.getElementById('splashTowerBtn');
                this.slowTowerBtn = document.getElementById('slowTowerBtn');

                this.topViewBtn = document.getElementById('topViewBtn');
                this.angleViewBtn = document.getElementById('angleViewBtn');
                this.freeViewBtn = document.getElementById('freeViewBtn');
                this.freeCamInstructions = document.getElementById('freeCamInstructions');

                // Speed control buttons
                this.speed1xBtn = document.getElementById('speed1x');
                this.speed2xBtn = document.getElementById('speed2x');
                this.speed3xBtn = document.getElementById('speed3x');
                this.speed5xBtn = document.getElementById('speed5x');
                this.speed10xBtn = document.getElementById('speed10x');
            }

            bindEvents() {
                this.joinGameBtn.addEventListener('click', () => this.joinGame());
                this.playerNameInput.addEventListener('input', () => this.validateForm());
                this.playerNameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !this.joinGameBtn.disabled) {
                        this.joinGame();
                    }
                });

                this.basicTowerBtn.addEventListener('click', () => this.selectTowerType('basic'));
                this.sniperTowerBtn.addEventListener('click', () => this.selectTowerType('sniper'));
                this.splashTowerBtn.addEventListener('click', () => this.selectTowerType('splash'));
                this.slowTowerBtn.addEventListener('click', () => this.selectTowerType('slow'));

                this.startWaveBtn.addEventListener('click', () => this.startWave());

                this.topViewBtn.addEventListener('click', () => this.setCameraView('top'));
                this.angleViewBtn.addEventListener('click', () => this.setCameraView('angle'));
                this.freeViewBtn.addEventListener('click', () => this.setCameraView('free'));

                // Speed controls
                this.speed1xBtn.addEventListener('click', () => this.setGameSpeed(1));
                this.speed2xBtn.addEventListener('click', () => this.setGameSpeed(2));
                this.speed3xBtn.addEventListener('click', () => this.setGameSpeed(3));
                this.speed5xBtn.addEventListener('click', () => this.setGameSpeed(5));
                this.speed10xBtn.addEventListener('click', () => this.setGameSpeed(10));

                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));
            }

            async checkConnection() {
                try {
                    const connectedRef = ref(database, '.info/connected');
                    onValue(connectedRef, (snapshot) => {
                        this.isConnected = snapshot.val() === true;
                        this.updateConnectionStatus();
                        this.validateForm();
                    });
                } catch (error) {
                    console.error('Connection failed:', error);
                    this.updateConnectionStatus(false);
                }
            }

            updateConnectionStatus(connected = this.isConnected) {
                const statusElement = this.connectionStatus;
                if (connected) {
                    statusElement.className = 'connection-status status-connected';
                    statusElement.innerHTML = '<div class="status-dot"></div><span>Connected</span>';
                } else {
                    statusElement.className = 'connection-status status-disconnected';
                    statusElement.innerHTML = '<div class="status-dot"></div><span>Connection failed</span>';
                }
            }

            validateForm() {
                const nameValid = this.playerNameInput.value.trim().length > 0;
                const connected = this.isConnected;
                this.joinGameBtn.disabled = !nameValid || !connected;
            }

            setupThreeJS() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0f1419);

                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight - 80), 0.1, 1000);
                this.camera.position.set(0, 10, 8);
                this.camera.lookAt(0, 0, 0);

                // Renderer
                this.canvas = document.getElementById('gameCanvas');
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight - 80);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Lighting
                this.setupLighting();

                // Battlefield
                this.createBattlefield();

                // Raycaster for mouse interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));

                // Start render loop
                this.animate();

                this.loadingText.style.display = 'none';
            }

            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);

                // Directional light (sun)
                this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                this.directionalLight.position.set(10, 20, 5);
                this.directionalLight.castShadow = true;
                this.directionalLight.shadow.mapSize.width = 2048;
                this.directionalLight.shadow.mapSize.height = 2048;
                this.directionalLight.shadow.camera.near = 0.5;
                this.directionalLight.shadow.camera.far = 50;
                this.directionalLight.shadow.camera.left = -20;
                this.directionalLight.shadow.camera.right = 20;
                this.directionalLight.shadow.camera.top = 20;
                this.directionalLight.shadow.camera.bottom = -20;
                this.scene.add(this.directionalLight);

                // Point light for dramatic effect
                const pointLight = new THREE.PointLight(0x00f5ff, 0.5, 30);
                pointLight.position.set(0, 8, 0);
                this.scene.add(pointLight);
            }

            createBattlefield() {
                // Ground plane
                const groundGeometry = new THREE.PlaneGeometry(20, 12);
                const groundMaterial = new THREE.MeshLambertMaterial({
                    color: 0x2d3748,
                    transparent: true,
                    opacity: 0.8
                });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);

                // Enhanced grid helper for visual reference
                const gridHelper = new THREE.GridHelper(20, 20, 0x00f5ff, 0x444444);
                gridHelper.material.opacity = 0.4;
                gridHelper.material.transparent = true;
                this.scene.add(gridHelper);

                // Create placement grid system
                this.createPlacementGrid();

                // Path visualization
                this.createPath();
            }

            createPath() {
                const pathGeometry = new THREE.BufferGeometry();
                const pathVertices = [];

                for (let i = 0; i < this.pathPoints.length; i++) {
                    const point = this.pathPoints[i];
                    pathVertices.push(point.x, point.y + 0.1, point.z);
                }

                pathGeometry.setAttribute('position', new THREE.Float32BufferAttribute(pathVertices, 3));

                const pathMaterial = new THREE.LineBasicMaterial({
                    color: 0x8b4513,
                    linewidth: 5
                });

                this.pathLine = new THREE.Line(pathGeometry, pathMaterial);
                this.scene.add(this.pathLine);

                // Add path markers
                this.pathPoints.forEach((point, index) => {
                    const markerGeometry = new THREE.SphereGeometry(0.2, 8, 6);
                    let markerMaterial;

                    if (index === 0) {
                        markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Start - Red
                    } else if (index === this.pathPoints.length - 1) {
                        markerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // End - Green
                    } else {
                        markerMaterial = new THREE.MeshBasicMaterial({ color: 0x8b4513 }); // Path - Brown
                    }

                    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.set(point.x, point.y + 0.3, point.z);
                    this.scene.add(marker);
                });
            }

            handleCanvasClick(event) {
                if (!this.selectedTowerType) return;

                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.ground);

                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const position = intersect.point;

                    // Snap to grid centers (offset by 0.5 to center on squares)
                    position.x = Math.round(position.x - 0.5) + 0.5;
                    position.z = Math.round(position.z - 0.5) + 0.5;
                    position.y = 0;

                    // Check if position is valid (not on path, not occupied)
                    if (this.isValidTowerPosition(position)) {
                        this.placeTower(position, this.selectedTowerType);
                    }
                }
            }

            handleCanvasMouseMove(event) {
                if (!this.selectedTowerType) return;

                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.ground);

                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const position = intersect.point;

                    // Snap to grid centers
                    const gridX = Math.round(position.x - 0.5) + 0.5;
                    const gridZ = Math.round(position.z - 0.5) + 0.5;

                    this.updateHoverTile(gridX, gridZ);
                }
            }

            isValidTowerPosition(position) {
                // Check if position is too close to path
                for (const pathPoint of this.pathPoints) {
                    const distance = Math.sqrt(
                        (position.x - pathPoint.x) ** 2 +
                        (position.z - pathPoint.z) ** 2
                    );
                    if (distance < 1.5) return false;
                }

                // Check if position is occupied by another tower
                for (const tower of this.towers.values()) {
                    const distance = Math.sqrt(
                        (position.x - tower.position.x) ** 2 +
                        (position.z - tower.position.z) ** 2
                    );
                    if (distance < 1) return false;
                }

                // Check bounds
                if (Math.abs(position.x) > 9 || Math.abs(position.z) > 5) return false;

                return true;
            }

            createPlacementGrid() {
                // Create visual grid tiles for tower placement
                const tileGeometry = new THREE.PlaneGeometry(0.9, 0.9);
                const validTileMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide
                });
                const invalidTileMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const hoverTileMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00f5ff,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });

                this.gridMaterials = {
                    valid: validTileMaterial,
                    invalid: invalidTileMaterial,
                    hover: hoverTileMaterial
                };

                // Create grid tiles at square centers
                for (let x = -9; x <= 8; x++) {
                    for (let z = -5; z <= 4; z++) {
                        const tile = new THREE.Mesh(tileGeometry, validTileMaterial.clone());
                        tile.rotation.x = -Math.PI / 2;
                        tile.position.set(x + 0.5, 0.01, z + 0.5);
                        tile.userData = { gridX: x + 0.5, gridZ: z + 0.5 };
                        tile.visible = false; // Initially hidden
                        this.scene.add(tile);
                        this.gridTiles.push(tile);
                    }
                }
            }

            updateHoverTile(gridX, gridZ) {
                // Clear previous hover
                if (this.hoveredTile) {
                    this.hoveredTile.visible = false;
                }

                // Find the tile at this grid position
                const tile = this.gridTiles.find(t =>
                    t.userData.gridX === gridX && t.userData.gridZ === gridZ
                );

                if (tile) {
                    this.hoveredTile = tile;
                    const position = new THREE.Vector3(gridX, 0, gridZ);

                    if (this.isValidTowerPosition(position)) {
                        tile.material = this.gridMaterials.hover;
                    } else {
                        tile.material = this.gridMaterials.invalid;
                    }
                    tile.visible = true;
                }
            }

            showPlacementGrid() {
                // Show all grid tiles when a tower is selected
                this.gridTiles.forEach(tile => {
                    const position = new THREE.Vector3(tile.userData.gridX, 0, tile.userData.gridZ);
                    if (this.isValidTowerPosition(position)) {
                        tile.material = this.gridMaterials.valid;
                    } else {
                        tile.material = this.gridMaterials.invalid;
                    }
                    tile.visible = true;
                });
            }

            hidePlacementGrid() {
                // Hide all grid tiles
                this.gridTiles.forEach(tile => {
                    tile.visible = false;
                });
                this.hoveredTile = null;
            }

            selectTowerType(type) {
                // Clear previous selection
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.classList.remove('selected');
                });

                if (this.selectedTowerType === type) {
                    this.selectedTowerType = null;
                } else {
                    this.selectedTowerType = type;
                    const btn = document.getElementById(type + 'TowerBtn');
                    btn.classList.add('selected');
                }
            }

            placeTower(position, type) {
                const towerConfig = this.towerTypes[type];
                if (this.gold < towerConfig.cost) {
                    this.showNotification('❌ Not enough gold!');
                    return;
                }

                const towerId = 'tower_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);

                // Create 3D tower model
                const towerGroup = new THREE.Group();

                // Base
                const baseGeometry = new THREE.CylinderGeometry(0.4, 0.5, 0.3, 8);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.15;
                base.castShadow = true;
                towerGroup.add(base);

                // Tower body
                const bodyGeometry = new THREE.CylinderGeometry(0.25, 0.35, 0.8, 6);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: towerConfig.color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.7;
                body.castShadow = true;
                towerGroup.add(body);

                // Weapon (different for each type)
                this.addTowerWeapon(towerGroup, type);

                towerGroup.position.copy(position);
                this.scene.add(towerGroup);

                // Store tower data
                const towerData = {
                    id: towerId,
                    type: type,
                    position: position.clone(),
                    mesh: towerGroup,
                    lastFired: 0,
                    ...towerConfig
                };

                this.towers.set(towerId, towerData);
                this.gold -= towerConfig.cost;
                this.updateUI();

                this.showNotification(`🏗️ ${type.charAt(0).toUpperCase() + type.slice(1)} tower placed!`);
                this.selectedTowerType = null;
                this.hidePlacementGrid();
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.classList.remove('selected');
                });
            }

            addTowerWeapon(towerGroup, type) {
                switch (type) {
                    case 'basic':
                        // Simple cannon
                        const cannonGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.6, 6);
                        const cannonMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                        const cannon = new THREE.Mesh(cannonGeometry, cannonMaterial);
                        cannon.position.y = 1.2;
                        cannon.rotation.z = Math.PI / 2;
                        towerGroup.add(cannon);
                        break;

                    case 'sniper':
                        // Long barrel
                        const barrelGeometry = new THREE.CylinderGeometry(0.03, 0.04, 1.0, 8);
                        const barrelMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e50 });
                        const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                        barrel.position.y = 1.3;
                        barrel.rotation.z = Math.PI / 2;
                        towerGroup.add(barrel);
                        break;

                    case 'splash':
                        // Mortar tube
                        const mortarGeometry = new THREE.CylinderGeometry(0.15, 0.12, 0.4, 6);
                        const mortarMaterial = new THREE.MeshLambertMaterial({ color: 0xd35400 });
                        const mortar = new THREE.Mesh(mortarGeometry, mortarMaterial);
                        mortar.position.y = 1.3;
                        towerGroup.add(mortar);
                        break;

                    case 'slow':
                        // Crystal array
                        for (let i = 0; i < 4; i++) {
                            const crystalGeometry = new THREE.ConeGeometry(0.05, 0.3, 4);
                            const crystalMaterial = new THREE.MeshLambertMaterial({
                                color: 0x9b59b6,
                                transparent: true,
                                opacity: 0.8
                            });
                            const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                            crystal.position.y = 1.2;
                            crystal.position.x = Math.cos(i * Math.PI / 2) * 0.2;
                            crystal.position.z = Math.sin(i * Math.PI / 2) * 0.2;
                            towerGroup.add(crystal);
                        }
                        break;
                }
            }

            async joinGame() {
                this.playerName = this.playerNameInput.value.trim();

                try {
                    // Add player to the game
                    const playerRef = ref(database, `rooms/${this.roomCode}/players/${this.playerId}`);
                    await set(playerRef, {
                        name: this.playerName,
                        gold: this.gold,
                        lives: this.lives,
                        wave: this.wave,
                        score: this.currentScore,
                        connected: true,
                        joinedAt: serverTimestamp()
                    });

                    this.startGame();
                } catch (error) {
                    this.showError('Failed to join game: ' + error.message);
                }
            }

            startGame() {
                this.namePrompt.style.display = 'none';
                this.gameContainer.style.display = 'flex';

                // Set up Firebase listeners
                this.setupGameListeners();
                this.setupDisconnectCleanup();

                // Start game loops
                this.startGameLoop();
                this.startNextWaveTimer();
                this.loadLeaderboard();
                this.startLeaderboardSync();

                // Resize renderer
                this.onWindowResize();
                window.addEventListener('resize', () => this.onWindowResize());
            }

            setupGameListeners() {
                const roomRef = ref(database, `rooms/${this.roomCode}`);
                onValue(roomRef, (snapshot) => {
                    if (snapshot.exists()) {
                        this.gameState = snapshot.val();
                    }
                });
            }

            setupDisconnectCleanup() {
                const playerRef = ref(database, `rooms/${this.roomCode}/players/${this.playerId}`);
                onDisconnect(playerRef).remove();
            }

            async startWave() {
                if (this.isWaveActive) return;

                this.isWaveActive = true;
                this.enemiesInWave = Math.min(5 + this.wave * 2, 30);
                this.enemiesSpawned = 0;
                this.startWaveBtn.disabled = true;
                this.startWaveBtn.textContent = 'Wave Active';

                this.showNotification(`🌊 Wave ${this.wave} starting! ${this.enemiesInWave} enemies incoming!`);

                // Spawn enemies with delay (scaled by game speed)
                const spawnInterval = setInterval(() => {
                    if (this.enemiesSpawned >= this.enemiesInWave) {
                        clearInterval(spawnInterval);
                        return;
                    }

                    this.spawnEnemy();
                    this.enemiesSpawned++;
                }, 1500 / this.gameSpeed);
            }

            spawnEnemy() {
                let enemyType;

                // Different enemy types based on wave
                if (this.wave < 3) {
                    enemyType = 'basic';
                } else if (this.wave < 6) {
                    enemyType = Math.random() < 0.7 ? 'basic' : 'fast';
                } else if (this.wave < 10) {
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic';
                    else if (rand < 0.8) enemyType = 'fast';
                    else enemyType = 'tank';
                } else {
                    const rand = Math.random();
                    if (rand < 0.3) enemyType = 'basic';
                    else if (rand < 0.6) enemyType = 'fast';
                    else if (rand < 0.9) enemyType = 'tank';
                    else enemyType = 'boss';
                }

                const enemyId = 'enemy_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                const enemyConfig = this.enemyTypes[enemyType];

                // Create enhanced 3D enemy model
                const enemyGroup = new THREE.Group();

                let mainMesh;
                switch (enemyType) {
                    case 'basic':
                        mainMesh = this.createBasicEnemyModel(enemyConfig.color);
                        break;
                    case 'fast':
                        mainMesh = this.createFastEnemyModel(enemyConfig.color);
                        break;
                    case 'tank':
                        mainMesh = this.createTankEnemyModel(enemyConfig.color);
                        break;
                    case 'boss':
                        mainMesh = this.createBossEnemyModel(enemyConfig.color);
                        break;
                }

                enemyGroup.add(mainMesh);

                // Enhanced health bar with background
                const healthBarBg = new THREE.PlaneGeometry(0.5, 0.08);
                const healthBarBgMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
                const healthBarBackground = new THREE.Mesh(healthBarBg, healthBarBgMaterial);
                healthBarBackground.position.y = 0.6;
                enemyGroup.add(healthBarBackground);

                const healthBarGeometry = new THREE.PlaneGeometry(0.48, 0.06);
                const healthBarMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);
                healthBar.position.set(0, 0.6, 0.001); // Slightly in front of background
                enemyGroup.add(healthBar);

                // Position at start of path
                const startPos = this.pathPoints[0];
                enemyGroup.position.set(startPos.x, startPos.y + 0.2, startPos.z);
                this.scene.add(enemyGroup);

                // Store enemy data
                const enemyData = {
                    id: enemyId,
                    type: enemyType,
                    mesh: enemyGroup,
                    healthBar: healthBar,
                    pathIndex: 0,
                    pathProgress: 0,
                    health: enemyConfig.health * (1 + this.wave * 0.1),
                    maxHealth: enemyConfig.health * (1 + this.wave * 0.1),
                    speed: enemyConfig.speed,
                    reward: enemyConfig.reward,
                    slowEffect: 1
                };

                this.enemies.set(enemyId, enemyData);
            }

            createBasicEnemyModel(color) {
                const group = new THREE.Group();

                // Main body
                const bodyGeometry = new THREE.SphereGeometry(0.15, 12, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                group.add(body);

                // Spikes for detail
                for (let i = 0; i < 6; i++) {
                    const spikeGeometry = new THREE.ConeGeometry(0.03, 0.1, 4);
                    const spikeMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    spike.position.set(Math.cos(angle) * 0.12, 0, Math.sin(angle) * 0.12);
                    spike.rotation.z = -angle + Math.PI / 2;
                    group.add(spike);
                }

                return group;
            }

            createFastEnemyModel(color) {
                const group = new THREE.Group();

                // Main body (cone)
                const bodyGeometry = new THREE.ConeGeometry(0.12, 0.3, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.15;
                body.castShadow = true;
                group.add(body);

                // Speed trails
                for (let i = 0; i < 3; i++) {
                    const trailGeometry = new THREE.ConeGeometry(0.05, 0.2, 4);
                    const trailMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.5 - i * 0.1
                    });
                    const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                    trail.position.y = -0.1 - i * 0.15;
                    trail.scale.setScalar(0.8 - i * 0.2);
                    group.add(trail);
                }

                return group;
            }

            createTankEnemyModel(color) {
                const group = new THREE.Group();

                // Main body (box)
                const bodyGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.25);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                group.add(body);

                // Armor plates
                const plateGeometry = new THREE.BoxGeometry(0.32, 0.05, 0.27);
                const plateMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
                const topPlate = new THREE.Mesh(plateGeometry, plateMaterial);
                topPlate.position.y = 0.125;
                group.add(topPlate);

                // Side armor
                for (let i = 0; i < 2; i++) {
                    const sideGeometry = new THREE.BoxGeometry(0.05, 0.25, 0.3);
                    const sideMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.x = i === 0 ? -0.175 : 0.175;
                    group.add(side);
                }

                return group;
            }

            createBossEnemyModel(color) {
                const group = new THREE.Group();

                // Main body (octahedron)
                const bodyGeometry = new THREE.OctahedronGeometry(0.2);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                group.add(body);

                // Rotating energy ring
                const ringGeometry = new THREE.TorusGeometry(0.3, 0.02, 8, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.8
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.userData.rotationSpeed = 0.05;
                group.add(ring);

                // Crown spikes
                for (let i = 0; i < 8; i++) {
                    const spikeGeometry = new THREE.ConeGeometry(0.03, 0.15, 4);
                    const spikeMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                    const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                    const angle = (i / 8) * Math.PI * 2;
                    spike.position.set(Math.cos(angle) * 0.15, 0.2, Math.sin(angle) * 0.15);
                    spike.rotation.z = -angle;
                    group.add(spike);
                }

                return group;
            }

            moveEnemies() {
                for (const [enemyId, enemy] of this.enemies) {
                    // Move along path (scaled by game speed)
                    enemy.pathProgress += enemy.speed * enemy.slowEffect * this.gameSpeed;

                    if (enemy.pathProgress >= 1) {
                        enemy.pathIndex++;
                        enemy.pathProgress = 0;
                    }

                    if (enemy.pathIndex >= this.pathPoints.length - 1) {
                        // Enemy reached the end
                        this.lives--;
                        this.enemies.delete(enemyId);
                        this.scene.remove(enemy.mesh);
                        this.showNotification(`💔 Enemy reached base! Lives: ${this.lives}`);

                        if (this.lives <= 0) {
                            this.gameOver();
                        }
                        continue;
                    }

                    // Interpolate position between path points
                    const currentPoint = this.pathPoints[enemy.pathIndex];
                    const nextPoint = this.pathPoints[enemy.pathIndex + 1];

                    const position = new THREE.Vector3();
                    position.lerpVectors(
                        new THREE.Vector3(currentPoint.x, currentPoint.y + 0.2, currentPoint.z),
                        new THREE.Vector3(nextPoint.x, nextPoint.y + 0.2, nextPoint.z),
                        enemy.pathProgress
                    );

                    enemy.mesh.position.copy(position);

                    // Update health bar (right to left direction)
                    const healthPercent = enemy.health / enemy.maxHealth;
                    enemy.healthBar.scale.x = healthPercent;
                    enemy.healthBar.position.x = (1 - healthPercent) * 0.24; // Shift left as health decreases
                    enemy.healthBar.material.color.setRGB(1 - healthPercent, healthPercent, 0);
                    enemy.healthBar.lookAt(this.camera.position);
                    enemy.healthBarBackground.lookAt(this.camera.position);

                    // Animate enemy models
                    this.animateEnemyModel(enemy);

                    // Reset slow effect (scaled by game speed)
                    enemy.slowEffect = Math.min(1, enemy.slowEffect + 0.02 * this.gameSpeed);
                }
            }

            animateEnemyModel(enemy) {
                // Animate based on enemy type
                const time = Date.now() * 0.001;

                switch (enemy.type) {
                    case 'basic':
                        // Bobbing motion
                        enemy.mesh.children[0].position.y = Math.sin(time * 3) * 0.05;
                        // Rotate spikes
                        for (let i = 1; i < enemy.mesh.children.length - 2; i++) {
                            enemy.mesh.children[i].rotation.y = time + i;
                        }
                        break;
                    case 'fast':
                        // Fast spinning
                        enemy.mesh.children[0].rotation.y = time * 4;
                        // Animate speed trails
                        for (let i = 1; i < 4; i++) {
                            enemy.mesh.children[i].material.opacity = 0.3 + Math.sin(time * 5 + i) * 0.2;
                        }
                        break;
                    case 'tank':
                        // Slow heavy movement
                        enemy.mesh.children[0].rotation.y = time * 0.5;
                        break;
                    case 'boss':
                        // Rotating energy ring
                        enemy.mesh.children[1].rotation.y = time * 2;
                        enemy.mesh.children[0].rotation.x = Math.sin(time) * 0.2;
                        enemy.mesh.children[0].rotation.z = Math.cos(time) * 0.2;
                        break;
                }
            }

            towerShooting() {
                const now = Date.now();

                for (const [towerId, tower] of this.towers) {
                    if (now - tower.lastFired < tower.fireRate / this.gameSpeed) continue;

                    // Find nearest enemy in range
                    let target = null;
                    let nearestDistance = Infinity;

                    for (const [enemyId, enemy] of this.enemies) {
                        const distance = tower.position.distanceTo(enemy.mesh.position);

                        if (distance <= tower.range && distance < nearestDistance) {
                            nearestDistance = distance;
                            target = enemy;
                        }
                    }

                    if (target) {
                        this.fireTower(tower, target);
                        tower.lastFired = now;
                    }
                }
            }

            fireTower(tower, enemy) {
                // Create muzzle flash effect
                this.createMuzzleFlash(tower);

                // Create enhanced projectiles based on tower type
                let projectileGroup, projectileSpeed = 0.08; // Much slower base speed

                switch (tower.type) {
                    case 'basic':
                        projectileGroup = this.createBasicProjectile();
                        projectileSpeed = 0.1;
                        break;
                    case 'sniper':
                        projectileGroup = this.createSniperLaser(tower.position, enemy.mesh.position);
                        projectileSpeed = 0.25; // Still faster but more visible
                        break;
                    case 'splash':
                        projectileGroup = this.createMortarShell();
                        projectileSpeed = 0.06; // Very slow for mortar
                        break;
                    case 'slow':
                        projectileGroup = this.createSlowProjectile();
                        projectileSpeed = 0.12;
                        break;
                    default:
                        projectileGroup = this.createBasicProjectile();
                }

                projectileGroup.position.copy(tower.position);
                projectileGroup.position.y += 1.2; // Fire from tower top
                this.scene.add(projectileGroup);

                const projectileId = 'proj_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                const projectileData = {
                    id: projectileId,
                    mesh: projectileGroup,
                    target: enemy,
                    tower: tower,
                    speed: projectileSpeed,
                    damage: tower.damage,
                    trailParticles: []
                };

                this.projectiles.set(projectileId, projectileData);
            }

            createBasicProjectile() {
                const group = new THREE.Group();

                // Main projectile
                const geometry = new THREE.SphereGeometry(0.1, 8, 6);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00aaff,
                    emissive: 0x0055aa
                });
                const projectile = new THREE.Mesh(geometry, material);
                group.add(projectile);

                // Glowing aura
                const auraGeometry = new THREE.SphereGeometry(0.15, 8, 6);
                const auraMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0088ff,
                    transparent: true,
                    opacity: 0.3
                });
                const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                group.add(aura);

                return group;
            }

            createSniperLaser(startPos, targetPos) {
                const group = new THREE.Group();

                // Laser beam
                const distance = startPos.distanceTo(targetPos);
                const geometry = new THREE.CylinderGeometry(0.02, 0.02, distance, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    emissive: 0xffaa00,
                    transparent: true,
                    opacity: 0.8
                });
                const laser = new THREE.Mesh(geometry, material);

                // Position and orient the laser
                laser.position.y = distance / 2;
                laser.lookAt(targetPos);
                group.add(laser);

                // Bright core
                const coreGeometry = new THREE.SphereGeometry(0.05, 6, 4);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff88,
                    emissive: 0xffff44
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                group.add(core);

                return group;
            }

            createMortarShell() {
                const group = new THREE.Group();

                // Shell body
                const geometry = new THREE.SphereGeometry(0.12, 8, 6);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xff4400,
                    emissive: 0x441100
                });
                const shell = new THREE.Mesh(geometry, material);
                group.add(shell);

                // Flame trail
                const flameGeometry = new THREE.ConeGeometry(0.08, 0.3, 6);
                const flameMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    emissive: 0xff3300,
                    transparent: true,
                    opacity: 0.7
                });
                const flame = new THREE.Mesh(flameGeometry, flameMaterial);
                flame.position.y = -0.2;
                flame.rotation.x = Math.PI;
                group.add(flame);

                return group;
            }

            createSlowProjectile() {
                const group = new THREE.Group();

                // Crystal core
                const geometry = new THREE.OctahedronGeometry(0.08);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xaa44ff,
                    emissive: 0x4411aa,
                    transparent: true,
                    opacity: 0.9
                });
                const crystal = new THREE.Mesh(geometry, material);
                group.add(crystal);

                // Rotating energy rings
                for (let i = 0; i < 3; i++) {
                    const ringGeometry = new THREE.TorusGeometry(0.1 + i * 0.03, 0.01, 4, 8);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: 0x8844ff,
                        transparent: true,
                        opacity: 0.5 - i * 0.1
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.random() * Math.PI;
                    ring.rotation.y = Math.random() * Math.PI;
                    ring.userData.rotationSpeed = 0.05 + Math.random() * 0.05;
                    group.add(ring);
                }

                return group;
            }

            createMuzzleFlash(tower) {
                const flashGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const flashMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.8
                });
                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                flash.position.copy(tower.position);
                flash.position.y += 1.3;
                this.scene.add(flash);

                // Animate flash
                let scale = 0;
                const animateFlash = () => {
                    scale += 0.3;
                    flash.scale.setScalar(scale);
                    flash.material.opacity -= 0.15;

                    if (flash.material.opacity <= 0) {
                        this.scene.remove(flash);
                    } else {
                        requestAnimationFrame(animateFlash);
                    }
                };
                animateFlash();
            }

            createProjectileTrail(projectile, type) {
                // Create simple particle trail effect
                const trailGeometry = new THREE.SphereGeometry(0.02, 4, 3);
                let trailMaterial;

                if (type === 'sniper') {
                    trailMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffff88,
                        transparent: true,
                        opacity: 0.6
                    });
                } else if (type === 'splash') {
                    trailMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff8844,
                        transparent: true,
                        opacity: 0.4
                    });
                }

                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                trail.position.copy(projectile.position);
                this.scene.add(trail);

                // Animate trail fade out
                let opacity = 0.6;
                const fadeTrail = () => {
                    opacity -= 0.05;
                    trail.material.opacity = opacity;
                    if (opacity <= 0) {
                        this.scene.remove(trail);
                    } else {
                        requestAnimationFrame(fadeTrail);
                    }
                };
                setTimeout(fadeTrail, 100);
            }

            moveProjectiles() {
                for (const [projectileId, projectile] of this.projectiles) {
                    if (!this.enemies.has(projectile.target.id)) {
                        // Target is gone, remove projectile
                        this.scene.remove(projectile.mesh);
                        this.projectiles.delete(projectileId);
                        continue;
                    }

                    // Animate special projectile effects
                    this.animateProjectileEffects(projectile);

                    const target = projectile.target.mesh.position;
                    const direction = new THREE.Vector3().subVectors(target, projectile.mesh.position);
                    const distance = direction.length();

                    if (distance < 0.3) {
                        // Hit target
                        this.projectileHit(projectile);
                        this.scene.remove(projectile.mesh);
                        this.projectiles.delete(projectileId);
                    } else {
                        // Move towards target (scaled by game speed)
                        direction.normalize();
                        projectile.mesh.position.add(direction.multiplyScalar(projectile.speed * this.gameSpeed));

                        // Create trail particles for moving projectiles
                        this.createProjectileParticleTrail(projectile);
                    }
                }
            }

            animateProjectileEffects(projectile) {
                // Animate slow projectile rings
                if (projectile.tower.type === 'slow') {
                    projectile.mesh.children.forEach((child, index) => {
                        if (index > 0) { // Skip main crystal
                            child.rotation.x += child.userData.rotationSpeed;
                            child.rotation.y += child.userData.rotationSpeed * 0.7;
                        }
                    });
                }

                // Animate mortar flame
                if (projectile.tower.type === 'splash') {
                    const flame = projectile.mesh.children[1];
                    if (flame) {
                        flame.scale.y = 0.8 + Math.sin(Date.now() * 0.01) * 0.2;
                    }
                }
            }

            createProjectileParticleTrail(projectile) {
                // Create trail particles for enhanced visual effect
                if (Math.random() < 0.3) { // Only create trail sometimes to avoid performance issues
                    const trailGeometry = new THREE.SphereGeometry(0.02, 4, 3);
                    let trailMaterial;

                    switch (projectile.tower.type) {
                        case 'basic':
                            trailMaterial = new THREE.MeshBasicMaterial({
                                color: 0x0088ff,
                                transparent: true,
                                opacity: 0.6
                            });
                            break;
                        case 'splash':
                            trailMaterial = new THREE.MeshBasicMaterial({
                                color: 0xff6600,
                                transparent: true,
                                opacity: 0.5
                            });
                            break;
                        case 'slow':
                            trailMaterial = new THREE.MeshBasicMaterial({
                                color: 0x8844ff,
                                transparent: true,
                                opacity: 0.4
                            });
                            break;
                        default:
                            return; // No trail for sniper (already has beam)
                    }

                    const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                    trail.position.copy(projectile.mesh.position);
                    this.scene.add(trail);

                    // Animate trail fade out
                    let opacity = trailMaterial.opacity;
                    const fadeTrail = () => {
                        opacity -= 0.05;
                        trail.material.opacity = opacity;
                        if (opacity <= 0) {
                            this.scene.remove(trail);
                        } else {
                            requestAnimationFrame(fadeTrail);
                        }
                    };
                    fadeTrail();
                }
            }

            projectileHit(projectile) {
                // Create explosion effect
                this.createExplosion(projectile.mesh.position);

                // Apply damage
                if (projectile.tower.splash) {
                    // Splash damage
                    for (const [enemyId, enemy] of this.enemies) {
                        const distance = projectile.mesh.position.distanceTo(enemy.mesh.position);
                        if (distance <= projectile.tower.splash) {
                            this.damageEnemy(enemy, projectile.damage, projectile.tower);
                        }
                    }
                } else {
                    // Single target damage
                    if (this.enemies.has(projectile.target.id)) {
                        this.damageEnemy(projectile.target, projectile.damage, projectile.tower);
                    }
                }
            }

            createExplosion(position) {
                // Enhanced explosion effect with particles
                const explosionGroup = new THREE.Group();

                // Main explosion sphere
                const explosionGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const explosionMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6b35,
                    transparent: true,
                    opacity: 0.8
                });
                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosionGroup.add(explosion);

                // Add particle sparks
                for (let i = 0; i < 8; i++) {
                    const sparkGeometry = new THREE.SphereGeometry(0.05, 4, 3);
                    const sparkMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffaa44,
                        transparent: true,
                        opacity: 1
                    });
                    const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);

                    // Random direction
                    const angle = (i / 8) * Math.PI * 2;
                    spark.position.set(
                        Math.cos(angle) * 0.2,
                        Math.random() * 0.2,
                        Math.sin(angle) * 0.2
                    );
                    spark.userData.velocity = {
                        x: Math.cos(angle) * 0.05,
                        y: Math.random() * 0.05,
                        z: Math.sin(angle) * 0.05
                    };
                    explosionGroup.add(spark);
                }

                explosionGroup.position.copy(position);
                this.scene.add(explosionGroup);

                // Animate explosion with enhanced effects
                let scale = 0;
                let time = 0;
                const animateExplosion = () => {
                    time += 0.1;
                    scale += 0.15;

                    // Main explosion scaling and fading
                    explosion.scale.setScalar(scale);
                    explosion.material.opacity = Math.max(0, 0.8 - time * 2);

                    // Animate sparks
                    explosionGroup.children.forEach((child, index) => {
                        if (index > 0) { // Skip main explosion
                            child.position.add(new THREE.Vector3(
                                child.userData.velocity.x,
                                child.userData.velocity.y,
                                child.userData.velocity.z
                            ));
                            child.material.opacity = Math.max(0, 1 - time * 3);
                            child.userData.velocity.y -= 0.002; // Gravity
                        }
                    });

                    if (explosion.material.opacity <= 0) {
                        this.scene.remove(explosionGroup);
                    } else {
                        requestAnimationFrame(animateExplosion);
                    }
                };
                animateExplosion();
            }

            damageEnemy(enemy, damage, tower) {
                enemy.health -= damage;

                // Apply slow effect
                if (tower.slow) {
                    enemy.slowEffect = tower.slow;
                }

                // Create damage effect
                this.createDamageEffect(enemy.mesh.position, damage);

                if (enemy.health <= 0) {
                    // Create death effect before removing enemy
                    this.createDeathEffect(enemy);

                    // Enemy killed
                    this.gold += enemy.reward;
                    this.currentScore += enemy.reward * 10;
                    this.enemies.delete(enemy.id);
                    this.scene.remove(enemy.mesh);
                    this.showNotification(`💰 +$${enemy.reward}`);
                }
            }

            createDamageEffect(position, damage) {
                // Create floating damage number
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 64;
                canvas.height = 32;

                context.fillStyle = '#ff4444';
                context.font = 'bold 20px Arial';
                context.textAlign = 'center';
                context.fillText('-' + damage, 32, 24);

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(material);
                sprite.position.copy(position);
                sprite.position.y += 0.5;
                sprite.scale.set(0.5, 0.25, 1);
                this.scene.add(sprite);

                // Animate damage number
                let time = 0;
                const animateDamage = () => {
                    time += 0.1;
                    sprite.position.y += 0.02;
                    sprite.material.opacity = Math.max(0, 1 - time);
                    sprite.scale.setScalar(1 + time * 0.5);

                    if (sprite.material.opacity <= 0) {
                        this.scene.remove(sprite);
                    } else {
                        requestAnimationFrame(animateDamage);
                    }
                };
                animateDamage();
            }

            createDeathEffect(enemy) {
                const position = enemy.mesh.position.clone();

                // Create death explosion based on enemy type
                const deathGroup = new THREE.Group();

                // Main death burst
                const burstGeometry = new THREE.SphereGeometry(0.4, 8, 6);
                const burstMaterial = new THREE.MeshBasicMaterial({
                    color: enemy.type === 'boss' ? 0x8e44ad : 0xff4444,
                    transparent: true,
                    opacity: 0.8
                });
                const burst = new THREE.Mesh(burstGeometry, burstMaterial);
                deathGroup.add(burst);

                // Particle fragments
                for (let i = 0; i < 12; i++) {
                    const fragmentGeometry = new THREE.SphereGeometry(0.05, 4, 3);
                    const fragmentMaterial = new THREE.MeshBasicMaterial({
                        color: Math.random() > 0.5 ? 0xff6666 : 0xffaa44,
                        transparent: true,
                        opacity: 1
                    });
                    const fragment = new THREE.Mesh(fragmentGeometry, fragmentMaterial);

                    // Random direction
                    const angle = (i / 12) * Math.PI * 2;
                    const radius = 0.2 + Math.random() * 0.3;
                    fragment.position.set(
                        Math.cos(angle) * radius,
                        Math.random() * 0.3,
                        Math.sin(angle) * radius
                    );
                    fragment.userData.velocity = {
                        x: Math.cos(angle) * 0.08,
                        y: Math.random() * 0.1 + 0.05,
                        z: Math.sin(angle) * 0.08
                    };
                    deathGroup.add(fragment);
                }

                deathGroup.position.copy(position);
                this.scene.add(deathGroup);

                // Animate death effect
                let scale = 0;
                let time = 0;
                const animateDeath = () => {
                    time += 0.08;
                    scale += 0.2;

                    // Main burst animation
                    burst.scale.setScalar(scale);
                    burst.material.opacity = Math.max(0, 0.8 - time * 2);

                    // Fragment animation
                    deathGroup.children.forEach((child, index) => {
                        if (index > 0) { // Skip main burst
                            child.position.add(new THREE.Vector3(
                                child.userData.velocity.x,
                                child.userData.velocity.y,
                                child.userData.velocity.z
                            ));
                            child.material.opacity = Math.max(0, 1 - time * 1.5);
                            child.userData.velocity.y -= 0.005; // Gravity
                            child.rotation.x += 0.1;
                            child.rotation.y += 0.1;
                        }
                    });

                    if (burst.material.opacity <= 0) {
                        this.scene.remove(deathGroup);
                    } else {
                        requestAnimationFrame(animateDeath);
                    }
                };
                animateDeath();
            }

            checkWaveCompletion() {
                if (this.isWaveActive && this.enemiesSpawned >= this.enemiesInWave && this.enemies.size === 0) {
                    // Wave completed
                    this.isWaveActive = false;
                    this.wave++;
                    this.gold += 20;
                    this.currentScore += (this.wave - 1) * 100;
                    this.startWaveBtn.disabled = false;
                    this.startWaveBtn.textContent = 'Start Wave';

                    this.showNotification(`🎉 Wave ${this.wave - 1} completed! +$20 bonus`);
                    this.nextWaveTimer = 30;
                    this.updateLeaderboardEntry();
                }
            }

            startNextWaveTimer() {
                setInterval(() => {
                    if (!this.isWaveActive && this.nextWaveTimer > 0) {
                        this.nextWaveTimer -= this.gameSpeed;
                        this.nextWaveTime.textContent = Math.ceil(this.nextWaveTimer) + 's';

                        if (this.nextWaveTimer <= 0) {
                            this.startWave();
                            this.nextWaveTimer = 30;
                        }
                    }
                }, 1000);
            }

            startGameLoop() {
                const gameLoop = () => {
                    this.moveEnemies();
                    this.towerShooting();
                    this.moveProjectiles();
                    this.checkWaveCompletion();
                    this.updateUI();
                    requestAnimationFrame(gameLoop);
                };
                gameLoop();
            }

            updateUI() {
                this.playerGoldDisplay.textContent = this.gold;
                this.playerLivesDisplay.textContent = this.lives;
                this.currentWaveDisplay.textContent = this.wave;
                this.playerScoreDisplay.textContent = this.currentScore.toLocaleString();
                this.enemiesLeft.textContent = this.enemies.size;

                // Update wave progress
                if (this.isWaveActive && this.enemiesInWave > 0) {
                    const progress = ((this.enemiesInWave - this.enemies.size) / this.enemiesInWave) * 100;
                    this.waveFill.style.width = Math.max(0, progress) + '%';
                } else {
                    this.waveFill.style.width = '0%';
                }

                // Update tower button states
                Object.keys(this.towerTypes).forEach(type => {
                    const btn = document.getElementById(type + 'TowerBtn');
                    const tower = this.towerTypes[type];
                    btn.disabled = this.gold < tower.cost;
                });
            }

            setCameraView(view) {
                this.isFreeCam = false;
                this.freeCamInstructions.style.display = 'none';

                switch (view) {
                    case 'top':
                        this.camera.position.set(0, 15, 0);
                        this.camera.lookAt(0, 0, 0);
                        break;
                    case 'angle':
                        this.camera.position.set(0, 10, 8);
                        this.camera.lookAt(0, 0, 0);
                        break;
                    case 'free':
                        this.isFreeCam = true;
                        this.cameraRotation = { x: 0, y: 0 };
                        this.freeCamInstructions.style.display = 'block';
                        break;
                }
            }

            handleKeyDown(e) {
                if (e.key === 'Escape') {
                    this.selectedTowerType = null;
                    this.hidePlacementGrid();
                    document.querySelectorAll('.tower-btn').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                } else if (e.key >= '1' && e.key <= '4') {
                    const types = ['basic', 'sniper', 'splash', 'slow'];
                    this.selectTowerType(types[parseInt(e.key) - 1]);
                }

                // Free camera controls
                if (this.isFreeCam) {
                    this.cameraKeys.add(e.key.toLowerCase());

                    // FOV/Perspective controls
                    if (e.key === '=' || e.key === '+') {
                        this.camera.fov = Math.max(10, this.camera.fov - 5);
                        this.camera.updateProjectionMatrix();
                    } else if (e.key === '-' || e.key === '_') {
                        this.camera.fov = Math.min(120, this.camera.fov + 5);
                        this.camera.updateProjectionMatrix();
                    }
                }
            }

            handleKeyUp(e) {
                if (this.isFreeCam) {
                    this.cameraKeys.delete(e.key.toLowerCase());
                }
            }

            handleMouseDown(e) {
                if (this.isFreeCam && e.button === 0) {
                    this.mouseDown = true;
                    this.lastMouse = { x: e.clientX, y: e.clientY };
                }
            }

            handleMouseUp(e) {
                if (this.isFreeCam) {
                    this.mouseDown = false;
                }
            }

            handleWheel(e) {
                if (this.isFreeCam) {
                    e.preventDefault();
                    const direction = new THREE.Vector3(0, 0, -1);
                    direction.applyQuaternion(this.camera.quaternion);
                    direction.multiplyScalar(e.deltaY * 0.01);
                    this.camera.position.add(direction);
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                // Update free camera
                if (this.isFreeCam) {
                    this.updateFreeCamera();
                }

                this.renderer.render(this.scene, this.camera);
            }

            updateFreeCamera() {
                const moveSpeed = 0.1;
                const rotateSpeed = 0.002;

                // Movement
                const direction = new THREE.Vector3();
                if (this.cameraKeys.has('w') || this.cameraKeys.has('arrowup')) {
                    direction.z -= 1;
                }
                if (this.cameraKeys.has('s') || this.cameraKeys.has('arrowdown')) {
                    direction.z += 1;
                }
                if (this.cameraKeys.has('a') || this.cameraKeys.has('arrowleft')) {
                    direction.x -= 1;
                }
                if (this.cameraKeys.has('d') || this.cameraKeys.has('arrowright')) {
                    direction.x += 1;
                }

                if (direction.length() > 0) {
                    direction.normalize();
                    direction.applyQuaternion(this.camera.quaternion);
                    direction.multiplyScalar(moveSpeed);
                    this.camera.position.add(direction);
                }

                // Mouse look
                if (this.mouseDown) {
                    const deltaX = (event.clientX - this.lastMouse.x) * rotateSpeed;
                    const deltaY = (event.clientY - this.lastMouse.y) * rotateSpeed;

                    this.cameraRotation.y -= deltaX;
                    this.cameraRotation.x -= deltaY;

                    // Clamp vertical rotation
                    this.cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraRotation.x));

                    // Apply rotation
                    this.camera.rotation.order = 'YXZ';
                    this.camera.rotation.y = this.cameraRotation.y;
                    this.camera.rotation.x = this.cameraRotation.x;

                    this.lastMouse = { x: event.clientX, y: event.clientY };
                }
            }

            setGameSpeed(speed) {
                this.gameSpeed = speed;

                // Update speed button states
                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(`speed${speed}x`).classList.add('active');
            }

            onWindowResize() {
                const width = window.innerWidth;
                const height = window.innerHeight - 80;

                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }

            // Leaderboard functions (simplified)
            async loadLeaderboard() {
                try {
                    const leaderboardRef = ref(database, 'leaderboard');
                    onValue(leaderboardRef, (snapshot) => {
                        if (snapshot.exists()) {
                            const data = snapshot.val();
                            this.leaderboard = Object.values(data).sort((a, b) => b.score - a.score);
                            this.updateLeaderboardDisplay();
                        }
                    });
                } catch (error) {
                    console.error('Failed to load leaderboard:', error);
                }
            }

            startLeaderboardSync() {
                setInterval(() => {
                    this.updateLeaderboardEntry();
                }, 10000);
            }

            async updateLeaderboardEntry() {
                try {
                    const leaderboardRef = ref(database, `leaderboard/${this.playerId}`);
                    await set(leaderboardRef, {
                        name: this.playerName,
                        score: this.currentScore,
                        wave: this.wave,
                        gold: this.gold,
                        lives: this.lives,
                        lastUpdated: serverTimestamp()
                    });
                } catch (error) {
                    console.error('Failed to update leaderboard:', error);
                }
            }

            updateLeaderboardDisplay() {
                this.leaderboardList.innerHTML = '';

                this.leaderboard.slice(0, 10).forEach((player, index) => {
                    const entry = document.createElement('div');
                    entry.className = 'leaderboard-entry';

                    if (player.name === this.playerName) {
                        entry.classList.add('current-player');
                    }

                    let rankIcon = '';
                    if (index === 0) rankIcon = '<span class="crown">👑</span>';
                    else if (index === 1) rankIcon = '<span class="medal">🥈</span>';
                    else if (index === 2) rankIcon = '<span class="bronze">🥉</span>';

                    entry.innerHTML = `
                        <div class="player-rank">${rankIcon}${index + 1}</div>
                        <div class="player-info">
                            <div>${player.name}</div>
                            <div class="player-stats">Wave ${player.wave} • $${player.gold}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-weight: bold; color: #00f5ff;">${player.score.toLocaleString()}</div>
                            <div style="font-size: 0.7rem; opacity: 0.7;">❤️${player.lives}</div>
                        </div>
                    `;

                    this.leaderboardList.appendChild(entry);
                });
            }

            async gameOver() {
                await this.updateLeaderboardEntry();

                const gameOverDiv = document.createElement('div');
                gameOverDiv.className = 'game-over';
                gameOverDiv.innerHTML = `
                    <h1>GAME OVER</h1>
                    <p>You reached wave ${this.wave}</p>
                    <p>Final Score: <span style="color: #00f5ff; font-weight: bold;">${this.currentScore.toLocaleString()}</span></p>
                    <p>Gold Earned: $${this.gold}</p>
                    <button class="btn btn-primary" onclick="location.reload()">Play Again</button>
                `;
                this.gameContainer.appendChild(gameOverDiv);
            }

            showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 2500);
            }

            showError(message) {
                this.nameError.textContent = message;
                this.nameError.style.display = 'block';
                setTimeout(() => {
                    this.nameError.style.display = 'none';
                }, 5000);
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            new TowerDefense3D();
        });
    </script>
</body>
</html>