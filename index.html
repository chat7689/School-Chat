<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale Plus Blooket</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #2d1b69 100%);
            color: white;
            overflow: hidden;
        }

        .game-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .name-prompt {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #2d1b69 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .name-card {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
            padding: 3rem;
            border-radius: 20px;
            text-align: center;
            border: 2px solid rgba(0, 245, 255, 0.3);
            min-width: 400px;
        }

        .name-title {
            font-size: 2rem;
            font-weight: 800;
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 2rem;
        }

        .input-group {
            margin: 1rem 0;
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #00f5ff;
            font-weight: 600;
        }

        .input-group input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        .input-group input:focus {
            outline: none;
            border-color: #00f5ff;
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
        }

        .connection-status {
            margin: 1rem 0;
            padding: 0.5rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-connected {
            color: #4ade80;
            background: rgba(74, 222, 128, 0.1);
        }

        .status-disconnected {
            color: #f87171;
            background: rgba(248, 113, 113, 0.1);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00f5ff;
            animation: blink 2s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            position: relative;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stats {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem 1rem;
            border-radius: 25px;
            backdrop-filter: blur(5px);
        }

        .stat-value {
            font-weight: 700;
            color: #00f5ff;
        }

        #gameCanvas {
            display: block;
            background: radial-gradient(circle, #1a2332 0%, #0f1419 100%);
        }

        .game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .tower-menu {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            pointer-events: auto;
        }

        .tower-btn {
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            min-width: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            pointer-events: auto;
        }

        .tower-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .tower-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .tower-btn.basic {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
        }

        .tower-btn.sniper {
            background: linear-gradient(135deg, #5cb85c, #449d44);
            color: white;
        }

        .tower-btn.splash {
            background: linear-gradient(135deg, #f0ad4e, #ec971f);
            color: white;
        }

        .tower-btn.slow {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
        }

        .tower-btn.laser {
            background: linear-gradient(135deg, #ff0066, #cc0044);
            color: white;
        }

        .tower-btn.poison {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }

        .tower-btn.electric {
            background: linear-gradient(135deg, #ffff00, #e6e600);
            color: black;
        }

        .tower-btn.booster {
            background: linear-gradient(135deg, #00ffff, #00cccc);
            color: black;
        }

        .tower-btn.selected {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
        }

        .tower-cost {
            font-size: 0.7rem;
            opacity: 0.9;
        }

        .wave-info {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            min-width: 200px;
            pointer-events: auto;
        }

        .wave-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin: 0.5rem 0;
            overflow: hidden;
        }

        .wave-fill {
            height: 100%;
            background: linear-gradient(90deg, #00f5ff, #0066ff);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .leaderboard {
            position: fixed;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            min-width: 250px;
            max-height: 400px;
            overflow-y: auto;
            pointer-events: auto;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            margin: 0.25rem 0;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .leaderboard-entry:hover {
            background: rgba(0, 245, 255, 0.1);
            transform: translateX(5px);
        }

        .leaderboard-entry.current-player {
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
        }

        .player-rank {
            font-weight: bold;
            color: #00f5ff;
            min-width: 30px;
        }

        .player-info {
            flex: 1;
            margin: 0 0.5rem;
        }

        .player-stats {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .crown {
            color: #ffd700;
            margin-right: 0.25rem;
        }

        .medal {
            color: #c0c0c0;
            margin-right: 0.25rem;
        }

        .bronze {
            color: #cd7f32;
            margin-right: 0.25rem;
        }

        .camera-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 0.5rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            pointer-events: auto;
        }

        .speed-controls {
            position: fixed;
            top: 100px;
            right: 250px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            pointer-events: auto;
        }

        .speed-btn {
            padding: 0.5rem 0.75rem;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0.25rem;
            display: inline-block;
            min-width: 45px;
            font-size: 0.8rem;
        }

        .speed-btn:hover {
            background: rgba(0, 245, 255, 0.2);
        }

        .speed-btn.active {
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
        }

        .free-cam-instructions {
            position: fixed;
            bottom: 150px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 0.75rem;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            font-size: 0.7rem;
            opacity: 0.8;
            max-width: 200px;
            display: none;
        }

        .camera-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0.25rem;
            display: block;
            width: 100%;
        }

        .camera-btn:hover {
            background: rgba(0, 245, 255, 0.2);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            pointer-events: auto;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .notification {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            border-radius: 15px;
            text-align: center;
            z-index: 1001;
            animation: notification-appear 0.3s ease-out;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }

        @keyframes notification-appear {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .game-over h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: #e74c3c;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00f5ff;
            font-size: 1.2rem;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <!-- Name Prompt Screen -->
    <div class="name-prompt" id="namePrompt">
        <div class="name-card">
            <h1 class="name-title">CLASH ROYALE PLUS BLOOKET</h1>
            <p style="margin-bottom: 2rem; opacity: 0.8;">Multiplayer Strategy Defense</p>

            <div class="connection-status" id="connectionStatus">
                <div class="status-dot"></div>
                <span>Connecting...</span>
            </div>

            <div class="input-group">
                <label for="playerName">Player Name</label>
                <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
            </div>

            <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                <button class="btn btn-primary" id="joinGameBtn" disabled>Join Game</button>
            </div>

            <div id="nameError" style="color: #f87171; margin-top: 1rem; display: none;"></div>
        </div>
    </div>

    <!-- Game Screen -->
    <div class="game-container" id="gameContainer" style="display: none;">
        <div class="header">
            <div class="logo">CLASH ROYALE PLUS BLOOKET</div>
            <div class="stats">
                <div class="stat-item">
                    <span>💰</span>
                    <span class="stat-value" id="playerGold">100</span>
                </div>
                <div class="stat-item">
                    <span>❤️</span>
                    <span class="stat-value" id="playerLives">20</span>
                </div>
                <div class="stat-item">
                    <span>Wave:</span>
                    <span class="stat-value" id="currentWave">1</span>
                </div>
                <div class="stat-item">
                    <span>Score:</span>
                    <span class="stat-value" id="playerScore">0</span>
                </div>
                <div class="connection-status">
                    <div class="status-dot"></div>
                    <span>Online</span>
                </div>
            </div>
        </div>

        <div style="position: relative; flex: 1;">
            <canvas id="gameCanvas"></canvas>
            <div class="loading" id="loadingText">Loading 3D assets...</div>

            <div class="game-ui">
                <div class="tower-menu">
                    <button class="tower-btn basic" id="basicTowerBtn">
                        <span>🔫 Basic</span>
                        <span class="tower-cost">$10</span>
                    </button>
                    <button class="tower-btn sniper" id="sniperTowerBtn">
                        <span>🎯 Sniper</span>
                        <span class="tower-cost">$25</span>
                    </button>
                    <button class="tower-btn splash" id="splashTowerBtn">
                        <span>💥 Splash</span>
                        <span class="tower-cost">$40</span>
                    </button>
                    <button class="tower-btn slow" id="slowTowerBtn">
                        <span>❄️ Slow</span>
                        <span class="tower-cost">$30</span>
                    </button>
                    <button class="tower-btn laser" id="laserTowerBtn">
                        <span>🔴 Laser</span>
                        <span class="tower-cost">$50</span>
                    </button>
                    <button class="tower-btn poison" id="poisonTowerBtn">
                        <span>☢️ Poison</span>
                        <span class="tower-cost">$35</span>
                    </button>
                    <button class="tower-btn electric" id="electricTowerBtn">
                        <span>⚡ Electric</span>
                        <span class="tower-cost">$60</span>
                    </button>
                    <button class="tower-btn booster" id="boosterTowerBtn">
                        <span>🚀 Booster</span>
                        <span class="tower-cost">$45</span>
                    </button>
                </div>

                <div class="wave-info">
                    <h3 style="margin-bottom: 0.5rem; color: #00f5ff;">Wave Progress</h3>
                    <div class="wave-progress">
                        <div class="wave-fill" id="waveFill" style="width: 0%;"></div>
                    </div>
                    <div style="font-size: 0.9rem; margin-top: 0.5rem;">
                        <div>Enemies: <span id="enemiesLeft">0</span></div>
                        <div>Next Wave: <span id="nextWaveTime">30s</span></div>
                    </div>
                    <button class="btn btn-primary" id="startWaveBtn" style="margin-top: 1rem; width: 100%;">Start Wave</button>
                </div>

                <div class="leaderboard">
                    <h3 style="margin-bottom: 0.5rem; color: #00f5ff;">🏆 Leaderboard</h3>
                    <div id="leaderboardList">
                        <!-- Leaderboard entries will be populated here -->
                    </div>
                </div>

                <div class="speed-controls">
                    <h4 style="margin-bottom: 0.5rem; color: #00f5ff; font-size: 0.9rem;">⚡ Game Speed</h4>
                    <div>
                        <button class="speed-btn active" id="speed1x">1x</button>
                        <button class="speed-btn" id="speed2x">2x</button>
                        <button class="speed-btn" id="speed3x">3x</button>
                        <button class="speed-btn" id="speed5x">5x</button>
                        <button class="speed-btn" id="speed10x">10x</button>
                    </div>
                </div>

                <div class="camera-controls">
                    <button class="camera-btn" id="topViewBtn">Top View</button>
                    <button class="camera-btn" id="angleViewBtn">Angle View</button>
                    <button class="camera-btn" id="freeViewBtn">Free Camera</button>
                </div>

                <div class="free-cam-instructions" id="freeCamInstructions">
                    <div style="color: #00f5ff; font-weight: bold; margin-bottom: 0.25rem;">Free Camera:</div>
                    <div>WASD/Arrows: Move</div>
                    <div>Mouse: Look around</div>
                    <div>Space/Shift: Up/Down</div>
                    <div>Scroll: Zoom</div>
                    <div>+/-: Change FOV</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Firebase SDKs -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, onValue, push, remove, onDisconnect, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBLkFMipRS631fDNr8uwgozmxXBnqLd5_o",
            authDomain: "base-control-b391e.firebaseapp.com",
            databaseURL: "https://base-control-b391e-default-rtdb.firebaseio.com/",
            projectId: "base-control-b391e",
            storageBucket: "base-control-b391e.firebasestorage.app",
            messagingSenderId: "116375376675",
            appId: "1:116375376675:web:cdc8688222c7c35accf296",
            measurementId: "G-JY7P6D49HM"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        class TowerDefense3D {
            constructor() {
                this.playerId = this.generatePlayerId();
                this.playerName = '';
                this.roomCode = 'tower-defense-3d';
                this.gameState = null;
                this.isConnected = false;

                // Game state
                this.gold = 100;
                this.lives = 20;
                this.wave = 1;
                this.currentScore = 0;
                this.selectedTowerType = null;
                this.isWaveActive = false;
                this.enemiesInWave = 0;
                this.enemiesSpawned = 0;
                this.nextWaveTimer = 30;
                this.leaderboard = [];

                // 3D Objects
                this.towers = new Map();
                this.enemies = new Map();
                this.projectiles = new Map();
                this.environmentObjects = [];
                this.previewTower = null;
                this.previewRange = null;
                this.selectedTower = null;

                // Performance optimization
                this.performanceMode = false;
                this.frameCount = 0;
                this.lastFrameTime = Date.now();

                // Tower types
                this.towerTypes = {
                    basic: { cost: 10, damage: 15, range: 3, fireRate: 1000, color: 0x4a90e2 },
                    sniper: { cost: 25, damage: 40, range: 6, fireRate: 2000, color: 0x5cb85c },
                    splash: { cost: 40, damage: 25, range: 2.5, fireRate: 1500, color: 0xf0ad4e, splash: 1.5 },
                    slow: { cost: 30, damage: 10, range: 3, fireRate: 800, color: 0x9b59b6, slow: 0.5 },
                    laser: { cost: 50, damage: 8, range: 4, fireRate: 200, color: 0xff0066, continuous: true },
                    poison: { cost: 35, damage: 12, range: 2.8, fireRate: 1200, color: 0x27ae60, poison: { damage: 3, duration: 5000 } },
                    electric: { cost: 60, damage: 30, range: 3.5, fireRate: 1800, color: 0xffff00, chain: 3 },
                    booster: { cost: 45, damage: 0, range: 4, fireRate: 0, color: 0x00ffff, boost: { damage: 1.5, range: 1.2, fireRate: 0.8 } }
                };

                // Enemy types (slower base speeds)
                this.enemyTypes = {
                    basic: { health: 50, speed: 0.005, reward: 5, color: 0xe74c3c },
                    fast: { health: 30, speed: 0.008, reward: 8, color: 0xf39c12 },
                    tank: { health: 150, speed: 0.003, reward: 15, color: 0x34495e },
                    boss: { health: 300, speed: 0.004, reward: 50, color: 0x8e44ad }
                };

                // Game speed and camera controls
                this.gameSpeed = 1;
                this.isFreeCam = false;
                this.cameraKeys = new Set();
                this.cameraVelocity = { x: 0, y: 0, z: 0 };
                this.mouseDown = false;
                this.lastMouse = { x: 0, y: 0 };
                this.cameraRotation = { x: 0, y: 0 };

                // Grid system
                this.gridSize = 1;
                this.placementGrid = [];
                this.gridTiles = [];
                this.hoveredTile = null;

                // Path waypoints (3D coordinates)
                this.pathPoints = [
                    { x: -8, z: 0, y: 0 },
                    { x: -6, z: 2, y: 0 },
                    { x: -4, z: 3, y: 0 },
                    { x: -2, z: 2, y: 0 },
                    { x: 0, z: 0, y: 0 },
                    { x: 2, z: -2, y: 0 },
                    { x: 4, z: -3, y: 0 },
                    { x: 6, z: -2, y: 0 },
                    { x: 8, z: 0, y: 0 }
                ];

                this.init();
            }

            generatePlayerId() {
                return 'player_' + Math.random().toString(36).substr(2, 9);
            }

            init() {
                this.initializeElements();
                this.bindEvents();
                this.checkConnection();
                this.setupThreeJS();
            }

            initializeElements() {
                this.namePrompt = document.getElementById('namePrompt');
                this.gameContainer = document.getElementById('gameContainer');
                this.connectionStatus = document.getElementById('connectionStatus');
                this.playerNameInput = document.getElementById('playerName');
                this.joinGameBtn = document.getElementById('joinGameBtn');
                this.playerGoldDisplay = document.getElementById('playerGold');
                this.playerLivesDisplay = document.getElementById('playerLives');
                this.currentWaveDisplay = document.getElementById('currentWave');
                this.playerScoreDisplay = document.getElementById('playerScore');
                this.waveFill = document.getElementById('waveFill');
                this.enemiesLeft = document.getElementById('enemiesLeft');
                this.nextWaveTime = document.getElementById('nextWaveTime');
                this.startWaveBtn = document.getElementById('startWaveBtn');
                this.nameError = document.getElementById('nameError');
                this.leaderboardList = document.getElementById('leaderboardList');
                this.loadingText = document.getElementById('loadingText');

                this.basicTowerBtn = document.getElementById('basicTowerBtn');
                this.sniperTowerBtn = document.getElementById('sniperTowerBtn');
                this.splashTowerBtn = document.getElementById('splashTowerBtn');
                this.slowTowerBtn = document.getElementById('slowTowerBtn');
                this.laserTowerBtn = document.getElementById('laserTowerBtn');
                this.poisonTowerBtn = document.getElementById('poisonTowerBtn');
                this.electricTowerBtn = document.getElementById('electricTowerBtn');
                this.boosterTowerBtn = document.getElementById('boosterTowerBtn');

                this.topViewBtn = document.getElementById('topViewBtn');
                this.angleViewBtn = document.getElementById('angleViewBtn');
                this.freeViewBtn = document.getElementById('freeViewBtn');
                this.freeCamInstructions = document.getElementById('freeCamInstructions');

                // Speed control buttons
                this.speed1xBtn = document.getElementById('speed1x');
                this.speed2xBtn = document.getElementById('speed2x');
                this.speed3xBtn = document.getElementById('speed3x');
                this.speed5xBtn = document.getElementById('speed5x');
                this.speed10xBtn = document.getElementById('speed10x');
            }

            bindEvents() {
                this.joinGameBtn.addEventListener('click', () => this.joinGame());
                this.playerNameInput.addEventListener('input', () => this.validateForm());
                this.playerNameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !this.joinGameBtn.disabled) {
                        this.joinGame();
                    }
                });

                this.basicTowerBtn.addEventListener('click', () => this.selectTowerType('basic'));
                this.sniperTowerBtn.addEventListener('click', () => this.selectTowerType('sniper'));
                this.splashTowerBtn.addEventListener('click', () => this.selectTowerType('splash'));
                this.slowTowerBtn.addEventListener('click', () => this.selectTowerType('slow'));
                this.laserTowerBtn.addEventListener('click', () => this.selectTowerType('laser'));
                this.poisonTowerBtn.addEventListener('click', () => this.selectTowerType('poison'));
                this.electricTowerBtn.addEventListener('click', () => this.selectTowerType('electric'));
                this.boosterTowerBtn.addEventListener('click', () => this.selectTowerType('booster'));

                this.startWaveBtn.addEventListener('click', () => this.startWave());

                this.topViewBtn.addEventListener('click', () => this.setCameraView('top'));
                this.angleViewBtn.addEventListener('click', () => this.setCameraView('angle'));
                this.freeViewBtn.addEventListener('click', () => this.setCameraView('free'));

                // Speed controls
                this.speed1xBtn.addEventListener('click', () => this.setGameSpeed(1));
                this.speed2xBtn.addEventListener('click', () => this.setGameSpeed(2));
                this.speed3xBtn.addEventListener('click', () => this.setGameSpeed(3));
                this.speed5xBtn.addEventListener('click', () => this.setGameSpeed(5));
                this.speed10xBtn.addEventListener('click', () => this.setGameSpeed(10));

                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));
            }

            async checkConnection() {
                try {
                    const connectedRef = ref(database, '.info/connected');
                    onValue(connectedRef, (snapshot) => {
                        this.isConnected = snapshot.val() === true;
                        this.updateConnectionStatus();
                        this.validateForm();
                    });
                } catch (error) {
                    console.error('Connection failed:', error);
                    this.updateConnectionStatus(false);
                }
            }

            updateConnectionStatus(connected = this.isConnected) {
                const statusElement = this.connectionStatus;
                if (connected) {
                    statusElement.className = 'connection-status status-connected';
                    statusElement.innerHTML = '<div class="status-dot"></div><span>Connected</span>';
                } else {
                    statusElement.className = 'connection-status status-disconnected';
                    statusElement.innerHTML = '<div class="status-dot"></div><span>Connection failed</span>';
                }
            }

            validateForm() {
                const nameValid = this.playerNameInput.value.trim().length > 0;
                const connected = this.isConnected;
                this.joinGameBtn.disabled = !nameValid || !connected;
            }

            setupThreeJS() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0f1419);

                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight - 80), 0.1, 1000);
                this.camera.position.set(0, 10, 8);
                this.camera.lookAt(0, 0, 0);

                // Renderer
                this.canvas = document.getElementById('gameCanvas');
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight - 80);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Lighting
                this.setupLighting();

                // Battlefield
                this.createBattlefield();

                // Raycaster for mouse interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));

                // Start render loop
                this.animate();

                this.loadingText.style.display = 'none';
            }

            setupLighting() {
                // Enhanced ambient light with color variation
                const ambientLight = new THREE.AmbientLight(0x404060, 0.3);
                this.scene.add(ambientLight);

                // Main directional light (sun)
                this.directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                this.directionalLight.position.set(15, 25, 10);
                this.directionalLight.castShadow = true;
                this.directionalLight.shadow.mapSize.width = 4096;
                this.directionalLight.shadow.mapSize.height = 4096;
                this.directionalLight.shadow.camera.near = 0.5;
                this.directionalLight.shadow.camera.far = 100;
                this.directionalLight.shadow.camera.left = -25;
                this.directionalLight.shadow.camera.right = 25;
                this.directionalLight.shadow.camera.top = 25;
                this.directionalLight.shadow.camera.bottom = -25;
                this.directionalLight.shadow.bias = -0.0001;
                this.scene.add(this.directionalLight);

                // Secondary fill light
                const fillLight = new THREE.DirectionalLight(0x8899ff, 0.3);
                fillLight.position.set(-10, 15, -5);
                this.scene.add(fillLight);

                // Dynamic atmospheric lighting
                const atmosphereLight = new THREE.PointLight(0x00aaff, 0.6, 50);
                atmosphereLight.position.set(0, 12, 0);
                this.scene.add(atmosphereLight);

                // Animate atmospheric light - optimized with frame skipping
                let atmosphereFrameCount = 0;
                const animateAtmosphere = () => {
                    atmosphereFrameCount++;
                    if (atmosphereFrameCount % 3 === 0) { // Update every 3rd frame
                        const time = Date.now() * 0.001;
                        atmosphereLight.intensity = 0.4 + Math.sin(time * 0.5) * 0.2;
                        atmosphereLight.color.setHSL(0.55 + Math.sin(time * 0.3) * 0.1, 0.8, 0.6);
                    }
                    requestAnimationFrame(animateAtmosphere);
                };
                animateAtmosphere();

                // Add rim lighting for dramatic effect
                const rimLight1 = new THREE.DirectionalLight(0xff6600, 0.2);
                rimLight1.position.set(-20, 10, 20);
                this.scene.add(rimLight1);

                const rimLight2 = new THREE.DirectionalLight(0x0066ff, 0.2);
                rimLight2.position.set(20, 10, -20);
                this.scene.add(rimLight2);
            }

            createBattlefield() {
                // Enhanced terrain with multiple layers
                this.createTerrain();

                // Create placement grid system
                this.createPlacementGrid();

                // Enhanced path with more detail
                this.createPath();

                // Add environmental elements
                this.createEnvironment();
            }

            createTerrain() {
                // Main ground plane with texture-like appearance
                const groundGeometry = new THREE.PlaneGeometry(24, 16);
                const groundMaterial = new THREE.MeshLambertMaterial({
                    color: 0x2a4d3a,
                    transparent: false
                });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);

                // Add grass patches
                for (let i = 0; i < 50; i++) {
                    const grassGeometry = new THREE.PlaneGeometry(0.5 + Math.random() * 0.5, 0.5 + Math.random() * 0.5);
                    const grassMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color().setHSL(0.25 + Math.random() * 0.1, 0.6, 0.3 + Math.random() * 0.2),
                        transparent: true,
                        opacity: 0.7
                    });
                    const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                    grass.position.set(
                        (Math.random() - 0.5) * 22,
                        0.01,
                        (Math.random() - 0.5) * 14
                    );
                    grass.rotation.x = -Math.PI / 2;
                    grass.rotation.z = Math.random() * Math.PI * 2;
                    this.scene.add(grass);
                }

                // Subtle grid helper
                const gridHelper = new THREE.GridHelper(20, 20, 0x004400, 0x002200);
                gridHelper.material.opacity = 0.2;
                gridHelper.material.transparent = true;
                this.scene.add(gridHelper);
            }

            createEnvironment() {
                // Add trees around the battlefield
                for (let i = 0; i < 15; i++) {
                    this.createTree(
                        (Math.random() - 0.5) * 30,
                        (Math.random() - 0.5) * 20
                    );
                }

                // Add rocks and details
                for (let i = 0; i < 20; i++) {
                    this.createRock(
                        (Math.random() - 0.5) * 25,
                        (Math.random() - 0.5) * 18
                    );
                }

                // Add energy crystals for ambiance
                for (let i = 0; i < 8; i++) {
                    this.createEnergyCrystal(
                        (Math.random() - 0.5) * 28,
                        (Math.random() - 0.5) * 20
                    );
                }
            }

            createTree(x, z) {
                const treeGroup = new THREE.Group();

                // Tree trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.15, 1.2, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3c28 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 0.6;
                trunk.castShadow = true;
                treeGroup.add(trunk);

                // Tree foliage (multiple spheres)
                for (let i = 0; i < 3; i++) {
                    const foliageGeometry = new THREE.SphereGeometry(0.4 + i * 0.1, 8, 6);
                    const foliageMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color().setHSL(0.25, 0.6, 0.2 + Math.random() * 0.2)
                    });
                    const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                    foliage.position.set(
                        (Math.random() - 0.5) * 0.3,
                        1.0 + i * 0.2,
                        (Math.random() - 0.5) * 0.3
                    );
                    foliage.castShadow = true;
                    treeGroup.add(foliage);
                }

                treeGroup.position.set(x, 0, z);
                // Don't add trees too close to the path
                const distanceToPath = Math.min(...this.pathPoints.map(point =>
                    Math.sqrt((x - point.x) ** 2 + (z - point.z) ** 2)
                ));
                if (distanceToPath > 2) {
                    this.scene.add(treeGroup);
                    this.environmentObjects.push({ x: x, z: z, type: 'tree', radius: 0.8 });
                }
            }

            createRock(x, z) {
                const rockGeometry = new THREE.DodecahedronGeometry(0.2 + Math.random() * 0.3);
                const rockMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(0, 0, 0.3 + Math.random() * 0.2)
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(x, 0.1, z);
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                rock.castShadow = true;
                this.scene.add(rock);
                this.environmentObjects.push({ x: x, z: z, type: 'rock', radius: 0.5 });
            }

            createEnergyCrystal(x, z) {
                const crystalGeometry = new THREE.OctahedronGeometry(0.15);
                const crystalMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    emissive: 0x002222,
                    transparent: true,
                    opacity: 0.8
                });
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                crystal.position.set(x, 0.3, z);

                // Add a subtle point light
                const light = new THREE.PointLight(0x00ffff, 0.3, 3);
                light.position.copy(crystal.position);
                light.position.y += 0.2;

                this.scene.add(crystal);
                this.scene.add(light);

                // Animate crystal
                const animateCrystal = () => {
                    const time = Date.now() * 0.001;
                    crystal.rotation.y = time;
                    crystal.position.y = 0.3 + Math.sin(time * 2) * 0.05;
                    requestAnimationFrame(animateCrystal);
                };
                animateCrystal();
            }

            createPath() {
                // Create a detailed, multi-layered path
                const pathWidth = 1.0;

                for (let i = 0; i < this.pathPoints.length - 1; i++) {
                    const current = this.pathPoints[i];
                    const next = this.pathPoints[i + 1];

                    // Calculate direction and distance
                    const direction = new THREE.Vector3(next.x - current.x, 0, next.z - current.z);
                    const distance = direction.length();
                    direction.normalize();

                    // Main path base (stone)
                    const baseGeometry = new THREE.PlaneGeometry(pathWidth + 0.4, distance);
                    const baseMaterial = new THREE.MeshLambertMaterial({
                        color: 0x444444,
                        transparent: true,
                        opacity: 0.8
                    });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.set(
                        (current.x + next.x) / 2,
                        0.01,
                        (current.z + next.z) / 2
                    );
                    base.rotation.x = -Math.PI / 2;
                    base.rotation.z = Math.atan2(direction.x, direction.z);
                    this.scene.add(base);

                    // Main path surface (dirt road)
                    const segmentGeometry = new THREE.PlaneGeometry(pathWidth, distance);
                    const segmentMaterial = new THREE.MeshLambertMaterial({
                        color: 0x8b6914,
                        transparent: true,
                        opacity: 0.95
                    });
                    const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                    segment.position.set(
                        (current.x + next.x) / 2,
                        0.03,
                        (current.z + next.z) / 2
                    );
                    segment.rotation.x = -Math.PI / 2;
                    segment.rotation.z = Math.atan2(direction.x, direction.z);
                    this.scene.add(segment);

                    // Path center line (worn track)
                    const centerGeometry = new THREE.PlaneGeometry(pathWidth * 0.3, distance);
                    const centerMaterial = new THREE.MeshLambertMaterial({
                        color: 0x5d4e37,
                        transparent: true,
                        opacity: 0.7
                    });
                    const center = new THREE.Mesh(centerGeometry, centerMaterial);
                    center.position.set(
                        (current.x + next.x) / 2,
                        0.04,
                        (current.z + next.z) / 2
                    );
                    center.rotation.x = -Math.PI / 2;
                    center.rotation.z = Math.atan2(direction.x, direction.z);
                    this.scene.add(center);

                    // Add path decorations (small stones)
                    for (let j = 0; j < 3; j++) {
                        const stoneGeometry = new THREE.DodecahedronGeometry(0.05 + Math.random() * 0.03);
                        const stoneMaterial = new THREE.MeshLambertMaterial({
                            color: new THREE.Color().setHSL(0, 0, 0.2 + Math.random() * 0.3)
                        });
                        const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
                        stone.position.set(
                            (current.x + next.x) / 2 + (Math.random() - 0.5) * pathWidth * 0.8,
                            0.08,
                            (current.z + next.z) / 2 + (Math.random() - 0.5) * distance * 0.8
                        );
                        stone.rotation.set(
                            Math.random() * Math.PI,
                            Math.random() * Math.PI,
                            Math.random() * Math.PI
                        );
                        stone.castShadow = true;
                        this.scene.add(stone);
                    }
                }

                // Enhanced path markers
                this.pathPoints.forEach((point, index) => {
                    if (index === 0) {
                        // Start portal
                        this.createPortal(point, 0xff2222, "spawn");
                    } else if (index === this.pathPoints.length - 1) {
                        // End portal
                        this.createPortal(point, 0x22ff22, "end");
                    } else {
                        // Waypoint crystals
                        const crystalGeometry = new THREE.OctahedronGeometry(0.1);
                        const crystalMaterial = new THREE.MeshBasicMaterial({
                            color: 0xffaa00,
                            emissive: 0x442200,
                            transparent: true,
                            opacity: 0.8
                        });
                        const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                        crystal.position.set(point.x, point.y + 0.2, point.z);
                        this.scene.add(crystal);

                        // Animate waypoint
                        const animateWaypoint = () => {
                            const time = Date.now() * 0.002;
                            crystal.rotation.y = time;
                            crystal.position.y = point.y + 0.2 + Math.sin(time * 3) * 0.05;
                            requestAnimationFrame(animateWaypoint);
                        };
                        animateWaypoint();
                    }
                });
            }

            createPortal(point, color, type) {
                const portalGroup = new THREE.Group();

                // Portal ring
                const ringGeometry = new THREE.TorusGeometry(0.5, 0.1, 8, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    emissive: color,
                    transparent: true,
                    opacity: 0.8
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                portalGroup.add(ring);

                // Portal center
                const centerGeometry = new THREE.CircleGeometry(0.4, 16);
                const centerMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.3
                });
                const center = new THREE.Mesh(centerGeometry, centerMaterial);
                center.rotation.x = -Math.PI / 2;
                center.position.y = 0.01;
                portalGroup.add(center);

                portalGroup.position.set(point.x, point.y + 0.1, point.z);
                this.scene.add(portalGroup);

                // Animate portal
                const animatePortal = () => {
                    const time = Date.now() * 0.003;
                    ring.rotation.z = time;
                    center.rotation.z = -time * 0.5;
                    portalGroup.position.y = point.y + 0.1 + Math.sin(time * 2) * 0.05;
                    requestAnimationFrame(animatePortal);
                };
                animatePortal();
            }

            handleCanvasClick(event) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);

                // Check if clicking on a tower first
                const towerMeshes = Array.from(this.towers.values()).map(tower => tower.mesh);
                const towerIntersects = this.raycaster.intersectObjects(towerMeshes, true);

                if (towerIntersects.length > 0) {
                    // Clicked on a tower - show its range
                    const clickedMesh = towerIntersects[0].object;
                    const tower = Array.from(this.towers.values()).find(t =>
                        t.mesh === clickedMesh || t.mesh.children.includes(clickedMesh) ||
                        t.mesh.children.some(child => child.children && child.children.includes(clickedMesh))
                    );
                    if (tower) {
                        this.showTowerRange(tower);
                        return;
                    }
                }

                // If not clicking on a tower, hide ranges
                this.hideTowerRanges();

                // Handle tower placement
                if (!this.selectedTowerType) return;

                const intersects = this.raycaster.intersectObject(this.ground);
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const position = intersect.point;

                    // Snap to grid centers (offset by 0.5 to center on squares)
                    position.x = Math.round(position.x - 0.5) + 0.5;
                    position.z = Math.round(position.z - 0.5) + 0.5;
                    position.y = 0;

                    // Check if position is valid (not on path, not occupied)
                    if (this.isValidTowerPosition(position)) {
                        this.placeTower(position, this.selectedTowerType);
                    }
                }
            }

            handleCanvasMouseMove(event) {
                if (!this.selectedTowerType) {
                    this.clearTowerPreview();
                    return;
                }

                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.ground);

                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const position = intersect.point;

                    // Snap to grid centers
                    const gridX = Math.round(position.x - 0.5) + 0.5;
                    const gridZ = Math.round(position.z - 0.5) + 0.5;
                    const snapPosition = new THREE.Vector3(gridX, 0, gridZ);

                    this.updateHoverTile(gridX, gridZ);
                    this.updateTowerPreview(snapPosition);
                }
            }

            updateTowerPreview(position) {
                // Clear existing preview
                this.clearTowerPreview();

                if (this.isValidTowerPosition(position)) {
                    // Create tower preview
                    this.previewTower = this.createTowerPreview(this.selectedTowerType);
                    this.previewTower.position.copy(position);
                    this.scene.add(this.previewTower);

                    // Create range preview
                    const towerConfig = this.towerTypes[this.selectedTowerType];
                    this.previewRange = this.createRangeIndicator(towerConfig.range);
                    this.previewRange.position.copy(position);
                    this.previewRange.visible = true;
                    // Make range preview more visible
                    this.previewRange.children.forEach(child => {
                        child.material.opacity *= 0.8;
                        child.material.color.setHex(0x00ff00);
                    });
                    this.scene.add(this.previewRange);
                }
            }

            createTowerPreview(type) {
                const towerGroup = new THREE.Group();

                // Base
                const baseGeometry = new THREE.CylinderGeometry(0.4, 0.5, 0.3, 8);
                const baseMaterial = new THREE.MeshLambertMaterial({
                    color: 0x555555,
                    transparent: true,
                    opacity: 0.6
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.15;
                towerGroup.add(base);

                // Tower body
                const towerConfig = this.towerTypes[type];
                const bodyGeometry = new THREE.CylinderGeometry(0.25, 0.35, 0.8, 6);
                const bodyMaterial = new THREE.MeshLambertMaterial({
                    color: towerConfig.color,
                    transparent: true,
                    opacity: 0.6
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.7;
                towerGroup.add(body);

                // Add weapon preview
                this.addTowerWeaponPreview(towerGroup, type);

                return towerGroup;
            }

            addTowerWeaponPreview(towerGroup, type) {
                let weaponMaterial = new THREE.MeshLambertMaterial({
                    color: 0x333333,
                    transparent: true,
                    opacity: 0.6
                });

                switch (type) {
                    case 'basic':
                        const cannonGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.6, 6);
                        const cannon = new THREE.Mesh(cannonGeometry, weaponMaterial);
                        cannon.position.y = 1.2;
                        cannon.rotation.z = Math.PI / 2;
                        towerGroup.add(cannon);
                        break;
                    case 'sniper':
                        const barrelGeometry = new THREE.CylinderGeometry(0.03, 0.04, 1.0, 8);
                        const barrel = new THREE.Mesh(barrelGeometry, weaponMaterial);
                        barrel.position.y = 1.3;
                        barrel.rotation.z = Math.PI / 2;
                        towerGroup.add(barrel);
                        break;
                    case 'splash':
                        const mortarGeometry = new THREE.CylinderGeometry(0.15, 0.12, 0.4, 6);
                        const mortar = new THREE.Mesh(mortarGeometry, weaponMaterial);
                        mortar.position.y = 1.3;
                        towerGroup.add(mortar);
                        break;
                    case 'slow':
                        for (let i = 0; i < 4; i++) {
                            const crystalGeometry = new THREE.ConeGeometry(0.05, 0.3, 4);
                            const crystalMaterial = new THREE.MeshLambertMaterial({
                                color: 0x9b59b6,
                                transparent: true,
                                opacity: 0.4
                            });
                            const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                            crystal.position.y = 1.2;
                            crystal.position.x = Math.cos(i * Math.PI / 2) * 0.2;
                            crystal.position.z = Math.sin(i * Math.PI / 2) * 0.2;
                            towerGroup.add(crystal);
                        }
                        break;
                    case 'laser':
                        const focusGeometry = new THREE.CylinderGeometry(0.15, 0.2, 0.1, 8);
                        const focus = new THREE.Mesh(focusGeometry, weaponMaterial);
                        focus.position.y = 1.3;
                        towerGroup.add(focus);
                        for (let i = 0; i < 6; i++) {
                            const laserGeometry = new THREE.CylinderGeometry(0.02, 0.04, 0.4, 6);
                            const laser = new THREE.Mesh(laserGeometry, weaponMaterial);
                            laser.position.y = 1.1;
                            laser.position.x = Math.cos(i * Math.PI / 3) * 0.15;
                            laser.position.z = Math.sin(i * Math.PI / 3) * 0.15;
                            towerGroup.add(laser);
                        }
                        break;
                    case 'poison':
                        const tankGeometry = new THREE.SphereGeometry(0.2, 8, 6);
                        const tank = new THREE.Mesh(tankGeometry, weaponMaterial);
                        tank.position.y = 1.2;
                        towerGroup.add(tank);
                        for (let i = 0; i < 3; i++) {
                            const nozzleGeometry = new THREE.CylinderGeometry(0.03, 0.06, 0.3, 6);
                            const nozzle = new THREE.Mesh(nozzleGeometry, weaponMaterial);
                            nozzle.position.y = 1.4;
                            nozzle.position.x = Math.cos(i * Math.PI * 2 / 3) * 0.12;
                            nozzle.position.z = Math.sin(i * Math.PI * 2 / 3) * 0.12;
                            nozzle.rotation.z = Math.PI / 2;
                            towerGroup.add(nozzle);
                        }
                        break;
                    case 'electric':
                        const coilGeometry = new THREE.CylinderGeometry(0.08, 0.12, 0.6, 8);
                        const coil = new THREE.Mesh(coilGeometry, weaponMaterial);
                        coil.position.y = 1.3;
                        towerGroup.add(coil);
                        for (let i = 0; i < 3; i++) {
                            const ringGeometry = new THREE.TorusGeometry(0.15 + i * 0.05, 0.02, 4, 8);
                            const ring = new THREE.Mesh(ringGeometry, weaponMaterial);
                            ring.position.y = 1.1 + i * 0.15;
                            ring.rotation.x = Math.PI / 2;
                            towerGroup.add(ring);
                        }
                        break;
                }
            }

            clearTowerPreview() {
                if (this.previewTower) {
                    this.scene.remove(this.previewTower);
                    this.previewTower = null;
                }
                if (this.previewRange) {
                    this.scene.remove(this.previewRange);
                    this.previewRange = null;
                }
            }

            isValidTowerPosition(position) {
                // Check if position is too close to path
                for (const pathPoint of this.pathPoints) {
                    const distance = Math.sqrt(
                        (position.x - pathPoint.x) ** 2 +
                        (position.z - pathPoint.z) ** 2
                    );
                    if (distance < 1.5) return false;
                }

                // Check if position is occupied by another tower
                for (const tower of this.towers.values()) {
                    const distance = Math.sqrt(
                        (position.x - tower.position.x) ** 2 +
                        (position.z - tower.position.z) ** 2
                    );
                    if (distance < 1) return false;
                }

                // Check bounds (extended area)
                if (Math.abs(position.x) > 11 || Math.abs(position.z) > 7) return false;

                // Check if position overlaps with environment objects (trees/rocks)
                for (const obj of this.environmentObjects) {
                    const distance = Math.sqrt(
                        (position.x - obj.x) ** 2 +
                        (position.z - obj.z) ** 2
                    );
                    if (distance < obj.radius + 0.5) return false; // Add some buffer
                }

                return true;
            }

            createPlacementGrid() {
                // Create visual grid tiles for tower placement
                const tileGeometry = new THREE.PlaneGeometry(0.9, 0.9);
                const validTileMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide
                });
                const invalidTileMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const hoverTileMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00f5ff,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });

                this.gridMaterials = {
                    valid: validTileMaterial,
                    invalid: invalidTileMaterial,
                    hover: hoverTileMaterial
                };

                // Create grid tiles at square centers (extended area)
                for (let x = -11; x <= 10; x++) {
                    for (let z = -7; z <= 6; z++) {
                        const tile = new THREE.Mesh(tileGeometry, validTileMaterial.clone());
                        tile.rotation.x = -Math.PI / 2;
                        tile.position.set(x + 0.5, 0.01, z + 0.5);
                        tile.userData = { gridX: x + 0.5, gridZ: z + 0.5 };
                        tile.visible = false; // Initially hidden
                        this.scene.add(tile);
                        this.gridTiles.push(tile);
                    }
                }
            }

            updateHoverTile(gridX, gridZ) {
                // Clear previous hover
                if (this.hoveredTile) {
                    this.hoveredTile.visible = false;
                }

                // Find the tile at this grid position
                const tile = this.gridTiles.find(t =>
                    t.userData.gridX === gridX && t.userData.gridZ === gridZ
                );

                if (tile) {
                    this.hoveredTile = tile;
                    const position = new THREE.Vector3(gridX, 0, gridZ);

                    if (this.isValidTowerPosition(position)) {
                        tile.material = this.gridMaterials.hover;
                    } else {
                        tile.material = this.gridMaterials.invalid;
                    }
                    tile.visible = true;
                }
            }

            showPlacementGrid() {
                // Show all grid tiles when a tower is selected
                this.gridTiles.forEach(tile => {
                    const position = new THREE.Vector3(tile.userData.gridX, 0, tile.userData.gridZ);
                    if (this.isValidTowerPosition(position)) {
                        tile.material = this.gridMaterials.valid;
                    } else {
                        tile.material = this.gridMaterials.invalid;
                    }
                    tile.visible = true;
                });
            }

            hidePlacementGrid() {
                // Hide all grid tiles
                this.gridTiles.forEach(tile => {
                    tile.visible = false;
                });
                this.hoveredTile = null;
            }

            selectTowerType(type) {
                // Clear previous selection
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.classList.remove('selected');
                });

                // Clear any existing tower preview
                this.clearTowerPreview();

                if (this.selectedTowerType === type) {
                    this.selectedTowerType = null;
                } else {
                    this.selectedTowerType = type;
                    const btn = document.getElementById(type + 'TowerBtn');
                    btn.classList.add('selected');
                }
            }

            placeTower(position, type) {
                const towerConfig = this.towerTypes[type];
                if (this.gold < towerConfig.cost) {
                    this.showNotification('❌ Not enough gold!');
                    return;
                }

                const towerId = 'tower_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);

                // Create 3D tower model
                const towerGroup = new THREE.Group();

                // Base
                const baseGeometry = new THREE.CylinderGeometry(0.4, 0.5, 0.3, 8);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.15;
                base.castShadow = true;
                towerGroup.add(base);

                // Tower body
                const bodyGeometry = new THREE.CylinderGeometry(0.25, 0.35, 0.8, 6);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: towerConfig.color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.7;
                body.castShadow = true;
                towerGroup.add(body);

                // Weapon (different for each type)
                this.addTowerWeapon(towerGroup, type);

                towerGroup.position.copy(position);
                this.scene.add(towerGroup);

                // Create range indicator
                const rangeIndicator = this.createRangeIndicator(towerConfig.range);
                rangeIndicator.position.copy(position);
                rangeIndicator.visible = false;
                this.scene.add(rangeIndicator);

                // Store tower data
                const towerData = {
                    id: towerId,
                    type: type,
                    position: position.clone(),
                    mesh: towerGroup,
                    rangeIndicator: rangeIndicator,
                    targetBeam: null,
                    lastFired: 0,
                    level: 1,
                    ...towerConfig
                };

                this.towers.set(towerId, towerData);
                this.gold -= towerConfig.cost;
                this.updateUI();

                this.showNotification(`🏗️ ${type.charAt(0).toUpperCase() + type.slice(1)} tower placed!`);
                this.selectedTowerType = null;
                this.hidePlacementGrid();
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.classList.remove('selected');
                });
            }

            createRangeIndicator(range) {
                const rangeGroup = new THREE.Group();

                // Range circle
                const rangeGeometry = new THREE.RingGeometry(range - 0.1, range + 0.1, 16);
                const rangeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide
                });
                const rangeCircle = new THREE.Mesh(rangeGeometry, rangeMaterial);
                rangeCircle.rotation.x = -Math.PI / 2;
                rangeCircle.position.y = 0.05;
                rangeGroup.add(rangeCircle);

                // Range area
                const areaGeometry = new THREE.CircleGeometry(range, 16);
                const areaMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.05,
                    side: THREE.DoubleSide
                });
                const rangeArea = new THREE.Mesh(areaGeometry, areaMaterial);
                rangeArea.rotation.x = -Math.PI / 2;
                rangeArea.position.y = 0.03;
                rangeGroup.add(rangeArea);

                return rangeGroup;
            }

            showTowerRange(tower) {
                // Hide all other range indicators
                this.towers.forEach(t => {
                    if (t.rangeIndicator) t.rangeIndicator.visible = false;
                });

                // Show this tower's range
                if (tower.rangeIndicator) {
                    tower.rangeIndicator.visible = true;
                }
            }

            hideTowerRanges() {
                this.towers.forEach(tower => {
                    if (tower.rangeIndicator) tower.rangeIndicator.visible = false;
                });
            }

            addTowerWeapon(towerGroup, type) {
                switch (type) {
                    case 'basic':
                        // Simple cannon
                        const cannonGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.6, 6);
                        const cannonMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                        const cannon = new THREE.Mesh(cannonGeometry, cannonMaterial);
                        cannon.position.y = 1.2;
                        cannon.rotation.z = Math.PI / 2;
                        towerGroup.add(cannon);
                        break;

                    case 'sniper':
                        // Long barrel
                        const barrelGeometry = new THREE.CylinderGeometry(0.03, 0.04, 1.0, 8);
                        const barrelMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e50 });
                        const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                        barrel.position.y = 1.3;
                        barrel.rotation.z = Math.PI / 2;
                        towerGroup.add(barrel);
                        break;

                    case 'splash':
                        // Mortar tube
                        const mortarGeometry = new THREE.CylinderGeometry(0.15, 0.12, 0.4, 6);
                        const mortarMaterial = new THREE.MeshLambertMaterial({ color: 0xd35400 });
                        const mortar = new THREE.Mesh(mortarGeometry, mortarMaterial);
                        mortar.position.y = 1.3;
                        towerGroup.add(mortar);
                        break;

                    case 'slow':
                        // Crystal array
                        for (let i = 0; i < 4; i++) {
                            const crystalGeometry = new THREE.ConeGeometry(0.05, 0.3, 4);
                            const crystalMaterial = new THREE.MeshLambertMaterial({
                                color: 0x9b59b6,
                                transparent: true,
                                opacity: 0.8
                            });
                            const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                            crystal.position.y = 1.2;
                            crystal.position.x = Math.cos(i * Math.PI / 2) * 0.2;
                            crystal.position.z = Math.sin(i * Math.PI / 2) * 0.2;
                            towerGroup.add(crystal);
                        }
                        break;
                    case 'laser':
                        // Laser array with focusing lens
                        const focusGeometry = new THREE.CylinderGeometry(0.15, 0.2, 0.1, 8);
                        const focusMaterial = new THREE.MeshLambertMaterial({ color: 0xff0066 });
                        const focus = new THREE.Mesh(focusGeometry, focusMaterial);
                        focus.position.y = 1.3;
                        towerGroup.add(focus);

                        for (let i = 0; i < 6; i++) {
                            const laserGeometry = new THREE.CylinderGeometry(0.02, 0.04, 0.4, 6);
                            const laserMaterial = new THREE.MeshLambertMaterial({ color: 0xff3388 });
                            const laser = new THREE.Mesh(laserGeometry, laserMaterial);
                            laser.position.y = 1.1;
                            laser.position.x = Math.cos(i * Math.PI / 3) * 0.15;
                            laser.position.z = Math.sin(i * Math.PI / 3) * 0.15;
                            towerGroup.add(laser);
                        }
                        break;
                    case 'poison':
                        // Poison tank with nozzles
                        const tankGeometry = new THREE.SphereGeometry(0.2, 8, 6);
                        const tankMaterial = new THREE.MeshLambertMaterial({ color: 0x27ae60 });
                        const tank = new THREE.Mesh(tankGeometry, tankMaterial);
                        tank.position.y = 1.2;
                        towerGroup.add(tank);

                        for (let i = 0; i < 3; i++) {
                            const nozzleGeometry = new THREE.CylinderGeometry(0.03, 0.06, 0.3, 6);
                            const nozzleMaterial = new THREE.MeshLambertMaterial({ color: 0x229954 });
                            const nozzle = new THREE.Mesh(nozzleGeometry, nozzleMaterial);
                            nozzle.position.y = 1.4;
                            nozzle.position.x = Math.cos(i * Math.PI * 2 / 3) * 0.12;
                            nozzle.position.z = Math.sin(i * Math.PI * 2 / 3) * 0.12;
                            nozzle.rotation.z = Math.PI / 2;
                            towerGroup.add(nozzle);
                        }
                        break;
                    case 'electric':
                        // Tesla coil with electric rings
                        const coilGeometry = new THREE.CylinderGeometry(0.08, 0.12, 0.6, 8);
                        const coilMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 });
                        const coil = new THREE.Mesh(coilGeometry, coilMaterial);
                        coil.position.y = 1.3;
                        towerGroup.add(coil);

                        for (let i = 0; i < 3; i++) {
                            const ringGeometry = new THREE.TorusGeometry(0.15 + i * 0.05, 0.02, 4, 8);
                            const ringMaterial = new THREE.MeshLambertMaterial({ color: 0xe6e600 });
                            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                            ring.position.y = 1.1 + i * 0.15;
                            ring.rotation.x = Math.PI / 2;
                            towerGroup.add(ring);
                        }
                        break;
                }
            }

            async joinGame() {
                this.playerName = this.playerNameInput.value.trim();

                try {
                    // Add player to the game
                    const playerRef = ref(database, `rooms/${this.roomCode}/players/${this.playerId}`);
                    await set(playerRef, {
                        name: this.playerName,
                        gold: this.gold,
                        lives: this.lives,
                        wave: this.wave,
                        score: this.currentScore,
                        connected: true,
                        joinedAt: serverTimestamp()
                    });

                    this.startGame();
                } catch (error) {
                    this.showError('Failed to join game: ' + error.message);
                }
            }

            startGame() {
                this.namePrompt.style.display = 'none';
                this.gameContainer.style.display = 'flex';

                // Set up Firebase listeners
                this.setupGameListeners();
                this.setupDisconnectCleanup();

                // Start game loops
                this.startGameLoop();
                this.startNextWaveTimer();
                this.loadLeaderboard();
                this.startLeaderboardSync();

                // Resize renderer
                this.onWindowResize();
                window.addEventListener('resize', () => this.onWindowResize());
            }

            setupGameListeners() {
                const roomRef = ref(database, `rooms/${this.roomCode}`);
                onValue(roomRef, (snapshot) => {
                    if (snapshot.exists()) {
                        this.gameState = snapshot.val();
                    }
                });
            }

            setupDisconnectCleanup() {
                const playerRef = ref(database, `rooms/${this.roomCode}/players/${this.playerId}`);
                onDisconnect(playerRef).remove();
            }

            async startWave() {
                if (this.isWaveActive) return;

                this.isWaveActive = true;
                this.enemiesInWave = Math.min(5 + this.wave * 2, 30);
                this.enemiesSpawned = 0;
                this.startWaveBtn.disabled = true;
                this.startWaveBtn.textContent = 'Wave Active';

                this.showNotification(`🌊 Wave ${this.wave} starting! ${this.enemiesInWave} enemies incoming!`);

                // Spawn enemies with delay (scaled by game speed)
                const spawnInterval = setInterval(() => {
                    if (this.enemiesSpawned >= this.enemiesInWave) {
                        clearInterval(spawnInterval);
                        return;
                    }

                    this.spawnEnemy();
                    this.enemiesSpawned++;
                }, 1500 / this.gameSpeed);
            }

            spawnEnemy() {
                let enemyType;

                // Different enemy types based on wave
                if (this.wave < 3) {
                    enemyType = 'basic';
                } else if (this.wave < 6) {
                    enemyType = Math.random() < 0.7 ? 'basic' : 'fast';
                } else if (this.wave < 10) {
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic';
                    else if (rand < 0.8) enemyType = 'fast';
                    else enemyType = 'tank';
                } else {
                    const rand = Math.random();
                    if (rand < 0.3) enemyType = 'basic';
                    else if (rand < 0.6) enemyType = 'fast';
                    else if (rand < 0.9) enemyType = 'tank';
                    else enemyType = 'boss';
                }

                const enemyId = 'enemy_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                const enemyConfig = this.enemyTypes[enemyType];

                // Create enhanced 3D enemy model
                const enemyGroup = new THREE.Group();

                let mainMesh;
                switch (enemyType) {
                    case 'basic':
                        mainMesh = this.createBasicEnemyModel(enemyConfig.color);
                        break;
                    case 'fast':
                        mainMesh = this.createFastEnemyModel(enemyConfig.color);
                        break;
                    case 'tank':
                        mainMesh = this.createTankEnemyModel(enemyConfig.color);
                        break;
                    case 'boss':
                        mainMesh = this.createBossEnemyModel(enemyConfig.color);
                        break;
                }

                enemyGroup.add(mainMesh);

                // Enhanced health bar with background
                const healthBarBg = new THREE.PlaneGeometry(0.5, 0.08);
                const healthBarBgMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
                const healthBarBackground = new THREE.Mesh(healthBarBg, healthBarBgMaterial);
                healthBarBackground.position.y = 0.6;
                enemyGroup.add(healthBarBackground);

                const healthBarGeometry = new THREE.PlaneGeometry(0.48, 0.06);
                const healthBarMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);
                healthBar.position.set(0, 0.6, 0.001); // Slightly in front of background
                enemyGroup.add(healthBar);

                // Position at start of path
                const startPos = this.pathPoints[0];
                enemyGroup.position.set(startPos.x, startPos.y + 0.2, startPos.z);
                this.scene.add(enemyGroup);

                // Store enemy data
                const enemyData = {
                    id: enemyId,
                    type: enemyType,
                    mesh: enemyGroup,
                    healthBar: healthBar,
                    healthBarBackground: healthBarBackground,
                    pathIndex: 0,
                    pathProgress: 0,
                    health: enemyConfig.health * (1 + this.wave * 0.1),
                    maxHealth: enemyConfig.health * (1 + this.wave * 0.1),
                    speed: enemyConfig.speed,
                    reward: enemyConfig.reward,
                    slowEffect: 1
                };

                this.enemies.set(enemyId, enemyData);
            }

            createBasicEnemyModel(color) {
                const group = new THREE.Group();

                // Enhanced main body with metallic sheen
                const bodyGeometry = new THREE.SphereGeometry(0.18, 8, 6);
                const bodyMaterial = new THREE.MeshLambertMaterial({
                    color: color,
                    emissive: new THREE.Color(color).multiplyScalar(0.1)
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                group.add(body);

                // Enhanced spikes with glow effect
                for (let i = 0; i < 8; i++) {
                    const spikeGeometry = new THREE.ConeGeometry(0.04, 0.15, 6);
                    const spikeMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color(color).multiplyScalar(0.8),
                        emissive: new THREE.Color(color).multiplyScalar(0.2)
                    });
                    const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                    const angle = (i / 8) * Math.PI * 2;
                    spike.position.set(Math.cos(angle) * 0.14, 0, Math.sin(angle) * 0.14);
                    spike.rotation.z = -angle + Math.PI / 2;
                    spike.castShadow = true;
                    group.add(spike);
                }

                // Core glow effect
                const coreGeometry = new THREE.SphereGeometry(0.08, 8, 6);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff4444,
                    emissive: 0xff2222,
                    transparent: true,
                    opacity: 0.8
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                group.add(core);

                return group;
            }

            createFastEnemyModel(color) {
                const group = new THREE.Group();

                // Enhanced sleek body
                const bodyGeometry = new THREE.ConeGeometry(0.15, 0.4, 12);
                const bodyMaterial = new THREE.MeshLambertMaterial({
                    color: color,
                    emissive: new THREE.Color(color).multiplyScalar(0.2)
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.2;
                body.castShadow = true;
                group.add(body);

                // Aerodynamic fins
                for (let i = 0; i < 4; i++) {
                    const finGeometry = new THREE.ConeGeometry(0.03, 0.12, 3);
                    const finMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color(color).multiplyScalar(0.7)
                    });
                    const fin = new THREE.Mesh(finGeometry, finMaterial);
                    const angle = (i / 4) * Math.PI * 2;
                    fin.position.set(Math.cos(angle) * 0.1, 0.1, Math.sin(angle) * 0.1);
                    fin.rotation.z = angle;
                    fin.castShadow = true;
                    group.add(fin);
                }

                // Enhanced speed trails with energy effect
                for (let i = 0; i < 5; i++) {
                    const trailGeometry = new THREE.ConeGeometry(0.06 - i * 0.01, 0.25, 6);
                    const trailMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(0.1 + i * 0.05, 1, 0.5),
                        transparent: true,
                        opacity: 0.8 - i * 0.15,
                        emissive: new THREE.Color().setHSL(0.1 + i * 0.05, 1, 0.3)
                    });
                    const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                    trail.position.y = -0.15 - i * 0.12;
                    trail.scale.setScalar(0.9 - i * 0.15);
                    group.add(trail);
                }

                return group;
            }

            createTankEnemyModel(color) {
                const group = new THREE.Group();

                // Enhanced main body with battle damage
                const bodyGeometry = new THREE.BoxGeometry(0.35, 0.25, 0.3);
                const bodyMaterial = new THREE.MeshLambertMaterial({
                    color: color,
                    emissive: new THREE.Color(color).multiplyScalar(0.1)
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                group.add(body);

                // Heavy armor plates
                const plateGeometry = new THREE.BoxGeometry(0.37, 0.08, 0.32);
                const plateMaterial = new THREE.MeshLambertMaterial({
                    color: 0x333333,
                    emissive: 0x111111
                });
                const topPlate = new THREE.Mesh(plateGeometry, plateMaterial);
                topPlate.position.y = 0.165;
                topPlate.castShadow = true;
                group.add(topPlate);

                // Enhanced side armor with detail
                for (let i = 0; i < 2; i++) {
                    const sideGeometry = new THREE.BoxGeometry(0.08, 0.3, 0.35);
                    const sideMaterial = new THREE.MeshLambertMaterial({
                        color: 0x444444,
                        emissive: 0x111111
                    });
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.x = i === 0 ? -0.215 : 0.215;
                    side.castShadow = true;
                    group.add(side);
                }

                // Tank treads/tracks
                for (let i = 0; i < 2; i++) {
                    const trackGeometry = new THREE.BoxGeometry(0.06, 0.12, 0.4);
                    const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
                    const track = new THREE.Mesh(trackGeometry, trackMaterial);
                    track.position.x = i === 0 ? -0.25 : 0.25;
                    track.position.y = -0.18;
                    track.castShadow = true;
                    group.add(track);
                }

                // Command antenna
                const antennaGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.15, 4);
                const antennaMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.y = 0.32;
                group.add(antenna);

                return group;
            }

            createBossEnemyModel(color) {
                const group = new THREE.Group();

                // Main body (octahedron)
                const bodyGeometry = new THREE.OctahedronGeometry(0.2);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                group.add(body);

                // Rotating energy ring
                const ringGeometry = new THREE.TorusGeometry(0.3, 0.02, 8, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.8
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.userData.rotationSpeed = 0.05;
                group.add(ring);

                // Crown spikes
                for (let i = 0; i < 8; i++) {
                    const spikeGeometry = new THREE.ConeGeometry(0.03, 0.15, 4);
                    const spikeMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                    const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                    const angle = (i / 8) * Math.PI * 2;
                    spike.position.set(Math.cos(angle) * 0.15, 0.2, Math.sin(angle) * 0.15);
                    spike.rotation.z = -angle;
                    group.add(spike);
                }

                return group;
            }

            moveEnemies() {
                for (const [enemyId, enemy] of this.enemies) {
                    // Move along path (scaled by game speed)
                    enemy.pathProgress += enemy.speed * enemy.slowEffect * this.gameSpeed;

                    if (enemy.pathProgress >= 1) {
                        enemy.pathIndex++;
                        enemy.pathProgress = 0;
                    }

                    if (enemy.pathIndex >= this.pathPoints.length - 1) {
                        // Enemy reached the end
                        this.lives--;
                        this.enemies.delete(enemyId);
                        this.scene.remove(enemy.mesh);
                        this.showNotification(`💔 Enemy reached base! Lives: ${this.lives}`);

                        if (this.lives <= 0) {
                            this.gameOver();
                        }
                        continue;
                    }

                    // Interpolate position between path points
                    const currentPoint = this.pathPoints[enemy.pathIndex];
                    const nextPoint = this.pathPoints[enemy.pathIndex + 1];

                    const position = new THREE.Vector3();
                    position.lerpVectors(
                        new THREE.Vector3(currentPoint.x, currentPoint.y + 0.2, currentPoint.z),
                        new THREE.Vector3(nextPoint.x, nextPoint.y + 0.2, nextPoint.z),
                        enemy.pathProgress
                    );

                    enemy.mesh.position.copy(position);

                    // Update health bar (right to left direction)
                    const healthPercent = enemy.health / enemy.maxHealth;
                    enemy.healthBar.scale.x = healthPercent;
                    enemy.healthBar.position.x = (1 - healthPercent) * 0.24; // Shift left as health decreases
                    enemy.healthBar.material.color.setRGB(1 - healthPercent, healthPercent, 0);
                    enemy.healthBar.lookAt(this.camera.position);
                    enemy.healthBarBackground.lookAt(this.camera.position);

                    // Animate enemy models
                    this.animateEnemyModel(enemy);

                    // Reset slow effect (scaled by game speed)
                    enemy.slowEffect = Math.min(1, enemy.slowEffect + 0.02 * this.gameSpeed);
                }
            }

            animateEnemyModel(enemy) {
                // Animate based on enemy type - only animate the main model (first child)
                const time = Date.now() * 0.001;
                const mainModel = enemy.mesh.children[0]; // The actual enemy model

                if (!mainModel) return;

                switch (enemy.type) {
                    case 'basic':
                        // Animate the main sphere and its spikes
                        if (mainModel.children[0]) {
                            mainModel.children[0].position.y = Math.sin(time * 3) * 0.05;
                        }
                        // Rotate spikes
                        for (let i = 1; i < mainModel.children.length; i++) {
                            if (mainModel.children[i]) {
                                mainModel.children[i].rotation.y = time + i;
                            }
                        }
                        break;
                    case 'fast':
                        // Fast spinning
                        mainModel.rotation.y = time * 4;
                        // Animate speed trails
                        for (let i = 1; i < mainModel.children.length; i++) {
                            if (mainModel.children[i] && mainModel.children[i].material) {
                                mainModel.children[i].material.opacity = 0.3 + Math.sin(time * 5 + i) * 0.2;
                            }
                        }
                        break;
                    case 'tank':
                        // Slow heavy movement
                        mainModel.rotation.y = time * 0.5;
                        break;
                    case 'boss':
                        // Rotating energy ring and oscillating body
                        if (mainModel.children[1]) {
                            mainModel.children[1].rotation.y = time * 2;
                        }
                        if (mainModel.children[0]) {
                            mainModel.children[0].rotation.x = Math.sin(time) * 0.2;
                            mainModel.children[0].rotation.z = Math.cos(time) * 0.2;
                        }
                        break;
                }
            }

            towerShooting() {
                const now = Date.now();

                for (const [towerId, tower] of this.towers) {
                    if (now - tower.lastFired < tower.fireRate / this.gameSpeed) continue;

                    // Find nearest enemy in range
                    let target = null;
                    let nearestDistance = Infinity;

                    for (const [enemyId, enemy] of this.enemies) {
                        const distance = tower.position.distanceTo(enemy.mesh.position);

                        if (distance <= tower.range && distance < nearestDistance) {
                            nearestDistance = distance;
                            target = enemy;
                        }
                    }

                    if (target) {
                        this.createTargetingBeam(tower, target);
                        this.fireTower(tower, target);
                        tower.lastFired = now;
                    } else {
                        this.removeTargetingBeam(tower);
                    }
                }
            }

            createTargetingBeam(tower, target) {
                // Remove existing beam
                this.removeTargetingBeam(tower);

                // Create new targeting beam
                const startPos = tower.position.clone();
                startPos.y += 1.2;
                const endPos = target.mesh.position.clone();

                const distance = startPos.distanceTo(endPos);
                const beamGeometry = new THREE.CylinderGeometry(0.02, 0.02, distance, 8);
                const beamMaterial = new THREE.MeshBasicMaterial({
                    color: tower.color,
                    transparent: true,
                    opacity: 0.6
                });
                const beam = new THREE.Mesh(beamGeometry, beamMaterial);

                // Position and orient beam
                beam.position.copy(startPos);
                beam.position.lerp(endPos, 0.5);
                beam.lookAt(endPos);
                beam.rotateX(Math.PI / 2);

                this.scene.add(beam);
                tower.targetBeam = beam;

                // Animate beam
                const animateBeam = () => {
                    if (tower.targetBeam === beam && this.enemies.has(target.id)) {
                        const time = Date.now() * 0.01;
                        beam.material.opacity = 0.3 + Math.sin(time) * 0.3;
                        requestAnimationFrame(animateBeam);
                    }
                };
                animateBeam();
            }

            removeTargetingBeam(tower) {
                if (tower.targetBeam) {
                    this.scene.remove(tower.targetBeam);
                    tower.targetBeam = null;
                }
            }

            fireTower(tower, enemy) {
                // Create muzzle flash effect
                this.createMuzzleFlash(tower);

                // Create enhanced projectiles based on tower type
                let projectileGroup, projectileSpeed = 0.08; // Much slower base speed

                switch (tower.type) {
                    case 'basic':
                        projectileGroup = this.createBasicProjectile();
                        projectileSpeed = 0.1;
                        break;
                    case 'sniper':
                        projectileGroup = this.createSniperLaser(tower.position, enemy.mesh.position);
                        projectileSpeed = 0.25; // Still faster but more visible
                        break;
                    case 'splash':
                        projectileGroup = this.createMortarShell();
                        projectileSpeed = 0.06; // Very slow for mortar
                        break;
                    case 'slow':
                        projectileGroup = this.createSlowProjectile();
                        projectileSpeed = 0.12;
                        break;
                    default:
                        projectileGroup = this.createBasicProjectile();
                }

                projectileGroup.position.copy(tower.position);
                projectileGroup.position.y += 1.2; // Fire from tower top
                this.scene.add(projectileGroup);

                const projectileId = 'proj_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                const projectileData = {
                    id: projectileId,
                    mesh: projectileGroup,
                    target: enemy,
                    tower: tower,
                    speed: projectileSpeed,
                    damage: tower.damage,
                    trailParticles: []
                };

                this.projectiles.set(projectileId, projectileData);
            }

            createBasicProjectile() {
                const group = new THREE.Group();

                // Main projectile
                const geometry = new THREE.SphereGeometry(0.1, 8, 6);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00aaff,
                    emissive: 0x0055aa
                });
                const projectile = new THREE.Mesh(geometry, material);
                group.add(projectile);

                // Glowing aura
                const auraGeometry = new THREE.SphereGeometry(0.15, 8, 6);
                const auraMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0088ff,
                    transparent: true,
                    opacity: 0.3
                });
                const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                group.add(aura);

                return group;
            }

            createSniperLaser(startPos, targetPos) {
                const group = new THREE.Group();

                // Laser beam
                const distance = startPos.distanceTo(targetPos);
                const geometry = new THREE.CylinderGeometry(0.02, 0.02, distance, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    emissive: 0xffaa00,
                    transparent: true,
                    opacity: 0.8
                });
                const laser = new THREE.Mesh(geometry, material);

                // Position and orient the laser
                laser.position.y = distance / 2;
                laser.lookAt(targetPos);
                group.add(laser);

                // Bright core
                const coreGeometry = new THREE.SphereGeometry(0.05, 6, 4);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff88,
                    emissive: 0xffff44
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                group.add(core);

                return group;
            }

            createMortarShell() {
                const group = new THREE.Group();

                // Simpler shell body - reduced complexity
                const shellGeometry = new THREE.SphereGeometry(0.12, 8, 6);
                const shellMaterial = new THREE.MeshLambertMaterial({
                    color: 0x444444
                });
                const shell = new THREE.Mesh(shellGeometry, shellMaterial);
                group.add(shell);

                // Simple flame trail - single layer
                const flameGeometry = new THREE.ConeGeometry(0.08, 0.3, 6);
                const flameMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff4400,
                    transparent: true,
                    opacity: 0.8
                });
                const flame = new THREE.Mesh(flameGeometry, flameMaterial);
                flame.position.y = -0.2;
                flame.rotation.x = Math.PI;
                group.add(flame);

                return group;
            }

            createSlowProjectile() {
                const group = new THREE.Group();

                // Crystal core
                const geometry = new THREE.OctahedronGeometry(0.08);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xaa44ff,
                    emissive: 0x4411aa,
                    transparent: true,
                    opacity: 0.9
                });
                const crystal = new THREE.Mesh(geometry, material);
                group.add(crystal);

                // Rotating energy rings
                for (let i = 0; i < 3; i++) {
                    const ringGeometry = new THREE.TorusGeometry(0.1 + i * 0.03, 0.01, 4, 8);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: 0x8844ff,
                        transparent: true,
                        opacity: 0.5 - i * 0.1
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.random() * Math.PI;
                    ring.rotation.y = Math.random() * Math.PI;
                    ring.userData.rotationSpeed = 0.05 + Math.random() * 0.05;
                    group.add(ring);
                }

                return group;
            }

            createMuzzleFlash(tower) {
                const flashGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const flashMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.8
                });
                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                flash.position.copy(tower.position);
                flash.position.y += 1.3;
                this.scene.add(flash);

                // Animate flash
                let scale = 0;
                const animateFlash = () => {
                    scale += 0.3;
                    flash.scale.setScalar(scale);
                    flash.material.opacity -= 0.15;

                    if (flash.material.opacity <= 0) {
                        this.scene.remove(flash);
                    } else {
                        requestAnimationFrame(animateFlash);
                    }
                };
                animateFlash();
            }

            createProjectileTrail(projectile, type) {
                // Create simple particle trail effect
                const trailGeometry = new THREE.SphereGeometry(0.02, 4, 3);
                let trailMaterial;

                if (type === 'sniper') {
                    trailMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffff88,
                        transparent: true,
                        opacity: 0.6
                    });
                } else if (type === 'splash') {
                    trailMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff8844,
                        transparent: true,
                        opacity: 0.4
                    });
                }

                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                trail.position.copy(projectile.position);
                this.scene.add(trail);

                // Animate trail fade out
                let opacity = 0.6;
                const fadeTrail = () => {
                    opacity -= 0.05;
                    trail.material.opacity = opacity;
                    if (opacity <= 0) {
                        this.scene.remove(trail);
                    } else {
                        requestAnimationFrame(fadeTrail);
                    }
                };
                setTimeout(fadeTrail, 100);
            }

            moveProjectiles() {
                for (const [projectileId, projectile] of this.projectiles) {
                    if (!this.enemies.has(projectile.target.id)) {
                        // Target is gone, remove projectile
                        this.scene.remove(projectile.mesh);
                        this.projectiles.delete(projectileId);
                        continue;
                    }

                    // Animate special projectile effects
                    this.animateProjectileEffects(projectile);

                    const target = projectile.target.mesh.position;
                    const direction = new THREE.Vector3().subVectors(target, projectile.mesh.position);
                    const distance = direction.length();

                    if (distance < 0.3) {
                        // Hit target
                        this.projectileHit(projectile);
                        this.scene.remove(projectile.mesh);
                        this.projectiles.delete(projectileId);
                    } else {
                        // Move towards target (scaled by game speed)
                        direction.normalize();
                        projectile.mesh.position.add(direction.multiplyScalar(projectile.speed * this.gameSpeed));

                        // Create trail particles for moving projectiles
                        this.createProjectileParticleTrail(projectile);
                    }
                }
            }

            animateProjectileEffects(projectile) {
                // Animate slow projectile rings
                if (projectile.tower.type === 'slow') {
                    projectile.mesh.children.forEach((child, index) => {
                        if (index > 0) { // Skip main crystal
                            child.rotation.x += child.userData.rotationSpeed;
                            child.rotation.y += child.userData.rotationSpeed * 0.7;
                        }
                    });
                }

                // Animate mortar flame
                if (projectile.tower.type === 'splash') {
                    const flame = projectile.mesh.children[1];
                    if (flame) {
                        flame.scale.y = 0.8 + Math.sin(Date.now() * 0.01) * 0.2;
                    }
                }
            }

            createProjectileParticleTrail(projectile) {
                // Create trail particles for enhanced visual effect
                if (Math.random() < 0.3) { // Only create trail sometimes to avoid performance issues
                    const trailGeometry = new THREE.SphereGeometry(0.02, 4, 3);
                    let trailMaterial;

                    switch (projectile.tower.type) {
                        case 'basic':
                            trailMaterial = new THREE.MeshBasicMaterial({
                                color: 0x0088ff,
                                transparent: true,
                                opacity: 0.6
                            });
                            break;
                        case 'splash':
                            trailMaterial = new THREE.MeshBasicMaterial({
                                color: 0xff6600,
                                transparent: true,
                                opacity: 0.5
                            });
                            break;
                        case 'slow':
                            trailMaterial = new THREE.MeshBasicMaterial({
                                color: 0x8844ff,
                                transparent: true,
                                opacity: 0.4
                            });
                            break;
                        default:
                            return; // No trail for sniper (already has beam)
                    }

                    const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                    trail.position.copy(projectile.mesh.position);
                    this.scene.add(trail);

                    // Animate trail fade out
                    let opacity = trailMaterial.opacity;
                    const fadeTrail = () => {
                        opacity -= 0.05;
                        trail.material.opacity = opacity;
                        if (opacity <= 0) {
                            this.scene.remove(trail);
                        } else {
                            requestAnimationFrame(fadeTrail);
                        }
                    };
                    fadeTrail();
                }
            }

            projectileHit(projectile) {
                // Create explosion effect
                this.createExplosion(projectile.mesh.position);

                // Apply damage
                if (projectile.tower.splash) {
                    // Splash damage
                    for (const [enemyId, enemy] of this.enemies) {
                        const distance = projectile.mesh.position.distanceTo(enemy.mesh.position);
                        if (distance <= projectile.tower.splash) {
                            this.damageEnemy(enemy, projectile.damage, projectile.tower);
                        }
                    }
                } else {
                    // Single target damage
                    if (this.enemies.has(projectile.target.id)) {
                        this.damageEnemy(projectile.target, projectile.damage, projectile.tower);
                    }
                }
            }

            createExplosion(position) {
                // Enhanced explosion effect with particles
                const explosionGroup = new THREE.Group();

                // Main explosion sphere
                const explosionGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const explosionMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6b35,
                    transparent: true,
                    opacity: 0.8
                });
                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosionGroup.add(explosion);

                // Add particle sparks
                for (let i = 0; i < 8; i++) {
                    const sparkGeometry = new THREE.SphereGeometry(0.05, 4, 3);
                    const sparkMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffaa44,
                        transparent: true,
                        opacity: 1
                    });
                    const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);

                    // Random direction
                    const angle = (i / 8) * Math.PI * 2;
                    spark.position.set(
                        Math.cos(angle) * 0.2,
                        Math.random() * 0.2,
                        Math.sin(angle) * 0.2
                    );
                    spark.userData.velocity = {
                        x: Math.cos(angle) * 0.05,
                        y: Math.random() * 0.05,
                        z: Math.sin(angle) * 0.05
                    };
                    explosionGroup.add(spark);
                }

                explosionGroup.position.copy(position);
                this.scene.add(explosionGroup);

                // Animate explosion with enhanced effects
                let scale = 0;
                let time = 0;
                const animateExplosion = () => {
                    time += 0.1;
                    scale += 0.15;

                    // Main explosion scaling and fading
                    explosion.scale.setScalar(scale);
                    explosion.material.opacity = Math.max(0, 0.8 - time * 2);

                    // Animate sparks
                    explosionGroup.children.forEach((child, index) => {
                        if (index > 0) { // Skip main explosion
                            child.position.add(new THREE.Vector3(
                                child.userData.velocity.x,
                                child.userData.velocity.y,
                                child.userData.velocity.z
                            ));
                            child.material.opacity = Math.max(0, 1 - time * 3);
                            child.userData.velocity.y -= 0.002; // Gravity
                        }
                    });

                    if (explosion.material.opacity <= 0) {
                        this.scene.remove(explosionGroup);
                    } else {
                        requestAnimationFrame(animateExplosion);
                    }
                };
                animateExplosion();
            }

            damageEnemy(enemy, damage, tower) {
                enemy.health -= damage;

                // Apply slow effect
                if (tower.slow) {
                    enemy.slowEffect = tower.slow;
                    this.createSlowEffect(enemy);
                }

                // Create damage effect
                this.createDamageEffect(enemy.mesh.position, damage);

                if (enemy.health <= 0) {
                    // Create death effect before removing enemy
                    this.createDeathEffect(enemy);

                    // Enemy killed
                    this.gold += enemy.reward;
                    this.currentScore += enemy.reward * 10;
                    this.enemies.delete(enemy.id);
                    this.scene.remove(enemy.mesh);
                    this.showNotification(`💰 +$${enemy.reward}`);
                }
            }

            createDamageEffect(position, damage) {
                // Create floating damage number
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 64;
                canvas.height = 32;

                context.fillStyle = '#ff4444';
                context.font = 'bold 20px Arial';
                context.textAlign = 'center';
                context.fillText('-' + damage, 32, 24);

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(material);
                sprite.position.copy(position);
                sprite.position.y += 0.5;
                sprite.scale.set(0.5, 0.25, 1);
                this.scene.add(sprite);

                // Animate damage number
                let time = 0;
                const animateDamage = () => {
                    time += 0.1;
                    sprite.position.y += 0.02;
                    sprite.material.opacity = Math.max(0, 1 - time);
                    sprite.scale.setScalar(1 + time * 0.5);

                    if (sprite.material.opacity <= 0) {
                        this.scene.remove(sprite);
                    } else {
                        requestAnimationFrame(animateDamage);
                    }
                };
                animateDamage();
            }

            createDeathEffect(enemy) {
                const position = enemy.mesh.position.clone();
                const deathGroup = new THREE.Group();

                // Optimized death explosion based on enemy type and performance
                const isBoss = enemy.type === 'boss';
                const baseSize = isBoss ? 0.6 : 0.4;
                const particleCount = this.performanceMode ? (isBoss ? 6 : 4) : (isBoss ? 12 : 8);

                // Multiple explosion rings
                for (let ring = 0; ring < 3; ring++) {
                    const ringGeometry = new THREE.SphereGeometry(baseSize * (1 + ring * 0.3), 8, 6);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: isBoss ? (ring === 0 ? 0x8e44ad : ring === 1 ? 0xe74c3c : 0xf39c12) :
                               (ring === 0 ? 0xff4444 : ring === 1 ? 0xff8844 : 0xffaa44),
                        transparent: true,
                        opacity: 0.9 - ring * 0.2
                    });
                    const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                    ringMesh.userData.ringIndex = ring;
                    deathGroup.add(ringMesh);
                }

                // Enhanced particle fragments with different types
                for (let i = 0; i < particleCount; i++) {
                    const fragmentType = Math.floor(Math.random() * 4);
                    let fragmentGeometry, fragmentMaterial;

                    switch (fragmentType) {
                        case 0: // Sphere fragments
                            fragmentGeometry = new THREE.SphereGeometry(0.04 + Math.random() * 0.06, 4, 3);
                            break;
                        case 1: // Cube fragments
                            fragmentGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.08);
                            break;
                        case 2: // Cone shards
                            fragmentGeometry = new THREE.ConeGeometry(0.04, 0.12, 4);
                            break;
                        case 3: // Tetrahedron
                            fragmentGeometry = new THREE.TetrahedronGeometry(0.06);
                            break;
                    }

                    fragmentMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(
                            Math.random() * 0.1 + (isBoss ? 0.7 : 0.0), // Purple for boss, red-orange for normal
                            0.8,
                            0.4 + Math.random() * 0.4
                        ),
                        transparent: true,
                        opacity: 1
                    });

                    const fragment = new THREE.Mesh(fragmentGeometry, fragmentMaterial);

                    // Enhanced random direction with more variation
                    const angle = (i / particleCount) * Math.PI * 2 + Math.random() * 0.5;
                    const elevation = Math.random() * Math.PI / 3 - Math.PI / 6;
                    const speed = 0.1 + Math.random() * 0.15;
                    const radius = 0.1 + Math.random() * 0.4;

                    fragment.position.set(
                        Math.cos(angle) * radius,
                        Math.random() * 0.4,
                        Math.sin(angle) * radius
                    );

                    fragment.userData.velocity = {
                        x: Math.cos(angle) * Math.cos(elevation) * speed,
                        y: Math.sin(elevation) * speed + Math.random() * 0.1,
                        z: Math.sin(angle) * Math.cos(elevation) * speed
                    };
                    fragment.userData.angularVelocity = {
                        x: (Math.random() - 0.5) * 0.3,
                        y: (Math.random() - 0.5) * 0.3,
                        z: (Math.random() - 0.5) * 0.3
                    };
                    fragment.userData.startTime = Math.random() * 0.3; // Stagger appearance
                    deathGroup.add(fragment);
                }

                // Add energy shockwave
                const shockwaveGeometry = new THREE.RingGeometry(0.1, baseSize * 2, 16);
                const shockwaveMaterial = new THREE.MeshBasicMaterial({
                    color: isBoss ? 0xffffff : 0xffff88,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
                shockwave.rotation.x = -Math.PI / 2;
                shockwave.position.y = 0.1;
                deathGroup.add(shockwave);

                // Add simple electrical sparks for boss
                if (isBoss) {
                    for (let i = 0; i < 4; i++) {
                        const sparkGeometry = new THREE.SphereGeometry(0.04, 4, 3);
                        const sparkMaterial = new THREE.MeshBasicMaterial({
                            color: 0x88ddff,
                            transparent: true,
                            opacity: 0.8
                        });
                        const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                        spark.position.set(
                            (Math.random() - 0.5) * 1.0,
                            Math.random() * 0.6,
                            (Math.random() - 0.5) * 1.0
                        );
                        spark.userData.sparkDelay = Math.random() * 0.3;
                        deathGroup.add(spark);
                    }
                }

                deathGroup.position.copy(position);
                this.scene.add(deathGroup);

                // Enhanced animation
                let time = 0;
                const animateDeath = () => {
                    time += 0.05;

                    // Animate explosion rings
                    deathGroup.children.forEach((child, index) => {
                        if (child.userData.ringIndex !== undefined) {
                            const ringDelay = child.userData.ringIndex * 0.15;
                            const ringTime = Math.max(0, time - ringDelay);
                            child.scale.setScalar(1 + ringTime * 4);
                            child.material.opacity = Math.max(0, (0.9 - child.userData.ringIndex * 0.2) - ringTime * 2);
                        }
                    });

                    // Animate shockwave
                    if (shockwave) {
                        shockwave.scale.setScalar(1 + time * 8);
                        shockwave.material.opacity = Math.max(0, 0.6 - time * 1.5);
                    }

                    // Enhanced fragment animation
                    deathGroup.children.forEach((child) => {
                        if (child.userData.velocity && time > child.userData.startTime) {
                            const effectiveTime = time - child.userData.startTime;

                            // Movement with physics
                            child.position.add(new THREE.Vector3(
                                child.userData.velocity.x,
                                child.userData.velocity.y,
                                child.userData.velocity.z
                            ));

                            // Apply gravity and air resistance
                            child.userData.velocity.y -= 0.008;
                            child.userData.velocity.x *= 0.995;
                            child.userData.velocity.z *= 0.995;

                            // Rotation
                            child.rotation.x += child.userData.angularVelocity.x;
                            child.rotation.y += child.userData.angularVelocity.y;
                            child.rotation.z += child.userData.angularVelocity.z;

                            // Fade and shrink
                            child.material.opacity = Math.max(0, 1 - effectiveTime * 1.2);
                            child.scale.setScalar(Math.max(0.1, 1 - effectiveTime * 0.8));
                        }

                        // Animate sparks
                        if (child.userData.sparkDelay !== undefined && time > child.userData.sparkDelay) {
                            child.material.opacity = Math.max(0, 0.8 - (time - child.userData.sparkDelay) * 3);
                            child.rotation.z += 0.2;
                        }
                    });

                    // Remove when done
                    if (time > 3.0) {
                        this.scene.remove(deathGroup);
                    } else {
                        requestAnimationFrame(animateDeath);
                    }
                };
                animateDeath();
            }

            createSlowEffect(enemy) {
                // Remove any existing slow effect
                if (enemy.slowIndicator) {
                    enemy.mesh.remove(enemy.slowIndicator);
                }

                // Create ice/frost visual effect
                const slowGroup = new THREE.Group();

                // Ice crystals around the enemy - reduced count
                for (let i = 0; i < 4; i++) {
                    const crystalGeometry = new THREE.ConeGeometry(0.05, 0.15, 4);
                    const crystalMaterial = new THREE.MeshBasicMaterial({
                        color: 0x88ccff,
                        transparent: true,
                        opacity: 0.7
                    });
                    const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);

                    const angle = (i / 4) * Math.PI * 2;
                    crystal.position.set(
                        Math.cos(angle) * 0.6,
                        0.2 + Math.random() * 0.4,
                        Math.sin(angle) * 0.6
                    );
                    crystal.rotation.y = angle;
                    crystal.userData.floatOffset = Math.random() * Math.PI * 2;
                    slowGroup.add(crystal);
                }

                // Frost aura ring
                const auraGeometry = new THREE.RingGeometry(0.4, 0.7, 16);
                const auraMaterial = new THREE.MeshBasicMaterial({
                    color: 0x66aaff,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                aura.rotation.x = -Math.PI / 2;
                aura.position.y = 0.05;
                slowGroup.add(aura);

                // Swirling snow particles - reduced count
                for (let i = 0; i < 6; i++) {
                    const snowGeometry = new THREE.SphereGeometry(0.02, 4, 3);
                    const snowMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.8
                    });
                    const snow = new THREE.Mesh(snowGeometry, snowMaterial);

                    const radius = 0.3 + Math.random() * 0.4;
                    const angle = Math.random() * Math.PI * 2;
                    snow.position.set(
                        Math.cos(angle) * radius,
                        0.1 + Math.random() * 0.6,
                        Math.sin(angle) * radius
                    );
                    snow.userData.orbitAngle = angle;
                    snow.userData.orbitRadius = radius;
                    snow.userData.orbitSpeed = 0.02 + Math.random() * 0.02;
                    slowGroup.add(snow);
                }

                enemy.mesh.add(slowGroup);
                enemy.slowIndicator = slowGroup;

                // Animate the slow effect
                let time = 0;
                const animateSlowEffect = () => {
                    if (!enemy.slowIndicator || enemy.slowEffect >= 0.9) {
                        // Remove effect when enemy is no longer slowed
                        if (enemy.slowIndicator) {
                            enemy.mesh.remove(enemy.slowIndicator);
                            enemy.slowIndicator = null;
                        }
                        return;
                    }

                    time += 0.05;

                    // Animate crystals
                    slowGroup.children.forEach((child, index) => {
                        if (child.userData.floatOffset !== undefined) {
                            // Ice crystals bob up and down
                            child.position.y = 0.2 + Math.sin(time * 3 + child.userData.floatOffset) * 0.1;
                            child.rotation.y += 0.01;
                        }

                        if (child.userData.orbitAngle !== undefined) {
                            // Snow particles orbit
                            child.userData.orbitAngle += child.userData.orbitSpeed;
                            child.position.x = Math.cos(child.userData.orbitAngle) * child.userData.orbitRadius;
                            child.position.z = Math.sin(child.userData.orbitAngle) * child.userData.orbitRadius;
                            child.position.y = 0.1 + Math.sin(time * 2 + child.userData.orbitAngle) * 0.2;
                        }
                    });

                    // Pulse the aura
                    if (aura) {
                        aura.material.opacity = 0.2 + Math.sin(time * 4) * 0.15;
                        aura.rotation.z += 0.005;
                    }

                    requestAnimationFrame(animateSlowEffect);
                };
                animateSlowEffect();
            }

            checkWaveCompletion() {
                if (this.isWaveActive && this.enemiesSpawned >= this.enemiesInWave && this.enemies.size === 0) {
                    // Wave completed
                    this.isWaveActive = false;
                    this.wave++;
                    this.gold += 20;
                    this.currentScore += (this.wave - 1) * 100;
                    this.startWaveBtn.disabled = false;
                    this.startWaveBtn.textContent = 'Start Wave';

                    this.showNotification(`🎉 Wave ${this.wave - 1} completed! +$20 bonus`);
                    this.nextWaveTimer = 30;
                    this.updateLeaderboardEntry();
                }
            }

            startNextWaveTimer() {
                setInterval(() => {
                    if (!this.isWaveActive && this.nextWaveTimer > 0) {
                        this.nextWaveTimer -= this.gameSpeed;
                        this.nextWaveTime.textContent = Math.ceil(this.nextWaveTimer) + 's';

                        if (this.nextWaveTimer <= 0) {
                            this.startWave();
                            this.nextWaveTimer = 30;
                        }
                    }
                }, 1000);
            }

            startGameLoop() {
                const gameLoop = () => {
                    this.moveEnemies();
                    this.towerShooting();
                    this.moveProjectiles();
                    this.checkWaveCompletion();
                    this.updateUI();
                    requestAnimationFrame(gameLoop);
                };
                gameLoop();
            }

            updateUI() {
                this.playerGoldDisplay.textContent = this.gold;
                this.playerLivesDisplay.textContent = this.lives;
                this.currentWaveDisplay.textContent = this.wave;
                this.playerScoreDisplay.textContent = this.currentScore.toLocaleString();
                this.enemiesLeft.textContent = this.enemies.size;

                // Update wave progress
                if (this.isWaveActive && this.enemiesInWave > 0) {
                    const progress = ((this.enemiesInWave - this.enemies.size) / this.enemiesInWave) * 100;
                    this.waveFill.style.width = Math.max(0, progress) + '%';
                } else {
                    this.waveFill.style.width = '0%';
                }

                // Update tower button states
                Object.keys(this.towerTypes).forEach(type => {
                    const btn = document.getElementById(type + 'TowerBtn');
                    const tower = this.towerTypes[type];
                    btn.disabled = this.gold < tower.cost;
                });
            }

            setCameraView(view) {
                this.isFreeCam = false;
                this.freeCamInstructions.style.display = 'none';

                switch (view) {
                    case 'top':
                        this.camera.position.set(0, 15, 0);
                        this.camera.lookAt(0, 0, 0);
                        break;
                    case 'angle':
                        this.camera.position.set(0, 10, 8);
                        this.camera.lookAt(0, 0, 0);
                        break;
                    case 'free':
                        this.isFreeCam = true;
                        this.cameraRotation = { x: 0, y: 0 };
                        this.freeCamInstructions.style.display = 'block';
                        break;
                }
            }

            handleKeyDown(e) {
                if (e.key === 'Escape') {
                    this.selectedTowerType = null;
                    this.hidePlacementGrid();
                    document.querySelectorAll('.tower-btn').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                } else if (e.key >= '1' && e.key <= '8') {
                    const types = ['basic', 'sniper', 'splash', 'slow', 'laser', 'poison', 'electric', 'booster'];
                    this.selectTowerType(types[parseInt(e.key) - 1]);
                }

                // Free camera controls
                if (this.isFreeCam) {
                    this.cameraKeys.add(e.key.toLowerCase());

                    // FOV/Perspective controls
                    if (e.key === '=' || e.key === '+') {
                        this.camera.fov = Math.max(10, this.camera.fov - 5);
                        this.camera.updateProjectionMatrix();
                    } else if (e.key === '-' || e.key === '_') {
                        this.camera.fov = Math.min(120, this.camera.fov + 5);
                        this.camera.updateProjectionMatrix();
                    }
                }
            }

            handleKeyUp(e) {
                if (this.isFreeCam) {
                    this.cameraKeys.delete(e.key.toLowerCase());
                }
            }

            handleMouseDown(e) {
                if (this.isFreeCam && e.button === 0) {
                    this.mouseDown = true;
                    this.lastMouse = { x: e.clientX, y: e.clientY };
                    this.canvas.requestPointerLock();
                }
            }

            handleMouseUp(e) {
                if (this.isFreeCam) {
                    this.mouseDown = false;
                }
            }

            handleMouseMove(e) {
                if (this.isFreeCam && document.pointerLockElement === this.canvas) {
                    const sensitivity = 0.002;
                    this.cameraRotation.y -= e.movementX * sensitivity;
                    this.cameraRotation.x -= e.movementY * sensitivity;

                    // Clamp vertical rotation
                    this.cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraRotation.x));

                    // Apply rotation to camera
                    this.camera.rotation.order = 'YXZ';
                    this.camera.rotation.y = this.cameraRotation.y;
                    this.camera.rotation.x = this.cameraRotation.x;
                }
            }

            handleWheel(e) {
                if (this.isFreeCam) {
                    e.preventDefault();
                    const direction = new THREE.Vector3(0, 0, -1);
                    direction.applyQuaternion(this.camera.quaternion);
                    direction.multiplyScalar(-e.deltaY * 0.01); // Inverted for natural zoom
                    this.camera.position.add(direction);
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                // Performance monitoring
                this.frameCount++;
                const now = Date.now();
                if (this.frameCount % 60 === 0) { // Check every 60 frames
                    const fps = 60000 / (now - this.lastFrameTime);
                    this.performanceMode = fps < 30; // Enable performance mode if FPS drops below 30
                    this.lastFrameTime = now;
                }

                // Update free camera
                if (this.isFreeCam) {
                    this.updateFreeCamera();
                }

                this.renderer.render(this.scene, this.camera);
            }

            updateFreeCamera() {
                const moveSpeed = 0.15;

                // Get camera direction vectors
                const forward = new THREE.Vector3(0, 0, -1);
                const right = new THREE.Vector3(1, 0, 0);
                const up = new THREE.Vector3(0, 1, 0);

                forward.applyQuaternion(this.camera.quaternion);
                right.applyQuaternion(this.camera.quaternion);

                const movement = new THREE.Vector3();

                // Forward/Backward movement (W/S and Arrow Up/Down)
                if (this.cameraKeys.has('w') || this.cameraKeys.has('arrowup')) {
                    movement.add(forward);
                }
                if (this.cameraKeys.has('s') || this.cameraKeys.has('arrowdown')) {
                    movement.add(forward.clone().negate());
                }

                // Left/Right movement (A/D and Arrow Left/Right)
                if (this.cameraKeys.has('a') || this.cameraKeys.has('arrowleft')) {
                    movement.add(right.clone().negate());
                }
                if (this.cameraKeys.has('d') || this.cameraKeys.has('arrowright')) {
                    movement.add(right);
                }

                // Up/Down movement (Space/Shift)
                if (this.cameraKeys.has(' ')) {
                    movement.add(up);
                }
                if (this.cameraKeys.has('shift')) {
                    movement.add(up.clone().negate());
                }

                // Apply movement
                if (movement.length() > 0) {
                    movement.normalize();
                    movement.multiplyScalar(moveSpeed);
                    this.camera.position.add(movement);
                }
            }

            setGameSpeed(speed) {
                this.gameSpeed = speed;

                // Update speed button states
                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(`speed${speed}x`).classList.add('active');
            }

            onWindowResize() {
                const width = window.innerWidth;
                const height = window.innerHeight - 80;

                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }

            // Leaderboard functions (simplified)
            async loadLeaderboard() {
                try {
                    const leaderboardRef = ref(database, 'leaderboard');
                    onValue(leaderboardRef, (snapshot) => {
                        if (snapshot.exists()) {
                            const data = snapshot.val();
                            this.leaderboard = Object.values(data).sort((a, b) => b.score - a.score);
                            this.updateLeaderboardDisplay();
                        }
                    });
                } catch (error) {
                    console.error('Failed to load leaderboard:', error);
                }
            }

            startLeaderboardSync() {
                setInterval(() => {
                    this.updateLeaderboardEntry();
                }, 10000);
            }

            async updateLeaderboardEntry() {
                try {
                    const leaderboardRef = ref(database, `leaderboard/${this.playerId}`);
                    await set(leaderboardRef, {
                        name: this.playerName,
                        score: this.currentScore,
                        wave: this.wave,
                        gold: this.gold,
                        lives: this.lives,
                        lastUpdated: serverTimestamp()
                    });
                } catch (error) {
                    console.error('Failed to update leaderboard:', error);
                }
            }

            updateLeaderboardDisplay() {
                this.leaderboardList.innerHTML = '';

                this.leaderboard.slice(0, 10).forEach((player, index) => {
                    const entry = document.createElement('div');
                    entry.className = 'leaderboard-entry';

                    if (player.name === this.playerName) {
                        entry.classList.add('current-player');
                    }

                    let rankIcon = '';
                    if (index === 0) rankIcon = '<span class="crown">👑</span>';
                    else if (index === 1) rankIcon = '<span class="medal">🥈</span>';
                    else if (index === 2) rankIcon = '<span class="bronze">🥉</span>';

                    entry.innerHTML = `
                        <div class="player-rank">${rankIcon}${index + 1}</div>
                        <div class="player-info">
                            <div>${player.name}</div>
                            <div class="player-stats">Wave ${player.wave} • $${player.gold}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-weight: bold; color: #00f5ff;">${player.score.toLocaleString()}</div>
                            <div style="font-size: 0.7rem; opacity: 0.7;">❤️${player.lives}</div>
                        </div>
                    `;

                    this.leaderboardList.appendChild(entry);
                });
            }

            async gameOver() {
                await this.updateLeaderboardEntry();

                const gameOverDiv = document.createElement('div');
                gameOverDiv.className = 'game-over';
                gameOverDiv.innerHTML = `
                    <h1>GAME OVER</h1>
                    <p>You reached wave ${this.wave}</p>
                    <p>Final Score: <span style="color: #00f5ff; font-weight: bold;">${this.currentScore.toLocaleString()}</span></p>
                    <p>Gold Earned: $${this.gold}</p>
                    <button class="btn btn-primary" onclick="location.reload()">Play Again</button>
                `;
                this.gameContainer.appendChild(gameOverDiv);
            }

            showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 2500);
            }

            showError(message) {
                this.nameError.textContent = message;
                this.nameError.style.display = 'block';
                setTimeout(() => {
                    this.nameError.style.display = 'none';
                }, 5000);
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            new TowerDefense3D();
        });
    </script>
</body>
</html>