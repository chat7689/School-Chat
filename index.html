<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale Plus Blooket</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 30%, #2d1b69 70%, #0f1419 100%);
            color: white;
            overflow: hidden;
            animation: backgroundGlow 20s ease-in-out infinite;
        }

        @keyframes backgroundGlow {
            0%, 100% {
                background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 30%, #2d1b69 70%, #0f1419 100%);
                box-shadow: inset 0 0 100px rgba(45, 27, 105, 0.3);
            }
            50% {
                background: linear-gradient(135deg, #1a1f2e 0%, #2d1b69 30%, #0f1419 70%, #1a1f2e 100%);
                box-shadow: inset 0 0 100px rgba(45, 27, 105, 0.5);
            }
        }

        .game-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .name-prompt {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #2d1b69 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .name-card {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
            padding: 3rem;
            border-radius: 20px;
            text-align: center;
            border: 2px solid rgba(0, 245, 255, 0.3);
            min-width: 400px;
        }

        .name-title {
            font-size: 2rem;
            font-weight: 800;
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 2rem;
        }

        .input-group {
            margin: 1rem 0;
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #00f5ff;
            font-weight: 600;
        }

        .input-group input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        .input-group input:focus {
            outline: none;
            border-color: #00f5ff;
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
        }

        .connection-status {
            margin: 1rem 0;
            padding: 0.5rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-connected {
            color: #4ade80;
            background: rgba(74, 222, 128, 0.1);
        }

        .status-disconnected {
            color: #f87171;
            background: rgba(248, 113, 113, 0.1);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00f5ff;
            animation: blink 2s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            position: relative;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stats {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem 1rem;
            border-radius: 25px;
            backdrop-filter: blur(5px);
        }

        .stat-value {
            font-weight: 700;
            color: #00f5ff;
        }

        #gameCanvas {
            display: block;
            background: radial-gradient(circle, #1a2332 0%, #0f1419 100%);
        }

        .game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .tower-menu {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            pointer-events: auto;
        }

        .tower-btn {
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            min-width: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            pointer-events: auto;
        }

        .tower-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .tower-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .tower-btn.basic {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
        }

        .tower-btn.sniper {
            background: linear-gradient(135deg, #5cb85c, #449d44);
            color: white;
        }

        .tower-btn.splash {
            background: linear-gradient(135deg, #f0ad4e, #ec971f);
            color: white;
        }

        .tower-btn.slow {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
        }

        .tower-btn.laser {
            background: linear-gradient(135deg, #ff0066, #cc0044);
            color: white;
        }

        .tower-btn.poison {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }

        .tower-btn.electric {
            background: linear-gradient(135deg, #ffff00, #e6e600);
            color: black;
        }

        .tower-btn.booster {
            background: linear-gradient(135deg, #00ffff, #00cccc);
            color: black;
        }

        .tower-btn.selected {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
        }

        .tower-cost {
            font-size: 0.7rem;
            opacity: 0.9;
        }

        .wave-info {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            min-width: 200px;
            pointer-events: auto;
        }

        .wave-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin: 0.5rem 0;
            overflow: hidden;
        }

        .wave-fill {
            height: 100%;
            background: linear-gradient(90deg, #00f5ff, #0066ff);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .leaderboard {
            position: fixed;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            min-width: 250px;
            max-height: 400px;
            overflow-y: auto;
            pointer-events: auto;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            margin: 0.25rem 0;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .leaderboard-entry:hover {
            background: rgba(0, 245, 255, 0.1);
            transform: translateX(5px);
        }

        .leaderboard-entry.current-player {
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
        }

        .player-rank {
            font-weight: bold;
            color: #00f5ff;
            min-width: 30px;
        }

        .player-info {
            flex: 1;
            margin: 0 0.5rem;
        }

        .player-stats {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .crown {
            color: #ffd700;
            margin-right: 0.25rem;
        }

        .medal {
            color: #c0c0c0;
            margin-right: 0.25rem;
        }

        .bronze {
            color: #cd7f32;
            margin-right: 0.25rem;
        }

        .camera-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 0.5rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            pointer-events: auto;
        }

        .speed-controls {
            position: fixed;
            top: 100px;
            right: 250px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            pointer-events: auto;
        }

        .speed-btn {
            padding: 0.5rem 0.75rem;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0.25rem;
            display: inline-block;
            min-width: 45px;
            font-size: 0.8rem;
        }

        .speed-btn:hover {
            background: rgba(0, 245, 255, 0.2);
        }

        .speed-btn.active {
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
        }

        .tower-info {
            position: fixed;
            top: 280px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00f5ff;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-width: 200px;
            max-width: 250px;
            z-index: 1000;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.4rem;
            font-size: 0.85rem;
        }

        .stat-label {
            color: #00f5ff;
            font-weight: bold;
        }

        .tower-actions {
            margin-top: 15px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .action-btn {
            padding: 8px 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: bold;
            transition: all 0.2s;
            text-align: center;
        }

        .action-btn.upgrade {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
        }

        .action-btn.downgrade {
            background: linear-gradient(135deg, #e67e22, #f39c12);
            color: white;
        }

        .action-btn.sell {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .action-btn.move {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .action-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 245, 255, 0.3);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .free-cam-instructions {
            position: fixed;
            bottom: 150px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 0.75rem;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            font-size: 0.7rem;
            opacity: 0.8;
            max-width: 200px;
            display: none;
        }

        .camera-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0.25rem;
            display: block;
            width: 100%;
        }

        .camera-btn:hover {
            background: rgba(0, 245, 255, 0.2);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            pointer-events: auto;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .notification {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.85), rgba(0, 30, 60, 0.8));
            backdrop-filter: blur(15px);
            padding: 1rem 2rem;
            border-radius: 20px;
            text-align: center;
            z-index: 1001;
            animation: notification-appear 0.3s ease-out;
            border: 1px solid rgba(0, 245, 255, 0.4);
            box-shadow: 0 8px 32px rgba(0, 245, 255, 0.15);
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        @keyframes notification-appear {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .game-over h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: #e74c3c;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00f5ff;
            font-size: 1.2rem;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <!-- Name Prompt Screen -->
    <div class="name-prompt" id="namePrompt">
        <div class="name-card">
            <h1 class="name-title">CLASH ROYALE PLUS BLOOKET</h1>
            <p style="margin-bottom: 2rem; opacity: 0.8;">Multiplayer Strategy Defense</p>

            <div class="connection-status" id="connectionStatus">
                <div class="status-dot"></div>
                <span>Connecting...</span>
            </div>

            <div class="input-group">
                <label for="playerName">Player Name</label>
                <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
            </div>

            <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                <button class="btn btn-primary" id="joinGameBtn" disabled>Join Game</button>
            </div>

            <div id="nameError" style="color: #f87171; margin-top: 1rem; display: none;"></div>
        </div>
    </div>

    <!-- Game Screen -->
    <div class="game-container" id="gameContainer" style="display: none;">
        <div class="header">
            <div class="logo">CLASH ROYALE PLUS BLOOKET</div>
            <div class="stats">
                <div class="stat-item">
                    <span>üí∞</span>
                    <span class="stat-value" id="playerGold">100</span>
                </div>
                <div class="stat-item">
                    <span>‚ù§Ô∏è</span>
                    <span class="stat-value" id="playerLives">20</span>
                </div>
                <div class="stat-item">
                    <span>Wave:</span>
                    <span class="stat-value" id="currentWave">1</span>
                </div>
                <div class="stat-item">
                    <span>Score:</span>
                    <span class="stat-value" id="playerScore">0</span>
                </div>
                <div class="connection-status">
                    <div class="status-dot"></div>
                    <span>Online</span>
                </div>
            </div>
        </div>

        <div style="position: relative; flex: 1;">
            <canvas id="gameCanvas"></canvas>
            <div class="loading" id="loadingText">Loading 3D assets...</div>

            <div class="game-ui">
                <div class="tower-menu">
                    <button class="tower-btn basic" id="basicTowerBtn">
                        <span>üî´ Basic</span>
                        <span class="tower-cost">$10</span>
                    </button>
                    <button class="tower-btn sniper" id="sniperTowerBtn">
                        <span>üéØ Sniper</span>
                        <span class="tower-cost">$25</span>
                    </button>
                    <button class="tower-btn splash" id="splashTowerBtn">
                        <span>üí• Splash</span>
                        <span class="tower-cost">$40</span>
                    </button>
                    <button class="tower-btn slow" id="slowTowerBtn">
                        <span>‚ùÑÔ∏è Slow</span>
                        <span class="tower-cost">$30</span>
                    </button>
                    <button class="tower-btn laser" id="laserTowerBtn">
                        <span>üî¥ Laser</span>
                        <span class="tower-cost">$50</span>
                    </button>
                    <button class="tower-btn poison" id="poisonTowerBtn">
                        <span>‚ò¢Ô∏è Poison</span>
                        <span class="tower-cost">$35</span>
                    </button>
                    <button class="tower-btn electric" id="electricTowerBtn">
                        <span>‚ö° Electric</span>
                        <span class="tower-cost">$60</span>
                    </button>
                    <button class="tower-btn booster" id="boosterTowerBtn">
                        <span>üöÄ Booster</span>
                        <span class="tower-cost">$45</span>
                    </button>
                </div>

                <div class="wave-info">
                    <h3 style="margin-bottom: 0.5rem; color: #00f5ff;">Wave Progress</h3>
                    <div class="wave-progress">
                        <div class="wave-fill" id="waveFill" style="width: 0%;"></div>
                    </div>
                    <div style="font-size: 0.9rem; margin-top: 0.5rem;">
                        <div>Enemies: <span id="enemiesLeft">0</span></div>
                        <div>Next Wave: <span id="nextWaveTime">30s</span></div>
                    </div>
                    <button class="btn btn-primary" id="startWaveBtn" style="margin-top: 1rem; width: 100%;">Start Wave</button>
                </div>

                <div class="leaderboard">
                    <h3 style="margin-bottom: 0.5rem; color: #00f5ff;">üèÜ Leaderboard</h3>
                    <div id="leaderboardList">
                        <!-- Leaderboard entries will be populated here -->
                    </div>
                </div>

                <div class="speed-controls">
                    <h4 style="margin-bottom: 0.5rem; color: #00f5ff; font-size: 0.9rem;">‚ö° Game Speed</h4>
                    <div>
                        <button class="speed-btn active" id="speed1x">1x</button>
                        <button class="speed-btn" id="speed2x">2x</button>
                        <button class="speed-btn" id="speed3x">3x</button>
                        <button class="speed-btn" id="speed5x">5x</button>
                        <button class="speed-btn" id="speed10x">10x</button>
                    </div>
                </div>

                <div class="tower-info" id="towerInfoPanel" style="display: none;">
                    <h4 style="margin-bottom: 0.5rem; color: #00f5ff; font-size: 0.9rem;">üèóÔ∏è Tower Info</h4>
                    <div id="towerStats">
                        <div class="stat-row">
                            <span class="stat-label">Type:</span>
                            <span id="towerTypeStat">-</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Level:</span>
                            <span id="towerLevelStat">1</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Damage:</span>
                            <span id="towerDamageStat">-</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Range:</span>
                            <span id="towerRangeStat">-</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Fire Rate:</span>
                            <span id="towerFireRateStat">-</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Total Damage:</span>
                            <span id="towerTotalDamageStat">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Kills:</span>
                            <span id="towerKillsStat">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Shots Fired:</span>
                            <span id="towerShotsFiredStat">0</span>
                        </div>
                    </div>
                    <div class="tower-actions">
                        <button class="action-btn upgrade" id="upgradeTowerBtn">‚¨ÜÔ∏è Upgrade</button>
                        <button class="action-btn downgrade" id="downgradeTowerBtn">‚¨áÔ∏è Downgrade</button>
                        <button class="action-btn sell" id="sellTowerBtn">üí∞ Sell</button>
                        <button class="action-btn move" id="moveTowerBtn">üìç Move</button>
                    </div>
                </div>

                <div class="camera-controls">
                    <button class="camera-btn" id="topViewBtn">Top View</button>
                    <button class="camera-btn" id="angleViewBtn">Angle View</button>
                    <button class="camera-btn" id="freeViewBtn">Free Camera</button>
                </div>

                <div class="free-cam-instructions" id="freeCamInstructions">
                    <div style="color: #00f5ff; font-weight: bold; margin-bottom: 0.25rem;">Free Camera:</div>
                    <div>WASD/Arrows: Move</div>
                    <div>Mouse: Look around</div>
                    <div>Space/Shift: Up/Down</div>
                    <div>Scroll: Zoom</div>
                    <div>+/-: Change FOV</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Firebase SDKs -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, onValue, push, remove, onDisconnect, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBLkFMipRS631fDNr8uwgozmxXBnqLd5_o",
            authDomain: "base-control-b391e.firebaseapp.com",
            databaseURL: "https://base-control-b391e-default-rtdb.firebaseio.com/",
            projectId: "base-control-b391e",
            storageBucket: "base-control-b391e.firebasestorage.app",
            messagingSenderId: "116375376675",
            appId: "1:116375376675:web:cdc8688222c7c35accf296",
            measurementId: "G-JY7P6D49HM"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        class TowerDefense3D {
            constructor() {
                this.playerId = this.generatePlayerId();
                this.playerName = '';
                this.roomCode = 'tower-defense-3d';
                this.gameState = null;
                this.isConnected = false;

                // Game state
                this.gold = 100;
                this.lives = 20;
                this.wave = 1;
                this.currentScore = 0;
                this.selectedTowerType = null;
                this.isWaveActive = false;
                this.enemiesInWave = 0;
                this.enemiesSpawned = 0;
                this.nextWaveTimer = 30;
                this.leaderboard = [];

                // Fun mechanics
                this.killCombo = 0;
                this.comboTimer = 0;
                this.powerUps = new Map();
                this.nextPowerUpId = 1;

                // 3D Objects
                this.towers = new Map();
                this.enemies = new Map();
                this.projectiles = new Map();
                this.environmentObjects = [];
                this.previewTower = null;
                this.previewRange = null;
                this.selectedTower = null;

                // Performance optimization
                this.performanceMode = false;
                this.frameCount = 0;
                this.lastFrameTime = Date.now();

                // Achievement system
                this.achievements = {
                    firstTower: { unlocked: false, name: "Builder", description: "Place your first tower" },
                    tenKills: { unlocked: false, name: "Exterminator", description: "Kill 10 enemies" },
                    hundredKills: { unlocked: false, name: "Slayer", description: "Kill 100 enemies" },
                    firstUpgrade: { unlocked: false, name: "Improver", description: "Upgrade a tower" },
                    maxLevel: { unlocked: false, name: "Maxed Out", description: "Get a tower to max level" },
                    wave10: { unlocked: false, name: "Veteran", description: "Survive 10 waves" },
                    wave25: { unlocked: false, name: "Expert", description: "Survive 25 waves" },
                    millionaire: { unlocked: false, name: "Rich", description: "Have 1000+ gold" },
                    noLives: { unlocked: false, name: "Close Call", description: "Win with 1 life remaining" },
                    boosterMaster: { unlocked: false, name: "Support", description: "Place a booster tower" }
                };
                this.totalKills = 0;

                // Load saved achievements
                this.loadAchievements();

                // Sound system (basic structure)
                this.soundEnabled = localStorage.getItem('soundEnabled') === 'true';
                this.sounds = {
                    shoot: null,
                    explosion: null,
                    enemyKill: null,
                    waveStart: null,
                    achievement: null
                };

                // Tower types
                this.towerTypes = {
                    basic: { cost: 12, damage: 18, range: 3.2, fireRate: 1000, color: 0x4a90e2, name: "Cannon" },
                    sniper: { cost: 28, damage: 65, range: 7, fireRate: 2500, color: 0x5cb85c, name: "Sniper", critical: 0.3 },
                    splash: { cost: 42, damage: 35, range: 2.8, fireRate: 1800, color: 0xf0ad4e, splash: 1.8, name: "Mortar" },
                    slow: { cost: 32, damage: 15, range: 3.5, fireRate: 900, color: 0x9b59b6, slow: 0.4, name: "Frost" },
                    laser: { cost: 55, damage: 12, range: 4.5, fireRate: 250, color: 0xff0066, continuous: true, name: "Laser" },
                    poison: { cost: 38, damage: 18, range: 3, fireRate: 1400, color: 0x27ae60, poison: { damage: 5, duration: 6000 }, name: "Toxic" },
                    electric: { cost: 65, damage: 35, range: 3.8, fireRate: 2000, color: 0xffff00, chain: 4, name: "Tesla" },
                    booster: { cost: 50, damage: 0, range: 4.5, fireRate: 0, color: 0x00ffff, boost: { damage: 1.6, range: 1.3, fireRate: 0.75 }, name: "Amplifier" }
                };

                // Enemy types - Enhanced with special abilities
                this.enemyTypes = {
                    basic: { health: 50, speed: 0.005, reward: 5, color: 0xe74c3c, name: "Scout" },
                    fast: { health: 30, speed: 0.008, reward: 8, color: 0xf39c12, name: "Runner", dodge: 0.15 },
                    tank: { health: 150, speed: 0.003, reward: 15, color: 0x34495e, name: "Tank", armor: 0.2 },
                    boss: { health: 300, speed: 0.004, reward: 50, color: 0x8e44ad, name: "Boss", shield: true, regen: 2 },
                    stealth: { health: 40, speed: 0.006, reward: 12, color: 0x2c3e50, name: "Ghost", stealth: 0.3 },
                    swarm: { health: 20, speed: 0.007, reward: 3, color: 0xe67e22, name: "Swarmling", swarm: true }
                };

                // Game speed and camera controls
                this.gameSpeed = 1;
                this.isFreeCam = false;
                this.cameraKeys = new Set();
                this.cameraVelocity = { x: 0, y: 0, z: 0 };
                this.mouseDown = false;
                this.lastMouse = { x: 0, y: 0 };
                this.cameraRotation = { x: 0, y: 0 };

                // Grid system
                this.gridSize = 1;
                this.placementGrid = [];
                this.gridTiles = [];
                this.hoveredTile = null;

                // Path waypoints (3D coordinates)
                this.pathPoints = [
                    { x: -8, z: 0, y: 0 },
                    { x: -6, z: 2, y: 0 },
                    { x: -4, z: 3, y: 0 },
                    { x: -2, z: 2, y: 0 },
                    { x: 0, z: 0, y: 0 },
                    { x: 2, z: -2, y: 0 },
                    { x: 4, z: -3, y: 0 },
                    { x: 6, z: -2, y: 0 },
                    { x: 8, z: 0, y: 0 }
                ];

                this.init();
            }

            generatePlayerId() {
                return 'player_' + Math.random().toString(36).substr(2, 9);
            }

            init() {
                this.initializeElements();
                this.bindEvents();
                this.checkConnection();
                this.setupThreeJS();
            }

            initializeElements() {
                this.namePrompt = document.getElementById('namePrompt');
                this.gameContainer = document.getElementById('gameContainer');
                this.connectionStatus = document.getElementById('connectionStatus');
                this.playerNameInput = document.getElementById('playerName');
                this.joinGameBtn = document.getElementById('joinGameBtn');
                this.playerGoldDisplay = document.getElementById('playerGold');
                this.playerLivesDisplay = document.getElementById('playerLives');
                this.currentWaveDisplay = document.getElementById('currentWave');
                this.playerScoreDisplay = document.getElementById('playerScore');
                this.waveFill = document.getElementById('waveFill');
                this.enemiesLeft = document.getElementById('enemiesLeft');
                this.nextWaveTime = document.getElementById('nextWaveTime');
                this.startWaveBtn = document.getElementById('startWaveBtn');
                this.nameError = document.getElementById('nameError');
                this.leaderboardList = document.getElementById('leaderboardList');
                this.loadingText = document.getElementById('loadingText');

                this.basicTowerBtn = document.getElementById('basicTowerBtn');
                this.sniperTowerBtn = document.getElementById('sniperTowerBtn');
                this.splashTowerBtn = document.getElementById('splashTowerBtn');
                this.slowTowerBtn = document.getElementById('slowTowerBtn');
                this.laserTowerBtn = document.getElementById('laserTowerBtn');
                this.poisonTowerBtn = document.getElementById('poisonTowerBtn');
                this.electricTowerBtn = document.getElementById('electricTowerBtn');
                this.boosterTowerBtn = document.getElementById('boosterTowerBtn');

                this.topViewBtn = document.getElementById('topViewBtn');
                this.angleViewBtn = document.getElementById('angleViewBtn');
                this.freeViewBtn = document.getElementById('freeViewBtn');
                this.freeCamInstructions = document.getElementById('freeCamInstructions');

                // Speed control buttons
                this.speed1xBtn = document.getElementById('speed1x');
                this.speed2xBtn = document.getElementById('speed2x');
                this.speed3xBtn = document.getElementById('speed3x');
                this.speed5xBtn = document.getElementById('speed5x');
                this.speed10xBtn = document.getElementById('speed10x');

                // Tower info panel elements
                this.towerInfoPanel = document.getElementById('towerInfoPanel');
                this.towerTypeStat = document.getElementById('towerTypeStat');
                this.towerLevelStat = document.getElementById('towerLevelStat');
                this.towerDamageStat = document.getElementById('towerDamageStat');
                this.towerRangeStat = document.getElementById('towerRangeStat');
                this.towerFireRateStat = document.getElementById('towerFireRateStat');
                this.towerTotalDamageStat = document.getElementById('towerTotalDamageStat');
                this.towerKillsStat = document.getElementById('towerKillsStat');

                // Tower action buttons
                this.upgradeTowerBtn = document.getElementById('upgradeTowerBtn');
                this.downgradeTowerBtn = document.getElementById('downgradeTowerBtn');
                this.sellTowerBtn = document.getElementById('sellTowerBtn');
                this.moveTowerBtn = document.getElementById('moveTowerBtn');
            }

            bindEvents() {
                this.joinGameBtn.addEventListener('click', () => this.joinGame());
                this.playerNameInput.addEventListener('input', () => this.validateForm());
                this.playerNameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !this.joinGameBtn.disabled) {
                        this.joinGame();
                    }
                });

                this.basicTowerBtn.addEventListener('click', () => this.selectTowerType('basic'));
                this.sniperTowerBtn.addEventListener('click', () => this.selectTowerType('sniper'));
                this.splashTowerBtn.addEventListener('click', () => this.selectTowerType('splash'));
                this.slowTowerBtn.addEventListener('click', () => this.selectTowerType('slow'));
                this.laserTowerBtn.addEventListener('click', () => this.selectTowerType('laser'));
                this.poisonTowerBtn.addEventListener('click', () => this.selectTowerType('poison'));
                this.electricTowerBtn.addEventListener('click', () => this.selectTowerType('electric'));
                this.boosterTowerBtn.addEventListener('click', () => this.selectTowerType('booster'));

                this.startWaveBtn.addEventListener('click', () => this.startWave());

                this.topViewBtn.addEventListener('click', () => this.setCameraView('top'));
                this.angleViewBtn.addEventListener('click', () => this.setCameraView('angle'));
                this.freeViewBtn.addEventListener('click', () => this.setCameraView('free'));

                // Speed controls
                this.speed1xBtn.addEventListener('click', () => this.setGameSpeed(1));
                this.speed2xBtn.addEventListener('click', () => this.setGameSpeed(2));
                this.speed3xBtn.addEventListener('click', () => this.setGameSpeed(3));
                this.speed5xBtn.addEventListener('click', () => this.setGameSpeed(5));
                this.speed10xBtn.addEventListener('click', () => this.setGameSpeed(10));

                // Tower action button events
                this.upgradeTowerBtn.addEventListener('click', () => this.upgradeTower());
                this.downgradeTowerBtn.addEventListener('click', () => this.downgradeTower());
                this.sellTowerBtn.addEventListener('click', () => this.sellTower());
                this.moveTowerBtn.addEventListener('click', () => this.moveTower());

                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));
            }

            async checkConnection() {
                try {
                    const connectedRef = ref(database, '.info/connected');
                    onValue(connectedRef, (snapshot) => {
                        this.isConnected = snapshot.val() === true;
                        this.updateConnectionStatus();
                        this.validateForm();
                    });
                } catch (error) {
                    console.error('Connection failed:', error);
                    this.updateConnectionStatus(false);
                }
            }

            updateConnectionStatus(connected = this.isConnected) {
                const statusElement = this.connectionStatus;
                if (connected) {
                    statusElement.className = 'connection-status status-connected';
                    statusElement.innerHTML = '<div class="status-dot"></div><span>Connected</span>';
                } else {
                    statusElement.className = 'connection-status status-disconnected';
                    statusElement.innerHTML = '<div class="status-dot"></div><span>Connection failed</span>';
                }
            }

            validateForm() {
                const nameValid = this.playerNameInput.value.trim().length > 0;
                const connected = this.isConnected;
                this.joinGameBtn.disabled = !nameValid || !connected;
            }

            setupThreeJS() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0f1419);

                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight - 80), 0.1, 1000);
                this.camera.position.set(0, 10, 8);
                this.camera.lookAt(0, 0, 0);

                // Renderer
                this.canvas = document.getElementById('gameCanvas');
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight - 80);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Lighting
                this.setupLighting();

                // Battlefield
                this.createBattlefield();

                // Raycaster for mouse interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));
                this.canvas.addEventListener('contextmenu', (e) => this.handleCanvasRightClick(e));
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));

                // Start render loop
                this.animate();

                this.loadingText.style.display = 'none';
            }

            setupLighting() {
                // Enhanced ambient light with color variation
                const ambientLight = new THREE.AmbientLight(0x404060, 0.3);
                this.scene.add(ambientLight);

                // Main directional light (sun)
                this.directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                this.directionalLight.position.set(15, 25, 10);
                this.directionalLight.castShadow = true;
                this.directionalLight.shadow.mapSize.width = 4096;
                this.directionalLight.shadow.mapSize.height = 4096;
                this.directionalLight.shadow.camera.near = 0.5;
                this.directionalLight.shadow.camera.far = 100;
                this.directionalLight.shadow.camera.left = -25;
                this.directionalLight.shadow.camera.right = 25;
                this.directionalLight.shadow.camera.top = 25;
                this.directionalLight.shadow.camera.bottom = -25;
                this.directionalLight.shadow.bias = -0.0001;
                this.scene.add(this.directionalLight);

                // Secondary fill light
                const fillLight = new THREE.DirectionalLight(0x8899ff, 0.3);
                fillLight.position.set(-10, 15, -5);
                this.scene.add(fillLight);

                // Dynamic atmospheric lighting
                const atmosphereLight = new THREE.PointLight(0x00aaff, 0.6, 50);
                atmosphereLight.position.set(0, 12, 0);
                this.scene.add(atmosphereLight);

                // Animate atmospheric light - optimized with frame skipping
                let atmosphereFrameCount = 0;
                const animateAtmosphere = () => {
                    atmosphereFrameCount++;
                    if (atmosphereFrameCount % 3 === 0) { // Update every 3rd frame
                        const time = Date.now() * 0.001;
                        atmosphereLight.intensity = 0.4 + Math.sin(time * 0.5) * 0.2;
                        atmosphereLight.color.setHSL(0.55 + Math.sin(time * 0.3) * 0.1, 0.8, 0.6);
                    }
                    requestAnimationFrame(animateAtmosphere);
                };
                animateAtmosphere();

                // Add rim lighting for dramatic effect
                const rimLight1 = new THREE.DirectionalLight(0xff6600, 0.2);
                rimLight1.position.set(-20, 10, 20);
                this.scene.add(rimLight1);

                const rimLight2 = new THREE.DirectionalLight(0x0066ff, 0.2);
                rimLight2.position.set(20, 10, -20);
                this.scene.add(rimLight2);
            }

            createBattlefield() {
                // Enhanced terrain with multiple layers
                this.createTerrain();

                // Placement grid disabled - no green rectangles

                // Enhanced path with more detail
                this.createPath();

                // Add environmental elements
                this.createEnvironment();
            }

            createTerrain() {
                // Main ground plane with texture-like appearance
                const groundGeometry = new THREE.PlaneGeometry(24, 16);
                const groundMaterial = new THREE.MeshLambertMaterial({
                    color: 0x2a4d3a,
                    transparent: false
                });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);

                // Add grass patches
                for (let i = 0; i < 50; i++) {
                    const grassGeometry = new THREE.PlaneGeometry(0.5 + Math.random() * 0.5, 0.5 + Math.random() * 0.5);
                    const grassMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color().setHSL(0.25 + Math.random() * 0.1, 0.6, 0.3 + Math.random() * 0.2),
                        transparent: true,
                        opacity: 0.7
                    });
                    const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                    grass.position.set(
                        (Math.random() - 0.5) * 22,
                        0.01,
                        (Math.random() - 0.5) * 14
                    );
                    grass.rotation.x = -Math.PI / 2;
                    grass.rotation.z = Math.random() * Math.PI * 2;
                    this.scene.add(grass);
                }

                // Subtle grid helper
                const gridHelper = new THREE.GridHelper(20, 20, 0x004400, 0x002200);
                gridHelper.material.opacity = 0.2;
                gridHelper.material.transparent = true;
                this.scene.add(gridHelper);
            }

            createEnvironment() {
                // Add trees around the battlefield
                for (let i = 0; i < 15; i++) {
                    this.createTree(
                        (Math.random() - 0.5) * 30,
                        (Math.random() - 0.5) * 20
                    );
                }

                // Add rocks and details
                for (let i = 0; i < 20; i++) {
                    this.createRock(
                        (Math.random() - 0.5) * 25,
                        (Math.random() - 0.5) * 18
                    );
                }

                // Add energy crystals for ambiance
                for (let i = 0; i < 8; i++) {
                    this.createEnergyCrystal(
                        (Math.random() - 0.5) * 28,
                        (Math.random() - 0.5) * 20
                    );
                }
            }

            createTree(x, z) {
                const treeGroup = new THREE.Group();

                // Tree trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.15, 1.2, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3c28 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 0.6;
                trunk.castShadow = true;
                treeGroup.add(trunk);

                // Tree foliage (multiple spheres)
                for (let i = 0; i < 3; i++) {
                    const foliageGeometry = new THREE.SphereGeometry(0.4 + i * 0.1, 8, 6);
                    const foliageMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color().setHSL(0.25, 0.6, 0.2 + Math.random() * 0.2)
                    });
                    const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                    foliage.position.set(
                        (Math.random() - 0.5) * 0.3,
                        1.0 + i * 0.2,
                        (Math.random() - 0.5) * 0.3
                    );
                    foliage.castShadow = true;
                    treeGroup.add(foliage);
                }

                treeGroup.position.set(x, 0, z);
                // Don't add trees too close to the path
                const distanceToPath = Math.min(...this.pathPoints.map(point =>
                    Math.sqrt((x - point.x) ** 2 + (z - point.z) ** 2)
                ));
                if (distanceToPath > 2) {
                    this.scene.add(treeGroup);
                    this.environmentObjects.push({ x: x, z: z, type: 'tree', radius: 0.8 });
                }
            }

            createRock(x, z) {
                const rockGeometry = new THREE.DodecahedronGeometry(0.2 + Math.random() * 0.3);
                const rockMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(0, 0, 0.3 + Math.random() * 0.2)
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(x, 0.1, z);
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                rock.castShadow = true;
                this.scene.add(rock);
                this.environmentObjects.push({ x: x, z: z, type: 'rock', radius: 0.5 });
            }

            createEnergyCrystal(x, z) {
                const crystalGeometry = new THREE.OctahedronGeometry(0.15);
                const crystalMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    emissive: 0x002222,
                    transparent: true,
                    opacity: 0.8
                });
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                crystal.position.set(x, 0.3, z);

                // Add a subtle point light
                const light = new THREE.PointLight(0x00ffff, 0.3, 3);
                light.position.copy(crystal.position);
                light.position.y += 0.2;

                this.scene.add(crystal);
                this.scene.add(light);

                // Animate crystal
                const animateCrystal = () => {
                    const time = Date.now() * 0.001;
                    crystal.rotation.y = time;
                    crystal.position.y = 0.3 + Math.sin(time * 2) * 0.05;
                    requestAnimationFrame(animateCrystal);
                };
                animateCrystal();
            }

            createPath() {
                // Create a detailed, multi-layered path
                const pathWidth = 1.0;

                for (let i = 0; i < this.pathPoints.length - 1; i++) {
                    const current = this.pathPoints[i];
                    const next = this.pathPoints[i + 1];

                    // Calculate direction and distance
                    const direction = new THREE.Vector3(next.x - current.x, 0, next.z - current.z);
                    const distance = direction.length();
                    direction.normalize();

                    // Main path base (stone)
                    const baseGeometry = new THREE.PlaneGeometry(pathWidth + 0.4, distance);
                    const baseMaterial = new THREE.MeshLambertMaterial({
                        color: 0x444444,
                        transparent: true,
                        opacity: 0.8
                    });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.set(
                        (current.x + next.x) / 2,
                        0.01,
                        (current.z + next.z) / 2
                    );
                    base.rotation.x = -Math.PI / 2;
                    base.rotation.z = Math.atan2(direction.x, direction.z);
                    this.scene.add(base);

                    // Main path surface (dirt road)
                    const segmentGeometry = new THREE.PlaneGeometry(pathWidth, distance);
                    const segmentMaterial = new THREE.MeshLambertMaterial({
                        color: 0x8b6914,
                        transparent: true,
                        opacity: 0.95
                    });
                    const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                    segment.position.set(
                        (current.x + next.x) / 2,
                        0.03,
                        (current.z + next.z) / 2
                    );
                    segment.rotation.x = -Math.PI / 2;
                    segment.rotation.z = Math.atan2(direction.x, direction.z);
                    this.scene.add(segment);

                    // Path center line (worn track)
                    const centerGeometry = new THREE.PlaneGeometry(pathWidth * 0.3, distance);
                    const centerMaterial = new THREE.MeshLambertMaterial({
                        color: 0x5d4e37,
                        transparent: true,
                        opacity: 0.7
                    });
                    const center = new THREE.Mesh(centerGeometry, centerMaterial);
                    center.position.set(
                        (current.x + next.x) / 2,
                        0.04,
                        (current.z + next.z) / 2
                    );
                    center.rotation.x = -Math.PI / 2;
                    center.rotation.z = Math.atan2(direction.x, direction.z);
                    this.scene.add(center);

                    // Add path decorations (small stones)
                    for (let j = 0; j < 3; j++) {
                        const stoneGeometry = new THREE.DodecahedronGeometry(0.05 + Math.random() * 0.03);
                        const stoneMaterial = new THREE.MeshLambertMaterial({
                            color: new THREE.Color().setHSL(0, 0, 0.2 + Math.random() * 0.3)
                        });
                        const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
                        stone.position.set(
                            (current.x + next.x) / 2 + (Math.random() - 0.5) * pathWidth * 0.8,
                            0.08,
                            (current.z + next.z) / 2 + (Math.random() - 0.5) * distance * 0.8
                        );
                        stone.rotation.set(
                            Math.random() * Math.PI,
                            Math.random() * Math.PI,
                            Math.random() * Math.PI
                        );
                        stone.castShadow = true;
                        this.scene.add(stone);
                    }
                }

                // Enhanced path markers
                this.pathPoints.forEach((point, index) => {
                    if (index === 0) {
                        // Start portal
                        this.createPortal(point, 0xff2222, "spawn");
                    } else if (index === this.pathPoints.length - 1) {
                        // End portal
                        this.createPortal(point, 0x22ff22, "end");
                    } else {
                        // Waypoint crystals
                        const crystalGeometry = new THREE.OctahedronGeometry(0.1);
                        const crystalMaterial = new THREE.MeshBasicMaterial({
                            color: 0xffaa00,
                            emissive: 0x442200,
                            transparent: true,
                            opacity: 0.8
                        });
                        const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                        crystal.position.set(point.x, point.y + 0.2, point.z);
                        this.scene.add(crystal);

                        // Animate waypoint
                        const animateWaypoint = () => {
                            const time = Date.now() * 0.002;
                            crystal.rotation.y = time;
                            crystal.position.y = point.y + 0.2 + Math.sin(time * 3) * 0.05;
                            requestAnimationFrame(animateWaypoint);
                        };
                        animateWaypoint();
                    }
                });
            }

            createPortal(point, color, type) {
                const portalGroup = new THREE.Group();

                // Portal ring
                const ringGeometry = new THREE.TorusGeometry(0.5, 0.1, 8, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    emissive: color,
                    transparent: true,
                    opacity: 0.8
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                portalGroup.add(ring);

                // Portal center
                const centerGeometry = new THREE.CircleGeometry(0.4, 16);
                const centerMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.3
                });
                const center = new THREE.Mesh(centerGeometry, centerMaterial);
                center.rotation.x = -Math.PI / 2;
                center.position.y = 0.01;
                portalGroup.add(center);

                portalGroup.position.set(point.x, point.y + 0.1, point.z);
                this.scene.add(portalGroup);

                // Animate portal
                const animatePortal = () => {
                    const time = Date.now() * 0.003;
                    ring.rotation.z = time;
                    center.rotation.z = -time * 0.5;
                    portalGroup.position.y = point.y + 0.1 + Math.sin(time * 2) * 0.05;
                    requestAnimationFrame(animatePortal);
                };
                animatePortal();
            }

            handleCanvasClick(event) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);

                // Handle tower movement mode
                if (this.movingTower) {
                    const intersects = this.raycaster.intersectObject(this.ground);
                    if (intersects.length > 0) {
                        const intersect = intersects[0];
                        const position = intersect.point;

                        // Snap to grid centers
                        position.x = Math.round(position.x - 0.5) + 0.5;
                        position.z = Math.round(position.z - 0.5) + 0.5;
                        position.y = 0;

                        // Check if new position is valid
                        if (this.isValidTowerPosition(position)) {
                            // Move the tower
                            this.movingTower.position.copy(position);
                            this.movingTower.mesh.position.copy(position);
                            if (this.movingTower.rangeIndicator) {
                                this.movingTower.rangeIndicator.position.copy(position);
                            }

                            this.showNotification('‚úÖ Tower moved successfully!');
                            this.cancelTowerMovement();
                        } else {
                            this.showNotification('‚ùå Invalid position! Choose another spot.');
                        }
                    }
                    return;
                }

                // Check if clicking on a tower first
                const towerMeshes = Array.from(this.towers.values()).map(tower => tower.mesh);
                const towerIntersects = this.raycaster.intersectObjects(towerMeshes, true);

                if (towerIntersects.length > 0) {
                    // Clicked on a tower - select it and show stats
                    const clickedMesh = towerIntersects[0].object;
                    const tower = Array.from(this.towers.values()).find(t =>
                        t.mesh === clickedMesh || t.mesh.children.includes(clickedMesh) ||
                        t.mesh.children.some(child => child.children && child.children.includes(clickedMesh))
                    );
                    if (tower) {
                        this.selectTower(tower);
                        return;
                    }
                }

                // If not clicking on a tower, hide ranges
                this.hideTowerRanges();

                // Handle tower placement
                if (!this.selectedTowerType) return;

                const intersects = this.raycaster.intersectObject(this.ground);
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const position = intersect.point;

                    // Snap to grid centers (offset by 0.5 to center on squares)
                    position.x = Math.round(position.x - 0.5) + 0.5;
                    position.z = Math.round(position.z - 0.5) + 0.5;
                    position.y = 0;

                    // Check if position is valid (not on path, not occupied)
                    if (this.isValidTowerPosition(position)) {
                        this.placeTower(position, this.selectedTowerType);
                    }
                }
            }

            handleCanvasMouseMove(event) {
                if (!this.selectedTowerType) {
                    this.clearTowerPreview();
                    return;
                }

                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.ground);

                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const position = intersect.point;

                    // Snap to grid centers
                    const gridX = Math.round(position.x - 0.5) + 0.5;
                    const gridZ = Math.round(position.z - 0.5) + 0.5;
                    const snapPosition = new THREE.Vector3(gridX, 0, gridZ);

                    this.updateHoverTile(gridX, gridZ);
                    this.updateTowerPreview(snapPosition);
                }
            }

            updateTowerPreview(position) {
                // Clear existing preview
                this.clearTowerPreview();

                if (this.isValidTowerPosition(position)) {
                    // Create tower preview
                    this.previewTower = this.createTowerPreview(this.selectedTowerType);
                    this.previewTower.position.copy(position);
                    this.scene.add(this.previewTower);

                    // Create range preview
                    const towerConfig = this.towerTypes[this.selectedTowerType];
                    this.previewRange = this.createRangeIndicator(towerConfig.range);
                    this.previewRange.position.copy(position);
                    this.previewRange.visible = true;
                    // Make range preview more visible
                    this.previewRange.children.forEach(child => {
                        child.material.opacity *= 0.8;
                        child.material.color.setHex(0x00ff00);
                    });
                    this.scene.add(this.previewRange);
                }
            }

            createTowerPreview(type) {
                const towerGroup = new THREE.Group();

                // Base
                const baseGeometry = new THREE.CylinderGeometry(0.4, 0.5, 0.3, 8);
                const baseMaterial = new THREE.MeshLambertMaterial({
                    color: 0x555555,
                    transparent: true,
                    opacity: 0.6
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.15;
                towerGroup.add(base);

                // Tower body
                const towerConfig = this.towerTypes[type];
                const bodyGeometry = new THREE.CylinderGeometry(0.25, 0.35, 0.8, 6);
                const bodyMaterial = new THREE.MeshLambertMaterial({
                    color: towerConfig.color,
                    transparent: true,
                    opacity: 0.6
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.7;
                towerGroup.add(body);

                // Add weapon preview
                this.addTowerWeaponPreview(towerGroup, type);

                return towerGroup;
            }

            addTowerWeaponPreview(towerGroup, type) {
                let weaponMaterial = new THREE.MeshLambertMaterial({
                    color: 0x333333,
                    transparent: true,
                    opacity: 0.6
                });

                switch (type) {
                    case 'basic':
                        const cannonGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.6, 6);
                        const cannon = new THREE.Mesh(cannonGeometry, weaponMaterial);
                        cannon.position.y = 1.2;
                        cannon.rotation.z = Math.PI / 2;
                        towerGroup.add(cannon);
                        break;
                    case 'sniper':
                        const barrelGeometry = new THREE.CylinderGeometry(0.03, 0.04, 1.0, 8);
                        const barrel = new THREE.Mesh(barrelGeometry, weaponMaterial);
                        barrel.position.y = 1.3;
                        barrel.rotation.z = Math.PI / 2;
                        towerGroup.add(barrel);
                        break;
                    case 'splash':
                        const mortarGeometry = new THREE.CylinderGeometry(0.15, 0.12, 0.4, 6);
                        const mortar = new THREE.Mesh(mortarGeometry, weaponMaterial);
                        mortar.position.y = 1.3;
                        towerGroup.add(mortar);
                        break;
                    case 'slow':
                        for (let i = 0; i < 4; i++) {
                            const crystalGeometry = new THREE.ConeGeometry(0.05, 0.3, 4);
                            const crystalMaterial = new THREE.MeshLambertMaterial({
                                color: 0x9b59b6,
                                transparent: true,
                                opacity: 0.4
                            });
                            const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                            crystal.position.y = 1.2;
                            crystal.position.x = Math.cos(i * Math.PI / 2) * 0.2;
                            crystal.position.z = Math.sin(i * Math.PI / 2) * 0.2;
                            towerGroup.add(crystal);
                        }
                        break;
                    case 'laser':
                        const focusGeometry = new THREE.CylinderGeometry(0.15, 0.2, 0.1, 8);
                        const focus = new THREE.Mesh(focusGeometry, weaponMaterial);
                        focus.position.y = 1.3;
                        towerGroup.add(focus);
                        for (let i = 0; i < 6; i++) {
                            const laserGeometry = new THREE.CylinderGeometry(0.02, 0.04, 0.4, 6);
                            const laser = new THREE.Mesh(laserGeometry, weaponMaterial);
                            laser.position.y = 1.1;
                            laser.position.x = Math.cos(i * Math.PI / 3) * 0.15;
                            laser.position.z = Math.sin(i * Math.PI / 3) * 0.15;
                            towerGroup.add(laser);
                        }
                        break;
                    case 'poison':
                        const tankGeometry = new THREE.SphereGeometry(0.2, 8, 6);
                        const tank = new THREE.Mesh(tankGeometry, weaponMaterial);
                        tank.position.y = 1.2;
                        towerGroup.add(tank);
                        for (let i = 0; i < 3; i++) {
                            const nozzleGeometry = new THREE.CylinderGeometry(0.03, 0.06, 0.3, 6);
                            const nozzle = new THREE.Mesh(nozzleGeometry, weaponMaterial);
                            nozzle.position.y = 1.4;
                            nozzle.position.x = Math.cos(i * Math.PI * 2 / 3) * 0.12;
                            nozzle.position.z = Math.sin(i * Math.PI * 2 / 3) * 0.12;
                            nozzle.rotation.z = Math.PI / 2;
                            towerGroup.add(nozzle);
                        }
                        break;
                    case 'electric':
                        const coilGeometry = new THREE.CylinderGeometry(0.08, 0.12, 0.6, 8);
                        const coil = new THREE.Mesh(coilGeometry, weaponMaterial);
                        coil.position.y = 1.3;
                        towerGroup.add(coil);
                        for (let i = 0; i < 3; i++) {
                            const ringGeometry = new THREE.TorusGeometry(0.15 + i * 0.05, 0.02, 4, 8);
                            const ring = new THREE.Mesh(ringGeometry, weaponMaterial);
                            ring.position.y = 1.1 + i * 0.15;
                            ring.rotation.x = Math.PI / 2;
                            towerGroup.add(ring);
                        }
                        break;
                    case 'booster':
                        // Central satellite dish
                        const dishGeometry = new THREE.ConeGeometry(0.2, 0.1, 8);
                        const dish = new THREE.Mesh(dishGeometry, weaponMaterial);
                        dish.position.y = 1.3;
                        dish.rotation.x = Math.PI;
                        towerGroup.add(dish);
                        // Signal transmitters
                        for (let i = 0; i < 4; i++) {
                            const transmitterGeometry = new THREE.CylinderGeometry(0.02, 0.04, 0.2, 4);
                            const transmitter = new THREE.Mesh(transmitterGeometry, weaponMaterial);
                            transmitter.position.y = 1.1;
                            transmitter.position.x = Math.cos(i * Math.PI / 2) * 0.15;
                            transmitter.position.z = Math.sin(i * Math.PI / 2) * 0.15;
                            towerGroup.add(transmitter);
                        }
                        break;
                }
            }

            clearTowerPreview() {
                if (this.previewTower) {
                    this.scene.remove(this.previewTower);
                    this.previewTower = null;
                }
                if (this.previewRange) {
                    this.scene.remove(this.previewRange);
                    this.previewRange = null;
                }
            }

            isValidTowerPosition(position) {
                // Check if position is too close to path
                for (const pathPoint of this.pathPoints) {
                    const distance = Math.sqrt(
                        (position.x - pathPoint.x) ** 2 +
                        (position.z - pathPoint.z) ** 2
                    );
                    if (distance < 1.5) return false;
                }

                // Check if position is occupied by another tower
                for (const tower of this.towers.values()) {
                    const distance = Math.sqrt(
                        (position.x - tower.position.x) ** 2 +
                        (position.z - tower.position.z) ** 2
                    );
                    if (distance < 1) return false;
                }

                // Check bounds (extended area)
                if (Math.abs(position.x) > 11 || Math.abs(position.z) > 7) return false;

                // Check if position overlaps with environment objects (trees/rocks)
                for (const obj of this.environmentObjects) {
                    const distance = Math.sqrt(
                        (position.x - obj.x) ** 2 +
                        (position.z - obj.z) ** 2
                    );
                    if (distance < obj.radius + 0.5) return false; // Add some buffer
                }

                return true;
            }

            createPlacementGrid() {
                // Create visual grid tiles for tower placement
                const tileGeometry = new THREE.PlaneGeometry(0.9, 0.9);
                const validTileMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide
                });
                const invalidTileMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const hoverTileMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00f5ff,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });

                this.gridMaterials = {
                    valid: validTileMaterial,
                    invalid: invalidTileMaterial,
                    hover: hoverTileMaterial
                };

                // Create grid tiles at square centers (extended area)
                for (let x = -11; x <= 10; x++) {
                    for (let z = -7; z <= 6; z++) {
                        const tile = new THREE.Mesh(tileGeometry, validTileMaterial.clone());
                        tile.rotation.x = -Math.PI / 2;
                        tile.position.set(x + 0.5, 0.01, z + 0.5);
                        tile.userData = { gridX: x + 0.5, gridZ: z + 0.5 };
                        tile.visible = false; // Initially hidden
                        this.scene.add(tile);
                        this.gridTiles.push(tile);
                    }
                }
            }

            updateHoverTile(gridX, gridZ) {
                // Clear previous hover
                if (this.hoveredTile) {
                    this.hoveredTile.visible = false;
                }

                // Find the tile at this grid position
                const tile = this.gridTiles.find(t =>
                    t.userData.gridX === gridX && t.userData.gridZ === gridZ
                );

                if (tile) {
                    this.hoveredTile = tile;
                    const position = new THREE.Vector3(gridX, 0, gridZ);

                    if (this.isValidTowerPosition(position)) {
                        tile.material = this.gridMaterials.hover;
                    } else {
                        tile.material = this.gridMaterials.invalid;
                    }
                    tile.visible = true;
                }
            }

            showPlacementGrid() {
                // Show all grid tiles when a tower is selected
                this.gridTiles.forEach(tile => {
                    const position = new THREE.Vector3(tile.userData.gridX, 0, tile.userData.gridZ);
                    if (this.isValidTowerPosition(position)) {
                        tile.material = this.gridMaterials.valid;
                    } else {
                        tile.material = this.gridMaterials.invalid;
                    }
                    tile.visible = true;
                });
            }

            hidePlacementGrid() {
                // Hide all grid tiles
                this.gridTiles.forEach(tile => {
                    tile.visible = false;
                });
                this.hoveredTile = null;
            }

            selectTowerType(type) {
                // Clear previous selection
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.classList.remove('selected');
                });

                // Clear any existing tower preview
                this.clearTowerPreview();

                if (this.selectedTowerType === type) {
                    this.selectedTowerType = null;
                } else {
                    this.selectedTowerType = type;
                    const btn = document.getElementById(type + 'TowerBtn');
                    btn.classList.add('selected');
                }
            }

            placeTower(position, type) {
                const towerConfig = this.towerTypes[type];
                if (this.gold < towerConfig.cost) {
                    this.showNotification('‚ùå Not enough gold!');
                    return;
                }

                const towerId = 'tower_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);

                // Create enhanced 3D tower model
                const towerGroup = new THREE.Group();

                // Enhanced Base with metallic finish
                const baseGeometry = new THREE.CylinderGeometry(0.45, 0.55, 0.35, 12);
                const baseMaterial = new THREE.MeshPhongMaterial({
                    color: 0x333333,
                    shininess: 80,
                    specular: 0x111111
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.175;
                base.castShadow = true;
                towerGroup.add(base);

                // Base ring detail
                const ringGeometry = new THREE.TorusGeometry(0.42, 0.03, 6, 16);
                const ringMaterial = new THREE.MeshPhongMaterial({
                    color: 0x444444,
                    shininess: 100
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.y = 0.35;
                ring.rotation.x = Math.PI / 2;
                towerGroup.add(ring);

                // Enhanced Tower body with glow effect
                const bodyGeometry = new THREE.CylinderGeometry(0.28, 0.38, 0.9, 8);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: towerConfig.color,
                    shininess: 60,
                    emissive: new THREE.Color(towerConfig.color).multiplyScalar(0.1)
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.8;
                body.castShadow = true;
                towerGroup.add(body);

                // Tower top cap
                const capGeometry = new THREE.CylinderGeometry(0.22, 0.28, 0.1, 8);
                const capMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(towerConfig.color).multiplyScalar(1.3),
                    shininess: 100
                });
                const cap = new THREE.Mesh(capGeometry, capMaterial);
                cap.position.y = 1.3;
                towerGroup.add(cap);

                // Weapon (different for each type)
                this.addTowerWeapon(towerGroup, type);

                towerGroup.position.copy(position);
                this.scene.add(towerGroup);

                // Create range indicator
                const rangeIndicator = this.createRangeIndicator(towerConfig.range);
                rangeIndicator.position.copy(position);
                rangeIndicator.visible = false;
                this.scene.add(rangeIndicator);

                // Store tower data
                const towerData = {
                    id: towerId,
                    type: type,
                    position: position.clone(),
                    mesh: towerGroup,
                    rangeIndicator: rangeIndicator,
                    targetBeam: null,
                    lastFired: 0,
                    level: 1,
                    totalDamage: 0,
                    kills: 0,
                    shotsFired: 0,
                    ...towerConfig
                };

                this.towers.set(towerId, towerData);
                this.gold -= towerConfig.cost;
                this.updateUI();

                // Initialize visual upgrades for the tower
                this.addTowerUpgradeVisuals(towerData);

                this.showNotification(`üèóÔ∏è ${type.charAt(0).toUpperCase() + type.slice(1)} tower placed!`);
                this.selectedTowerType = null;
                this.hidePlacementGrid();
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.classList.remove('selected');
                });
            }

            createRangeIndicator(range) {
                const rangeGroup = new THREE.Group();

                // Range circle
                const rangeGeometry = new THREE.RingGeometry(range - 0.1, range + 0.1, 16);
                const rangeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.08,
                    side: THREE.DoubleSide
                });
                const rangeCircle = new THREE.Mesh(rangeGeometry, rangeMaterial);
                rangeCircle.rotation.x = -Math.PI / 2;
                rangeCircle.position.y = 0.05;
                rangeGroup.add(rangeCircle);

                // Range area
                const areaGeometry = new THREE.CircleGeometry(range, 16);
                const areaMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.03,
                    side: THREE.DoubleSide
                });
                const rangeArea = new THREE.Mesh(areaGeometry, areaMaterial);
                rangeArea.rotation.x = -Math.PI / 2;
                rangeArea.position.y = 0.03;
                rangeGroup.add(rangeArea);

                return rangeGroup;
            }

            showTowerRange(tower) {
                // Hide all other range indicators
                this.towers.forEach(t => {
                    if (t.rangeIndicator) t.rangeIndicator.visible = false;
                });

                // Show this tower's range
                if (tower.rangeIndicator) {
                    tower.rangeIndicator.visible = true;
                }
            }

            hideTowerRanges() {
                this.towers.forEach(tower => {
                    if (tower.rangeIndicator) tower.rangeIndicator.visible = false;
                });
                // Hide tower info panel when hiding ranges
                document.getElementById('towerInfoPanel').style.display = 'none';
                this.selectedTower = null;
            }

            selectTower(tower) {
                this.selectedTower = tower;
                this.hideTowerRanges();

                // Show this tower's range
                if (tower.rangeIndicator) {
                    tower.rangeIndicator.visible = true;
                }

                // Populate and show tower info panel
                this.updateTowerInfoPanel(tower);
                document.getElementById('towerInfoPanel').style.display = 'block';
            }

            updateTowerInfoPanel(tower) {
                const boostedStats = this.getBoostedTowerStats(tower);
                const isBoosted = boostedStats.damage !== tower.damage || boostedStats.range !== tower.range || boostedStats.fireRate !== tower.fireRate;

                document.getElementById('towerTypeStat').textContent = tower.type.charAt(0).toUpperCase() + tower.type.slice(1);
                document.getElementById('towerLevelStat').textContent = tower.level || 1;

                // Show boosted stats with indication if boosted
                document.getElementById('towerDamageStat').textContent = isBoosted ?
                    `${tower.damage} ‚Üí ${boostedStats.damage}` : (tower.damage || 0);
                document.getElementById('towerRangeStat').textContent = isBoosted ?
                    `${tower.range.toFixed(1)} ‚Üí ${boostedStats.range.toFixed(1)}` : (tower.range || 0).toFixed(1);

                const baseFireRate = tower.fireRate ? (1000 / tower.fireRate).toFixed(1) + '/s' : '-';
                const boostedFireRate = boostedStats.fireRate ? (1000 / boostedStats.fireRate).toFixed(1) + '/s' : '-';
                document.getElementById('towerFireRateStat').textContent = isBoosted ?
                    `${baseFireRate} ‚Üí ${boostedFireRate}` : baseFireRate;

                document.getElementById('towerTotalDamageStat').textContent = tower.totalDamage || 0;
                document.getElementById('towerKillsStat').textContent = tower.kills || 0;
                document.getElementById('towerShotsFiredStat').textContent = tower.shotsFired || 0;

                // Update button states and text based on tower level
                const currentLevel = tower.level || 1;
                const upgradeCost = Math.floor(tower.cost * 0.75 * currentLevel);
                const sellPrice = Math.floor(tower.cost * 0.5 * currentLevel);

                const upgradeBtn = document.getElementById('upgradeTowerBtn');
                const downgradeBtn = document.getElementById('downgradeTowerBtn');
                const sellBtn = document.getElementById('sellTowerBtn');

                upgradeBtn.disabled = currentLevel >= 5;
                downgradeBtn.disabled = currentLevel <= 1;

                // Update button text with prices
                upgradeBtn.textContent = currentLevel >= 5 ? '‚¨ÜÔ∏è MAX LEVEL' : `‚¨ÜÔ∏è Upgrade ($${upgradeCost})`;
                sellBtn.textContent = `üí∞ Sell ($${sellPrice})`;
            }

            upgradeTower() {
                if (!this.selectedTower) return;

                const tower = this.selectedTower;
                const currentLevel = tower.level || 1;
                const upgradeCost = Math.floor(tower.cost * 0.75 * currentLevel);

                if (currentLevel >= 5) {
                    alert('Tower is already at maximum level!');
                    return;
                }

                if (this.gold < upgradeCost) {
                    alert(`Not enough gold! Need $${upgradeCost}`);
                    return;
                }

                // Deduct gold and upgrade tower
                this.gold -= upgradeCost;
                tower.level = currentLevel + 1;

                // Improve tower stats
                tower.damage = Math.floor(tower.damage * 1.5);
                tower.range = tower.range * 1.2;
                tower.fireRate = Math.max(tower.fireRate * 0.8, 100); // Faster firing, min 100ms

                // Check achievements
                if (!this.achievements.firstUpgrade.unlocked) {
                    this.unlockAchievement('firstUpgrade');
                }
                if (tower.level >= 5 && !this.achievements.maxLevel.unlocked) {
                    this.unlockAchievement('maxLevel');
                }

                // Update range indicator
                if (tower.rangeIndicator) {
                    tower.rangeIndicator.scale.setScalar(tower.range * 2);
                }

                // Add visual upgrade indicators
                this.addTowerUpgradeVisuals(tower);

                // Update UI
                this.updateUI();
                this.updateTowerInfoPanel(tower);

                console.log(`Tower upgraded to level ${tower.level} for $${upgradeCost}`);
            }

            downgradeTower() {
                if (!this.selectedTower) return;

                const tower = this.selectedTower;
                const currentLevel = tower.level || 1;

                if (currentLevel <= 1) {
                    alert('Tower is already at minimum level!');
                    return;
                }

                // Refund partial gold
                const refund = Math.floor(tower.cost * 0.5 * (currentLevel - 1));
                this.gold += refund;
                tower.level = currentLevel - 1;

                // Reduce tower stats
                tower.damage = Math.ceil(tower.damage / 1.5);
                tower.range = tower.range / 1.2;
                tower.fireRate = Math.min(tower.fireRate * 1.25, 2000); // Slower firing, max 2000ms

                // Update range indicator
                if (tower.rangeIndicator) {
                    tower.rangeIndicator.scale.setScalar(tower.range * 2);
                }

                // Update visual upgrade indicators
                this.addTowerUpgradeVisuals(tower);

                // Update UI
                this.updateUI();
                this.updateTowerInfoPanel(tower);

                console.log(`Tower downgraded to level ${tower.level}, refunded $${refund}`);
            }

            sellTower() {
                if (!this.selectedTower) return;

                const tower = this.selectedTower;
                const sellPrice = Math.floor(tower.cost * 0.5 * (tower.level || 1));

                // Refund gold
                this.gold += sellPrice;

                // Remove tower from scene and arrays
                this.scene.remove(tower.mesh);
                if (tower.rangeIndicator) {
                    this.scene.remove(tower.rangeIndicator);
                }

                // Remove from towers array
                const index = this.towers.findIndex(t => t.id === tower.id);
                if (index !== -1) {
                    this.towers.splice(index, 1);
                }

                // Hide tower info panel
                document.getElementById('towerInfoPanel').style.display = 'none';
                this.selectedTower = null;

                // Update UI
                this.updateUI();

                console.log(`Tower sold for $${sellPrice}`);
            }

            moveTower() {
                if (!this.selectedTower) return;

                this.movingTower = this.selectedTower;
                this.movingTowerOriginalPosition = this.selectedTower.position.clone();

                // Change cursor and show instructions
                document.body.style.cursor = 'move';
                this.showNotification('üèóÔ∏è Click a new position to move the tower, right-click to cancel');

                // Hide tower info panel temporarily
                document.getElementById('towerInfoPanel').style.display = 'none';
            }

            addTowerUpgradeVisuals(tower) {
                // Remove existing upgrade visuals
                if (tower.upgradeVisuals) {
                    tower.upgradeVisuals.forEach(visual => {
                        tower.mesh.remove(visual);
                    });
                }

                tower.upgradeVisuals = [];
                const level = tower.level || 1;

                if (level <= 1) return; // No visuals for level 1

                // Add level indicators - small spheres around the tower
                for (let i = 1; i < level; i++) {
                    const indicatorGeometry = new THREE.SphereGeometry(0.08, 6, 4);
                    const indicatorMaterial = new THREE.MeshBasicMaterial({
                        color: this.getLevelColor(level),
                        emissive: this.getLevelColor(level),
                        emissiveIntensity: 0.3
                    });
                    const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);

                    // Position indicators in a circle around the tower
                    const angle = (i - 1) * (Math.PI * 2 / (level - 1));
                    indicator.position.set(
                        Math.cos(angle) * 0.6,
                        1.4 + (i - 1) * 0.15, // Stack them vertically
                        Math.sin(angle) * 0.6
                    );

                    tower.mesh.add(indicator);
                    tower.upgradeVisuals.push(indicator);

                    // Add floating animation
                    indicator.userData = {
                        originalY: indicator.position.y,
                        floatOffset: Math.random() * Math.PI * 2
                    };
                }

                // Add crown for max level towers
                if (level >= 5) {
                    const crownGeometry = new THREE.ConeGeometry(0.2, 0.3, 6);
                    const crownMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffd700,
                        emissive: 0xffd700,
                        emissiveIntensity: 0.4
                    });
                    const crown = new THREE.Mesh(crownGeometry, crownMaterial);
                    crown.position.set(0, 1.8, 0);

                    tower.mesh.add(crown);
                    tower.upgradeVisuals.push(crown);

                    crown.userData = {
                        originalY: crown.position.y,
                        floatOffset: 0
                    };
                }
            }

            getLevelColor(level) {
                const colors = [
                    0x888888, // Level 1 - Gray (not used)
                    0x00ff00, // Level 2 - Green
                    0x0088ff, // Level 3 - Blue
                    0xff8800, // Level 4 - Orange
                    0xffd700  // Level 5 - Gold
                ];
                return colors[Math.min(level - 1, colors.length - 1)];
            }

            cancelTowerMovement() {
                this.movingTower = null;
                this.movingTowerOriginalPosition = null;
                document.body.style.cursor = 'default';

                // Show tower info panel again if we had a selected tower
                if (this.selectedTower) {
                    document.getElementById('towerInfoPanel').style.display = 'block';
                }
            }

            handleCanvasRightClick(event) {
                event.preventDefault();

                // Cancel tower movement if in progress
                if (this.movingTower) {
                    this.showNotification('‚ùå Tower movement cancelled');
                    this.cancelTowerMovement();
                    return;
                }

                // Cancel tower selection if any tower type is selected
                if (this.selectedTowerType) {
                    this.selectedTowerType = null;
                    this.clearTowerPreview();
                    document.querySelectorAll('.tower-btn').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    this.showNotification('‚ùå Tower placement cancelled');
                }
            }

            animateTowerUpgrades() {
                const time = Date.now() * 0.002;

                for (const [towerId, tower] of this.towers) {
                    // Animate upgrade visuals
                    if (tower.upgradeVisuals && tower.upgradeVisuals.length > 0) {
                        tower.upgradeVisuals.forEach(visual => {
                            if (visual.userData && visual.userData.originalY !== undefined) {
                                visual.position.y = visual.userData.originalY + Math.sin(time + visual.userData.floatOffset) * 0.05;
                                visual.rotation.y += 0.02;
                            }
                        });
                    }

                    // Check if tower is boosted and add glow effect
                    if (tower.type !== 'booster') {
                        const boostedStats = this.getBoostedTowerStats(tower);
                        const isBoosted = boostedStats.damage !== tower.damage || boostedStats.range !== tower.range;

                        if (isBoosted && !tower.boostGlow) {
                            this.addBoostGlow(tower);
                        } else if (!isBoosted && tower.boostGlow) {
                            this.removeBoostGlow(tower);
                        }

                        // Animate boost glow
                        if (tower.boostGlow) {
                            tower.boostGlow.material.opacity = 0.3 + Math.sin(time * 2) * 0.1;
                        }
                    }
                }
            }

            getBoostedTowerStats(tower) {
                let boostedStats = {
                    damage: tower.damage,
                    range: tower.range,
                    fireRate: tower.fireRate
                };

                // Check for nearby booster towers
                for (const [boosterId, booster] of this.towers) {
                    if (booster.type === 'booster' && booster.id !== tower.id) {
                        const distance = tower.position.distanceTo(booster.position);
                        if (distance <= booster.range) {
                            // Apply booster effects
                            boostedStats.damage = Math.floor(boostedStats.damage * booster.boost.damage);
                            boostedStats.range = boostedStats.range * booster.boost.range;
                            boostedStats.fireRate = boostedStats.fireRate * booster.boost.fireRate;
                        }
                    }
                }

                return boostedStats;
            }

            addBoostGlow(tower) {
                const glowGeometry = new THREE.RingGeometry(0.8, 1.0, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.rotation.x = -Math.PI / 2;
                glow.position.y = 0.1;

                tower.mesh.add(glow);
                tower.boostGlow = glow;
            }

            removeBoostGlow(tower) {
                if (tower.boostGlow) {
                    tower.mesh.remove(tower.boostGlow);
                    tower.boostGlow = null;
                }
            }

            cleanupOldObjects() {
                try {
                    // Enhanced cleanup for better memory management
                    const projectilesToRemove = [];
                    for (const [projectileId, projectile] of this.projectiles) {
                        if (!projectile || !projectile.mesh || !projectile.target ||
                            !projectile.mesh.parent ||
                            !this.enemies.has(projectile.target.id) ||
                            projectile.mesh.position.distanceTo(projectile.target.mesh.position) > 50) {

                            if (projectile && projectile.mesh) {
                                this.scene.remove(projectile.mesh);
                            }
                            projectilesToRemove.push(projectileId);
                        }
                    }

                    // Remove marked projectiles
                    projectilesToRemove.forEach(id => {
                        this.projectiles.delete(id);
                    });

                    // Clean up expired power-ups
                    const powerUpsToRemove = [];
                    for (const [id, powerUp] of this.powerUps) {
                        if (powerUp.collected || (Date.now() - powerUp.spawnTime) > 30000) {
                            if (powerUp.mesh) {
                                this.scene.remove(powerUp.mesh);
                            }
                            powerUpsToRemove.push(id);
                        }
                    }

                    powerUpsToRemove.forEach(id => {
                        this.powerUps.delete(id);
                    });

                    // Monitor performance less frequently for better optimization
                    this.frameCount = (this.frameCount || 0) + 1;
                    if (this.frameCount % 120 === 0) { // Check every 120 frames (2 seconds at 60fps)
                        const currentTime = performance.now();
                        if (this.lastFrameTime) {
                            const fps = 120000 / (currentTime - this.lastFrameTime);
                            if (fps < 25 && !this.performanceMode) {
                                this.reduceEffects();
                            }
                        }
                        this.lastFrameTime = currentTime;
                    }
                } catch (error) {
                    console.error('Cleanup error:', error);
                }
            }

            reduceEffects() {
                this.performanceMode = true;
                this.showNotification('üîß Performance mode enabled');
                console.log('Performance mode activated due to low FPS');
            }

            checkAchievements() {
                // Check for new achievements
                if (!this.achievements.firstTower.unlocked && this.towers.size > 0) {
                    this.unlockAchievement('firstTower');
                }

                if (!this.achievements.tenKills.unlocked && this.totalKills >= 10) {
                    this.unlockAchievement('tenKills');
                }

                if (!this.achievements.hundredKills.unlocked && this.totalKills >= 100) {
                    this.unlockAchievement('hundredKills');
                }

                if (!this.achievements.wave10.unlocked && this.wave >= 10) {
                    this.unlockAchievement('wave10');
                }

                if (!this.achievements.wave25.unlocked && this.wave >= 25) {
                    this.unlockAchievement('wave25');
                }

                if (!this.achievements.millionaire.unlocked && this.gold >= 1000) {
                    this.unlockAchievement('millionaire');
                }

                // Check for booster tower
                if (!this.achievements.boosterMaster.unlocked) {
                    for (const [towerId, tower] of this.towers) {
                        if (tower.type === 'booster') {
                            this.unlockAchievement('boosterMaster');
                            break;
                        }
                    }
                }
            }

            unlockAchievement(achievementKey) {
                if (!this.achievements[achievementKey].unlocked) {
                    this.achievements[achievementKey].unlocked = true;
                    const achievement = this.achievements[achievementKey];
                    this.showNotification(`üèÜ Achievement: ${achievement.name}! ${achievement.description}`);

                    // Save achievements to localStorage
                    localStorage.setItem('towerDefenseAchievements', JSON.stringify(this.achievements));
                }
            }

            saveGame() {
                try {
                    const gameState = {
                        gold: this.gold,
                        lives: this.lives,
                        wave: this.wave,
                        currentScore: this.currentScore,
                        totalKills: this.totalKills,
                        achievements: this.achievements,
                        isWaveActive: this.isWaveActive,
                        towers: Array.from(this.towers.entries()).map(([id, tower]) => ({
                            id: id,
                            type: tower.type,
                            position: { x: tower.position.x, y: tower.position.y, z: tower.position.z },
                            level: tower.level || 1,
                            totalDamage: tower.totalDamage || 0,
                            kills: tower.kills || 0,
                            shotsFired: tower.shotsFired || 0
                        })),
                        timestamp: Date.now()
                    };

                    localStorage.setItem('towerDefenseGameState', JSON.stringify(gameState));
                    this.showNotification('üíæ Game saved successfully!');
                    return true;
                } catch (error) {
                    console.error('Save failed:', error);
                    this.showNotification('‚ùå Save failed!');
                    return false;
                }
            }

            loadGame() {
                try {
                    const savedState = localStorage.getItem('towerDefenseGameState');
                    if (!savedState) {
                        this.showNotification('‚ùå No saved game found!');
                        return false;
                    }

                    const gameState = JSON.parse(savedState);

                    // Restore basic game state
                    this.gold = gameState.gold || 100;
                    this.lives = gameState.lives || 20;
                    this.wave = gameState.wave || 1;
                    this.currentScore = gameState.currentScore || 0;
                    this.totalKills = gameState.totalKills || 0;
                    this.achievements = { ...this.achievements, ...gameState.achievements };

                    // Clear existing towers
                    for (const [towerId, tower] of this.towers) {
                        this.scene.remove(tower.mesh);
                        if (tower.rangeIndicator) this.scene.remove(tower.rangeIndicator);
                    }
                    this.towers.clear();

                    // Restore towers
                    if (gameState.towers) {
                        gameState.towers.forEach(towerData => {
                            const position = new THREE.Vector3(towerData.position.x, towerData.position.y, towerData.position.z);
                            this.placeTowerFromSave(position, towerData.type, towerData);
                        });
                    }

                    this.updateUI();
                    this.showNotification('‚úÖ Game loaded successfully!');
                    return true;
                } catch (error) {
                    console.error('Load failed:', error);
                    this.showNotification('‚ùå Load failed!');
                    return false;
                }
            }

            placeTowerFromSave(position, type, savedData) {
                const towerConfig = this.towerTypes[type];
                const towerId = savedData.id;

                // Create tower (simplified version of placeTower)
                const towerGroup = new THREE.Group();

                // Base
                const baseGeometry = new THREE.CylinderGeometry(0.4, 0.5, 0.3, 8);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.15;
                base.castShadow = true;
                towerGroup.add(base);

                // Tower body
                const bodyGeometry = new THREE.CylinderGeometry(0.25, 0.35, 0.8, 6);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: towerConfig.color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.7;
                body.castShadow = true;
                towerGroup.add(body);

                // Weapon
                this.addTowerWeapon(towerGroup, type);

                towerGroup.position.copy(position);
                this.scene.add(towerGroup);

                // Create range indicator
                const rangeIndicator = this.createRangeIndicator(towerConfig.range);
                rangeIndicator.position.copy(position);
                rangeIndicator.visible = false;
                this.scene.add(rangeIndicator);

                // Store tower data with saved stats
                const towerData = {
                    id: towerId,
                    type: type,
                    position: position.clone(),
                    mesh: towerGroup,
                    rangeIndicator: rangeIndicator,
                    targetBeam: null,
                    lastFired: 0,
                    level: savedData.level || 1,
                    totalDamage: savedData.totalDamage || 0,
                    kills: savedData.kills || 0,
                    shotsFired: savedData.shotsFired || 0,
                    ...towerConfig
                };

                // Apply upgrades to match saved level
                for (let i = 1; i < towerData.level; i++) {
                    towerData.damage = Math.floor(towerData.damage * 1.5);
                    towerData.range = towerData.range * 1.2;
                    towerData.fireRate = Math.max(towerData.fireRate * 0.8, 100);
                }

                // Update range indicator for upgraded towers
                if (towerData.rangeIndicator) {
                    towerData.rangeIndicator.scale.setScalar(towerData.range * 2);
                }

                this.towers.set(towerId, towerData);
                this.addTowerUpgradeVisuals(towerData);
            }

            loadAchievements() {
                try {
                    const savedAchievements = localStorage.getItem('towerDefenseAchievements');
                    if (savedAchievements) {
                        const achievements = JSON.parse(savedAchievements);
                        this.achievements = { ...this.achievements, ...achievements };
                    }
                } catch (error) {
                    console.error('Failed to load achievements:', error);
                }
            }

            showHelpMessage() {
                const helpText = `
üéÆ TOWER DEFENSE CONTROLS üéÆ

üèóÔ∏è Building:
‚Ä¢ 1-8: Select tower types
‚Ä¢ Click: Place selected tower
‚Ä¢ Right-click: Cancel

üèØ Tower Management:
‚Ä¢ Click tower: Select and view stats
‚Ä¢ U: Upgrade selected tower
‚Ä¢ D: Downgrade selected tower
‚Ä¢ S: Sell selected tower
‚Ä¢ M: Move selected tower

üåä Game Controls:
‚Ä¢ Space/Enter: Start wave
‚Ä¢ P: Pause/Unpause
‚Ä¢ F5/Ctrl+S: Save game
‚Ä¢ F9/Ctrl+L: Load game
‚Ä¢ H/?: Show this help

üì∑ Camera:
‚Ä¢ Free Camera: WASD + Mouse
‚Ä¢ +/-: Zoom in/out
‚Ä¢ Mouse wheel: Zoom

üèÜ Achievement system included!
üíæ Auto-save every 5 waves!
                `;
                this.showNotification(helpText);
            }

            togglePause() {
                this.gameRunning = !this.gameRunning;
                if (this.gameRunning) {
                    this.showNotification('‚ñ∂Ô∏è Game resumed');
                    this.startGameLoop();
                } else {
                    this.showNotification('‚è∏Ô∏è Game paused');
                }
            }

            addTowerWeapon(towerGroup, type) {
                switch (type) {
                    case 'basic':
                        // Simple cannon
                        const cannonGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.6, 6);
                        const cannonMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                        const cannon = new THREE.Mesh(cannonGeometry, cannonMaterial);
                        cannon.position.y = 1.2;
                        cannon.rotation.z = Math.PI / 2;
                        towerGroup.add(cannon);
                        break;

                    case 'sniper':
                        // Long barrel
                        const barrelGeometry = new THREE.CylinderGeometry(0.03, 0.04, 1.0, 8);
                        const barrelMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e50 });
                        const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                        barrel.position.y = 1.3;
                        barrel.rotation.z = Math.PI / 2;
                        towerGroup.add(barrel);
                        break;

                    case 'splash':
                        // Mortar tube
                        const mortarGeometry = new THREE.CylinderGeometry(0.15, 0.12, 0.4, 6);
                        const mortarMaterial = new THREE.MeshLambertMaterial({ color: 0xd35400 });
                        const mortar = new THREE.Mesh(mortarGeometry, mortarMaterial);
                        mortar.position.y = 1.3;
                        towerGroup.add(mortar);
                        break;

                    case 'slow':
                        // Crystal array
                        for (let i = 0; i < 4; i++) {
                            const crystalGeometry = new THREE.ConeGeometry(0.05, 0.3, 4);
                            const crystalMaterial = new THREE.MeshLambertMaterial({
                                color: 0x9b59b6,
                                transparent: true,
                                opacity: 0.8
                            });
                            const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                            crystal.position.y = 1.2;
                            crystal.position.x = Math.cos(i * Math.PI / 2) * 0.2;
                            crystal.position.z = Math.sin(i * Math.PI / 2) * 0.2;
                            towerGroup.add(crystal);
                        }
                        break;
                    case 'laser':
                        // Laser array with focusing lens
                        const focusGeometry = new THREE.CylinderGeometry(0.15, 0.2, 0.1, 8);
                        const focusMaterial = new THREE.MeshLambertMaterial({ color: 0xff0066 });
                        const focus = new THREE.Mesh(focusGeometry, focusMaterial);
                        focus.position.y = 1.3;
                        towerGroup.add(focus);

                        for (let i = 0; i < 6; i++) {
                            const laserGeometry = new THREE.CylinderGeometry(0.02, 0.04, 0.4, 6);
                            const laserMaterial = new THREE.MeshLambertMaterial({ color: 0xff3388 });
                            const laser = new THREE.Mesh(laserGeometry, laserMaterial);
                            laser.position.y = 1.1;
                            laser.position.x = Math.cos(i * Math.PI / 3) * 0.15;
                            laser.position.z = Math.sin(i * Math.PI / 3) * 0.15;
                            towerGroup.add(laser);
                        }
                        break;
                    case 'poison':
                        // Poison tank with nozzles
                        const tankGeometry = new THREE.SphereGeometry(0.2, 8, 6);
                        const tankMaterial = new THREE.MeshLambertMaterial({ color: 0x27ae60 });
                        const tank = new THREE.Mesh(tankGeometry, tankMaterial);
                        tank.position.y = 1.2;
                        towerGroup.add(tank);

                        for (let i = 0; i < 3; i++) {
                            const nozzleGeometry = new THREE.CylinderGeometry(0.03, 0.06, 0.3, 6);
                            const nozzleMaterial = new THREE.MeshLambertMaterial({ color: 0x229954 });
                            const nozzle = new THREE.Mesh(nozzleGeometry, nozzleMaterial);
                            nozzle.position.y = 1.4;
                            nozzle.position.x = Math.cos(i * Math.PI * 2 / 3) * 0.12;
                            nozzle.position.z = Math.sin(i * Math.PI * 2 / 3) * 0.12;
                            nozzle.rotation.z = Math.PI / 2;
                            towerGroup.add(nozzle);
                        }
                        break;
                    case 'electric':
                        // Tesla coil with electric rings
                        const coilGeometry = new THREE.CylinderGeometry(0.08, 0.12, 0.6, 8);
                        const coilMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 });
                        const coil = new THREE.Mesh(coilGeometry, coilMaterial);
                        coil.position.y = 1.3;
                        towerGroup.add(coil);

                        for (let i = 0; i < 3; i++) {
                            const ringGeometry = new THREE.TorusGeometry(0.15 + i * 0.05, 0.02, 4, 8);
                            const ringMaterial = new THREE.MeshLambertMaterial({ color: 0xe6e600 });
                            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                            ring.position.y = 1.1 + i * 0.15;
                            ring.rotation.x = Math.PI / 2;
                            towerGroup.add(ring);
                        }
                        break;
                    case 'booster':
                        // Central satellite dish
                        const dishGeometry = new THREE.ConeGeometry(0.2, 0.1, 8);
                        const dishMaterial = new THREE.MeshLambertMaterial({ color: 0x00ffff });
                        const dish = new THREE.Mesh(dishGeometry, dishMaterial);
                        dish.position.y = 1.3;
                        dish.rotation.x = Math.PI;
                        towerGroup.add(dish);
                        // Signal transmitters
                        for (let i = 0; i < 4; i++) {
                            const transmitterGeometry = new THREE.CylinderGeometry(0.02, 0.04, 0.2, 4);
                            const transmitterMaterial = new THREE.MeshLambertMaterial({ color: 0x00cccc });
                            const transmitter = new THREE.Mesh(transmitterGeometry, transmitterMaterial);
                            transmitter.position.y = 1.1;
                            transmitter.position.x = Math.cos(i * Math.PI / 2) * 0.15;
                            transmitter.position.z = Math.sin(i * Math.PI / 2) * 0.15;
                            towerGroup.add(transmitter);
                        }
                        break;
                }
            }

            async joinGame() {
                this.playerName = this.playerNameInput.value.trim();

                try {
                    // Add player to the game
                    const playerRef = ref(database, `rooms/${this.roomCode}/players/${this.playerId}`);
                    await set(playerRef, {
                        name: this.playerName,
                        gold: this.gold,
                        lives: this.lives,
                        wave: this.wave,
                        score: this.currentScore,
                        connected: true,
                        joinedAt: serverTimestamp()
                    });

                    this.startGame();
                } catch (error) {
                    this.showError('Failed to join game: ' + error.message);
                }
            }

            startGame() {
                this.namePrompt.style.display = 'none';
                this.gameContainer.style.display = 'flex';

                // Set up Firebase listeners
                this.setupGameListeners();
                this.setupDisconnectCleanup();

                // Start game loops
                this.startGameLoop();
                this.startNextWaveTimer();
                this.loadLeaderboard();
                this.startLeaderboardSync();

                // Resize renderer
                this.onWindowResize();
                window.addEventListener('resize', () => this.onWindowResize());
            }

            setupGameListeners() {
                const roomRef = ref(database, `rooms/${this.roomCode}`);
                onValue(roomRef, (snapshot) => {
                    if (snapshot.exists()) {
                        this.gameState = snapshot.val();
                    }
                });
            }

            setupDisconnectCleanup() {
                const playerRef = ref(database, `rooms/${this.roomCode}/players/${this.playerId}`);
                onDisconnect(playerRef).remove();
            }

            async startWave() {
                if (this.isWaveActive) return;

                this.isWaveActive = true;
                this.enemiesSpawned = 0;
                this.startWaveBtn.disabled = true;
                this.startWaveBtn.textContent = 'Wave Active';

                // Enhanced wave progression with special waves
                const baseEnemies = Math.min(5 + this.wave * 2, 40);
                const waveType = this.getWaveType(this.wave);

                switch (waveType) {
                    case 'speed':
                        this.enemiesInWave = baseEnemies + 8;
                        this.showNotification(`üí® Speed Wave ${this.wave}! Fast enemies incoming!`);
                        break;
                    case 'tank':
                        this.enemiesInWave = Math.floor(baseEnemies * 0.6);
                        this.showNotification(`üõ°Ô∏è Tank Wave ${this.wave}! Armored enemies!`);
                        break;
                    case 'boss':
                        this.enemiesInWave = Math.floor(baseEnemies * 0.4) + 1;
                        this.showNotification(`üëπ Boss Wave ${this.wave}! Elite enemies!`);
                        break;
                    case 'swarm':
                        this.enemiesInWave = Math.floor(baseEnemies * 1.5);
                        this.showNotification(`üêú Swarm Wave ${this.wave}! Massive numbers!`);
                        break;
                    default:
                        this.enemiesInWave = baseEnemies;
                        this.showNotification(`üåä Wave ${this.wave} starting! ${this.enemiesInWave} enemies incoming!`);
                }

                this.currentWaveType = waveType;

                // Dynamic spawn rate based on wave type
                let spawnDelay = 1500;
                if (waveType === 'speed' || waveType === 'swarm') {
                    spawnDelay = 800; // Faster spawning
                } else if (waveType === 'tank' || waveType === 'boss') {
                    spawnDelay = 2200; // Slower spawning
                }

                // Spawn enemies with delay (scaled by game speed)
                const spawnInterval = setInterval(() => {
                    if (this.enemiesSpawned >= this.enemiesInWave) {
                        clearInterval(spawnInterval);
                        return;
                    }

                    this.spawnEnemy();
                    this.enemiesSpawned++;
                }, spawnDelay / this.gameSpeed);
            }

            getWaveType(wave) {
                // Special wave types every few waves
                if (wave % 10 === 0) return 'boss';
                if (wave % 7 === 0) return 'tank';
                if (wave % 5 === 0) return 'speed';
                if (wave % 8 === 0) return 'swarm';
                return 'normal';
            }

            selectEnemyType(wave, waveType) {
                let enemyType = 'basic';

                switch (waveType) {
                    case 'speed':
                        enemyType = Math.random() < 0.8 ? 'fast' : 'basic';
                        break;
                    case 'tank':
                        enemyType = Math.random() < 0.7 ? 'tank' : (Math.random() < 0.5 ? 'basic' : 'fast');
                        break;
                    case 'boss':
                        enemyType = Math.random() < 0.4 ? 'boss' : (Math.random() < 0.7 ? 'tank' : 'fast');
                        break;
                    case 'swarm':
                        enemyType = Math.random() < 0.85 ? 'basic' : 'fast';
                        break;
                    default:
                        // Normal wave progression
                        if (wave < 3) {
                            enemyType = 'basic';
                        } else if (wave < 6) {
                            enemyType = Math.random() < 0.7 ? 'basic' : 'fast';
                        } else if (wave < 10) {
                            const rand = Math.random();
                            if (rand < 0.5) enemyType = 'basic';
                            else if (rand < 0.8) enemyType = 'fast';
                            else enemyType = 'tank';
                        } else {
                            // Advanced waves include new enemy types
                            const rand = Math.random();
                            if (rand < 0.25) enemyType = 'basic';
                            else if (rand < 0.45) enemyType = 'fast';
                            else if (rand < 0.65) enemyType = 'tank';
                            else if (rand < 0.8) enemyType = 'boss';
                            else if (rand < 0.92) enemyType = 'stealth';
                            else enemyType = 'swarm';
                        }
                }

                return enemyType;
            }

            spawnEnemy() {
                let enemyType = this.selectEnemyType(this.wave, this.currentWaveType || 'normal');

                const enemyId = 'enemy_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                const enemyConfig = this.enemyTypes[enemyType];

                // Create enhanced 3D enemy model
                const enemyGroup = new THREE.Group();

                let mainMesh;
                switch (enemyType) {
                    case 'basic':
                        mainMesh = this.createBasicEnemyModel(enemyConfig.color);
                        break;
                    case 'fast':
                        mainMesh = this.createFastEnemyModel(enemyConfig.color);
                        break;
                    case 'tank':
                        mainMesh = this.createTankEnemyModel(enemyConfig.color);
                        break;
                    case 'boss':
                        mainMesh = this.createBossEnemyModel(enemyConfig.color);
                        break;
                    case 'stealth':
                        mainMesh = this.createStealthEnemyModel(enemyConfig.color);
                        break;
                    case 'swarm':
                        mainMesh = this.createSwarmEnemyModel(enemyConfig.color);
                        break;
                    default:
                        mainMesh = this.createBasicEnemyModel(enemyConfig.color);
                }

                enemyGroup.add(mainMesh);

                // Enhanced health bar with background
                const healthBarBg = new THREE.PlaneGeometry(0.5, 0.08);
                const healthBarBgMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
                const healthBarBackground = new THREE.Mesh(healthBarBg, healthBarBgMaterial);
                healthBarBackground.position.y = 0.6;
                enemyGroup.add(healthBarBackground);

                const healthBarGeometry = new THREE.PlaneGeometry(0.48, 0.06);
                const healthBarMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);
                healthBar.position.set(0, 0.6, 0.001); // Slightly in front of background
                enemyGroup.add(healthBar);

                // Position at start of path
                const startPos = this.pathPoints[0];
                enemyGroup.position.set(startPos.x, startPos.y + 0.2, startPos.z);
                this.scene.add(enemyGroup);

                // Store enemy data with special abilities
                const enemyData = {
                    id: enemyId,
                    type: enemyType,
                    name: enemyConfig.name,
                    mesh: enemyGroup,
                    healthBar: healthBar,
                    healthBarBackground: healthBarBackground,
                    pathIndex: 0,
                    pathProgress: 0,
                    health: enemyConfig.health * (1 + this.wave * 0.1),
                    maxHealth: enemyConfig.health * (1 + this.wave * 0.1),
                    speed: enemyConfig.speed,
                    reward: enemyConfig.reward,
                    slowEffect: 1,
                    // Copy special abilities from config
                    dodge: enemyConfig.dodge,
                    armor: enemyConfig.armor,
                    shield: enemyConfig.shield,
                    shieldActive: enemyConfig.shield || false,
                    regen: enemyConfig.regen,
                    stealth: enemyConfig.stealth,
                    swarm: enemyConfig.swarm
                };

                this.enemies.set(enemyId, enemyData);
            }

            createBasicEnemyModel(color) {
                const group = new THREE.Group();

                // Enhanced main body with metallic sheen
                const bodyGeometry = new THREE.SphereGeometry(0.18, 8, 6);
                const bodyMaterial = new THREE.MeshLambertMaterial({
                    color: color,
                    emissive: new THREE.Color(color).multiplyScalar(0.1)
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                group.add(body);

                // Enhanced spikes with glow effect
                for (let i = 0; i < 8; i++) {
                    const spikeGeometry = new THREE.ConeGeometry(0.04, 0.15, 6);
                    const spikeMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color(color).multiplyScalar(0.8),
                        emissive: new THREE.Color(color).multiplyScalar(0.2)
                    });
                    const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                    const angle = (i / 8) * Math.PI * 2;
                    spike.position.set(Math.cos(angle) * 0.14, 0, Math.sin(angle) * 0.14);
                    spike.rotation.z = -angle + Math.PI / 2;
                    spike.castShadow = true;
                    group.add(spike);
                }

                // Core glow effect
                const coreGeometry = new THREE.SphereGeometry(0.08, 8, 6);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff4444,
                    emissive: 0xff2222,
                    transparent: true,
                    opacity: 0.8
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                group.add(core);

                return group;
            }

            createFastEnemyModel(color) {
                const group = new THREE.Group();

                // Enhanced sleek body
                const bodyGeometry = new THREE.ConeGeometry(0.15, 0.4, 12);
                const bodyMaterial = new THREE.MeshLambertMaterial({
                    color: color,
                    emissive: new THREE.Color(color).multiplyScalar(0.2)
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.2;
                body.castShadow = true;
                group.add(body);

                // Aerodynamic fins
                for (let i = 0; i < 4; i++) {
                    const finGeometry = new THREE.ConeGeometry(0.03, 0.12, 3);
                    const finMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color(color).multiplyScalar(0.7)
                    });
                    const fin = new THREE.Mesh(finGeometry, finMaterial);
                    const angle = (i / 4) * Math.PI * 2;
                    fin.position.set(Math.cos(angle) * 0.1, 0.1, Math.sin(angle) * 0.1);
                    fin.rotation.z = angle;
                    fin.castShadow = true;
                    group.add(fin);
                }

                // Enhanced speed trails with energy effect
                for (let i = 0; i < 5; i++) {
                    const trailGeometry = new THREE.ConeGeometry(0.06 - i * 0.01, 0.25, 6);
                    const trailMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(0.1 + i * 0.05, 1, 0.5),
                        transparent: true,
                        opacity: 0.8 - i * 0.15,
                        emissive: new THREE.Color().setHSL(0.1 + i * 0.05, 1, 0.3)
                    });
                    const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                    trail.position.y = -0.15 - i * 0.12;
                    trail.scale.setScalar(0.9 - i * 0.15);
                    group.add(trail);
                }

                return group;
            }

            createTankEnemyModel(color) {
                const group = new THREE.Group();

                // Enhanced main body with battle damage
                const bodyGeometry = new THREE.BoxGeometry(0.35, 0.25, 0.3);
                const bodyMaterial = new THREE.MeshLambertMaterial({
                    color: color,
                    emissive: new THREE.Color(color).multiplyScalar(0.1)
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                group.add(body);

                // Heavy armor plates
                const plateGeometry = new THREE.BoxGeometry(0.37, 0.08, 0.32);
                const plateMaterial = new THREE.MeshLambertMaterial({
                    color: 0x333333,
                    emissive: 0x111111
                });
                const topPlate = new THREE.Mesh(plateGeometry, plateMaterial);
                topPlate.position.y = 0.165;
                topPlate.castShadow = true;
                group.add(topPlate);

                // Enhanced side armor with detail
                for (let i = 0; i < 2; i++) {
                    const sideGeometry = new THREE.BoxGeometry(0.08, 0.3, 0.35);
                    const sideMaterial = new THREE.MeshLambertMaterial({
                        color: 0x444444,
                        emissive: 0x111111
                    });
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.x = i === 0 ? -0.215 : 0.215;
                    side.castShadow = true;
                    group.add(side);
                }

                // Tank treads/tracks
                for (let i = 0; i < 2; i++) {
                    const trackGeometry = new THREE.BoxGeometry(0.06, 0.12, 0.4);
                    const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
                    const track = new THREE.Mesh(trackGeometry, trackMaterial);
                    track.position.x = i === 0 ? -0.25 : 0.25;
                    track.position.y = -0.18;
                    track.castShadow = true;
                    group.add(track);
                }

                // Command antenna
                const antennaGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.15, 4);
                const antennaMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.y = 0.32;
                group.add(antenna);

                return group;
            }

            createBossEnemyModel(color) {
                const group = new THREE.Group();

                // Main body (octahedron)
                const bodyGeometry = new THREE.OctahedronGeometry(0.2);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                group.add(body);

                // Rotating energy ring
                const ringGeometry = new THREE.TorusGeometry(0.3, 0.02, 8, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.8
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.userData.rotationSpeed = 0.05;
                group.add(ring);

                // Crown spikes
                for (let i = 0; i < 8; i++) {
                    const spikeGeometry = new THREE.ConeGeometry(0.03, 0.15, 4);
                    const spikeMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                    const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                    const angle = (i / 8) * Math.PI * 2;
                    spike.position.set(Math.cos(angle) * 0.15, 0.2, Math.sin(angle) * 0.15);
                    spike.rotation.z = -angle;
                    group.add(spike);
                }

                return group;
            }

            createStealthEnemyModel(color) {
                const group = new THREE.Group();

                // Sleek, low-profile design
                const bodyGeometry = new THREE.ConeGeometry(0.15, 0.25, 6);
                const bodyMaterial = new THREE.MeshLambertMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.x = Math.PI;
                group.add(body);

                // Stealth field effect
                const fieldGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const fieldMaterial = new THREE.MeshBasicMaterial({
                    color: 0x202040,
                    transparent: true,
                    opacity: 0.2,
                    wireframe: true
                });
                const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
                group.add(field);

                return group;
            }

            createSwarmEnemyModel(color) {
                const group = new THREE.Group();

                // Small, simple design for swarm units
                const bodyGeometry = new THREE.TetrahedronGeometry(0.12, 0);
                const bodyMaterial = new THREE.MeshLambertMaterial({
                    color: color,
                    emissive: new THREE.Color(color).multiplyScalar(0.3)
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);

                // Small energy trail
                const trailGeometry = new THREE.SphereGeometry(0.05, 4, 4);
                const trailMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(color).multiplyScalar(1.5),
                    transparent: true,
                    opacity: 0.6
                });
                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                trail.position.z = -0.2;
                group.add(trail);

                return group;
            }

            moveEnemies() {
                try {
                    const enemiesToRemove = [];

                    for (const [enemyId, enemy] of this.enemies) {
                        try {
                            // Safety checks
                            if (!enemy || !enemy.mesh || enemy.pathIndex === undefined) {
                                enemiesToRemove.push(enemyId);
                                continue;
                            }

                            // Move along path (scaled by game speed)
                            enemy.pathProgress += (enemy.speed || 0.01) * (enemy.slowEffect || 1) * this.gameSpeed;

                            if (enemy.pathProgress >= 1) {
                                enemy.pathIndex++;
                                enemy.pathProgress = 0;
                            }

                            if (enemy.pathIndex >= this.pathPoints.length - 1) {
                                // Enemy reached the end
                                this.lives--;
                                enemiesToRemove.push(enemyId);
                                if (enemy.mesh.parent) {
                                    this.scene.remove(enemy.mesh);
                                }
                                this.showNotification(`üíî Enemy reached base! Lives: ${this.lives}`);

                                if (this.lives <= 0) {
                                    this.gameOver();
                                }
                                continue;
                            }

                            // Interpolate position between path points
                            const currentPoint = this.pathPoints[enemy.pathIndex];
                            const nextPoint = this.pathPoints[enemy.pathIndex + 1];

                            if (!currentPoint || !nextPoint) {
                                enemiesToRemove.push(enemyId);
                                continue;
                            }

                            const position = new THREE.Vector3();
                            position.lerpVectors(
                                new THREE.Vector3(currentPoint.x, currentPoint.y + 0.2, currentPoint.z),
                                new THREE.Vector3(nextPoint.x, nextPoint.y + 0.2, nextPoint.z),
                                enemy.pathProgress
                            );

                            enemy.mesh.position.copy(position);

                            // Update health bar safely
                            if (enemy.healthBar && enemy.maxHealth > 0) {
                                const healthPercent = Math.max(0, enemy.health / enemy.maxHealth);
                                enemy.healthBar.scale.x = healthPercent;
                                enemy.healthBar.position.x = (1 - healthPercent) * 0.24;
                                enemy.healthBar.material.color.setRGB(1 - healthPercent, healthPercent, 0);

                                if (this.camera && enemy.healthBar.lookAt) {
                                    enemy.healthBar.lookAt(this.camera.position);
                                    if (enemy.healthBarBackground) {
                                        enemy.healthBarBackground.lookAt(this.camera.position);
                                    }
                                }
                            }

                            // Animate enemy models safely
                            this.animateEnemyModel(enemy);

                            // Reset slow effect (scaled by game speed)
                            enemy.slowEffect = Math.min(1, (enemy.slowEffect || 1) + 0.02 * this.gameSpeed);
                        } catch (error) {
                            console.warn('Enemy movement error:', error);
                            enemiesToRemove.push(enemyId);
                        }
                    }

                    // Clean up enemies marked for removal
                    enemiesToRemove.forEach(id => {
                        this.enemies.delete(id);
                    });
                } catch (error) {
                    console.error('moveEnemies error:', error);
                }
            }

            animateEnemyModel(enemy) {
                // Animate based on enemy type - only animate the main model (first child)
                const time = Date.now() * 0.001;
                const mainModel = enemy.mesh.children[0]; // The actual enemy model

                if (!mainModel) return;

                switch (enemy.type) {
                    case 'basic':
                        // Animate the main sphere and its spikes
                        if (mainModel.children[0]) {
                            mainModel.children[0].position.y = Math.sin(time * 3) * 0.05;
                        }
                        // Rotate spikes
                        for (let i = 1; i < mainModel.children.length; i++) {
                            if (mainModel.children[i]) {
                                mainModel.children[i].rotation.y = time + i;
                            }
                        }
                        break;
                    case 'fast':
                        // Fast spinning
                        mainModel.rotation.y = time * 4;
                        // Animate speed trails
                        for (let i = 1; i < mainModel.children.length; i++) {
                            if (mainModel.children[i] && mainModel.children[i].material) {
                                mainModel.children[i].material.opacity = 0.3 + Math.sin(time * 5 + i) * 0.2;
                            }
                        }
                        break;
                    case 'tank':
                        // Slow heavy movement
                        mainModel.rotation.y = time * 0.5;
                        break;
                    case 'boss':
                        // Rotating energy ring and oscillating body
                        if (mainModel.children[1]) {
                            mainModel.children[1].rotation.y = time * 2;
                        }
                        if (mainModel.children[0]) {
                            mainModel.children[0].rotation.x = Math.sin(time) * 0.2;
                            mainModel.children[0].rotation.z = Math.cos(time) * 0.2;
                        }
                        break;
                }
            }

            towerShooting() {
                try {
                    const now = Date.now();

                    for (const [towerId, tower] of this.towers) {
                        try {
                            // Safety checks
                            if (!tower || !tower.position || !tower.mesh) continue;

                            // Skip booster towers as they don't shoot
                            if (tower.type === 'booster') continue;

                            // Get boosted stats for this tower
                            const boostedStats = this.getBoostedTowerStats(tower);
                            if (!boostedStats) continue;

                            if (now - (tower.lastFired || 0) < (boostedStats.fireRate || 1000) / this.gameSpeed) continue;

                            // Find nearest enemy in range
                            let target = null;
                            let nearestDistance = Infinity;

                            for (const [enemyId, enemy] of this.enemies) {
                                try {
                                    if (!enemy || !enemy.mesh || !enemy.mesh.position) continue;

                                    const distance = tower.position.distanceTo(enemy.mesh.position);

                                    if (distance <= (boostedStats.range || 3) && distance < nearestDistance) {
                                        nearestDistance = distance;
                                        target = enemy;
                                    }
                                } catch (error) {
                                    console.warn('Enemy targeting error:', error);
                                }
                            }

                            if (target) {
                                this.createTargetingBeam(tower, target);
                                this.fireTower(tower, target);
                                tower.lastFired = now;
                            } else {
                                this.removeTargetingBeam(tower);
                            }
                        } catch (error) {
                            console.warn('Tower shooting error:', error);
                        }
                    }
                } catch (error) {
                    console.error('towerShooting error:', error);
                }
            }

            createTargetingBeam(tower, target) {
                // Remove existing beam
                this.removeTargetingBeam(tower);

                // Create new targeting beam
                const startPos = tower.position.clone();
                startPos.y += 1.2;
                const endPos = target.mesh.position.clone();

                const distance = startPos.distanceTo(endPos);
                const beamGeometry = new THREE.CylinderGeometry(0.02, 0.02, distance, 8);
                const beamMaterial = new THREE.MeshBasicMaterial({
                    color: tower.color,
                    transparent: true,
                    opacity: 0.6
                });
                const beam = new THREE.Mesh(beamGeometry, beamMaterial);

                // Position and orient beam
                beam.position.copy(startPos);
                beam.position.lerp(endPos, 0.5);
                beam.lookAt(endPos);
                beam.rotateX(Math.PI / 2);

                this.scene.add(beam);
                tower.targetBeam = beam;

                // Animate beam
                const animateBeam = () => {
                    if (tower.targetBeam === beam && this.enemies.has(target.id)) {
                        const time = Date.now() * 0.01;
                        beam.material.opacity = 0.3 + Math.sin(time) * 0.3;
                        requestAnimationFrame(animateBeam);
                    }
                };
                animateBeam();
            }

            removeTargetingBeam(tower) {
                if (tower.targetBeam) {
                    this.scene.remove(tower.targetBeam);
                    tower.targetBeam = null;
                }
            }

            fireTower(tower, enemy) {
                // Track shots fired
                tower.shotsFired = (tower.shotsFired || 0) + 1;

                // Create muzzle flash effect
                this.createMuzzleFlash(tower);

                // Create enhanced projectiles based on tower type
                let projectileGroup, projectileSpeed = 0.08; // Much slower base speed

                switch (tower.type) {
                    case 'basic':
                        projectileGroup = this.createBasicProjectile();
                        projectileSpeed = 0.1;
                        break;
                    case 'sniper':
                        projectileGroup = this.createSniperLaser(tower.position, enemy.mesh.position);
                        projectileSpeed = 0.25; // Still faster but more visible
                        break;
                    case 'splash':
                        projectileGroup = this.createMortarShell();
                        projectileSpeed = 0.06; // Very slow for mortar
                        break;
                    case 'slow':
                        projectileGroup = this.createSlowProjectile();
                        projectileSpeed = 0.12;
                        break;
                    default:
                        projectileGroup = this.createBasicProjectile();
                }

                projectileGroup.position.copy(tower.position);
                projectileGroup.position.y += 1.2; // Fire from tower top
                this.scene.add(projectileGroup);

                const projectileId = 'proj_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                // Get boosted damage for this tower
                const boostedStats = this.getBoostedTowerStats(tower);

                const projectileData = {
                    id: projectileId,
                    mesh: projectileGroup,
                    target: enemy,
                    tower: tower,
                    speed: projectileSpeed,
                    damage: boostedStats.damage,
                    trailParticles: []
                };

                this.projectiles.set(projectileId, projectileData);
            }

            createBasicProjectile() {
                const group = new THREE.Group();

                // Main projectile
                const geometry = new THREE.SphereGeometry(0.1, 8, 6);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00aaff,
                    emissive: 0x0055aa
                });
                const projectile = new THREE.Mesh(geometry, material);
                group.add(projectile);

                // Glowing aura
                const auraGeometry = new THREE.SphereGeometry(0.15, 8, 6);
                const auraMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0088ff,
                    transparent: true,
                    opacity: 0.3
                });
                const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                group.add(aura);

                return group;
            }

            createSniperLaser(startPos, targetPos) {
                const group = new THREE.Group();

                // Laser beam
                const distance = startPos.distanceTo(targetPos);
                const geometry = new THREE.CylinderGeometry(0.02, 0.02, distance, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    emissive: 0xffaa00,
                    transparent: true,
                    opacity: 0.8
                });
                const laser = new THREE.Mesh(geometry, material);

                // Position and orient the laser
                laser.position.y = distance / 2;
                laser.lookAt(targetPos);
                group.add(laser);

                // Bright core
                const coreGeometry = new THREE.SphereGeometry(0.05, 6, 4);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff88,
                    emissive: 0xffff44
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                group.add(core);

                return group;
            }

            createMortarShell() {
                const group = new THREE.Group();

                // Simpler shell body - reduced complexity
                const shellGeometry = new THREE.SphereGeometry(0.12, 8, 6);
                const shellMaterial = new THREE.MeshLambertMaterial({
                    color: 0x444444
                });
                const shell = new THREE.Mesh(shellGeometry, shellMaterial);
                group.add(shell);

                // Simple flame trail - single layer
                const flameGeometry = new THREE.ConeGeometry(0.08, 0.3, 6);
                const flameMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff4400,
                    transparent: true,
                    opacity: 0.8
                });
                const flame = new THREE.Mesh(flameGeometry, flameMaterial);
                flame.position.y = -0.2;
                flame.rotation.x = Math.PI;
                group.add(flame);

                return group;
            }

            createSlowProjectile() {
                const group = new THREE.Group();

                // Crystal core
                const geometry = new THREE.OctahedronGeometry(0.08);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xaa44ff,
                    emissive: 0x4411aa,
                    transparent: true,
                    opacity: 0.9
                });
                const crystal = new THREE.Mesh(geometry, material);
                group.add(crystal);

                // Rotating energy rings
                for (let i = 0; i < 3; i++) {
                    const ringGeometry = new THREE.TorusGeometry(0.1 + i * 0.03, 0.01, 4, 8);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: 0x8844ff,
                        transparent: true,
                        opacity: 0.5 - i * 0.1
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.random() * Math.PI;
                    ring.rotation.y = Math.random() * Math.PI;
                    ring.userData.rotationSpeed = 0.05 + Math.random() * 0.05;
                    group.add(ring);
                }

                return group;
            }

            createMuzzleFlash(tower) {
                const flashGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const flashMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.8
                });
                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                flash.position.copy(tower.position);
                flash.position.y += 1.3;
                this.scene.add(flash);

                // Animate flash
                let scale = 0;
                const animateFlash = () => {
                    scale += 0.3;
                    flash.scale.setScalar(scale);
                    flash.material.opacity -= 0.15;

                    if (flash.material.opacity <= 0) {
                        this.scene.remove(flash);
                    } else {
                        requestAnimationFrame(animateFlash);
                    }
                };
                animateFlash();
            }

            createProjectileTrail(projectile, type) {
                // Create simple particle trail effect
                const trailGeometry = new THREE.SphereGeometry(0.02, 4, 3);
                let trailMaterial;

                if (type === 'sniper') {
                    trailMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffff88,
                        transparent: true,
                        opacity: 0.6
                    });
                } else if (type === 'splash') {
                    trailMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff8844,
                        transparent: true,
                        opacity: 0.4
                    });
                }

                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                trail.position.copy(projectile.position);
                this.scene.add(trail);

                // Animate trail fade out
                let opacity = 0.6;
                const fadeTrail = () => {
                    opacity -= 0.05;
                    trail.material.opacity = opacity;
                    if (opacity <= 0) {
                        this.scene.remove(trail);
                    } else {
                        requestAnimationFrame(fadeTrail);
                    }
                };
                setTimeout(fadeTrail, 100);
            }

            moveProjectiles() {
                try {
                    const projectilesToRemove = [];

                    for (const [projectileId, projectile] of this.projectiles) {
                        try {
                            // Safety checks
                            if (!projectile || !projectile.mesh || !projectile.target) {
                                projectilesToRemove.push(projectileId);
                                continue;
                            }

                            if (!this.enemies.has(projectile.target.id)) {
                                // Target is gone, remove projectile
                                if (projectile.mesh.parent) {
                                    this.scene.remove(projectile.mesh);
                                }
                                projectilesToRemove.push(projectileId);
                                continue;
                            }

                            // Animate special projectile effects
                            this.animateProjectileEffects(projectile);

                            const target = projectile.target.mesh.position;
                            const direction = new THREE.Vector3().subVectors(target, projectile.mesh.position);
                            const distance = direction.length();

                            if (distance < 0.3) {
                                // Hit target
                                this.projectileHit(projectile);
                                if (projectile.mesh.parent) {
                                    this.scene.remove(projectile.mesh);
                                }
                                projectilesToRemove.push(projectileId);
                            } else {
                                // Move towards target (scaled by game speed)
                                direction.normalize();
                                projectile.mesh.position.add(direction.multiplyScalar(projectile.speed * this.gameSpeed));

                                // Create trail particles for moving projectiles
                                if (Math.random() < 0.3) { // Reduce frequency to prevent errors
                                    this.createProjectileParticleTrail(projectile);
                                }
                            }
                        } catch (error) {
                            console.warn('Projectile error:', error);
                            projectilesToRemove.push(projectileId);
                        }
                    }

                    // Clean up projectiles marked for removal
                    projectilesToRemove.forEach(id => {
                        this.projectiles.delete(id);
                    });
                } catch (error) {
                    console.error('moveProjectiles error:', error);
                }
            }

            animateProjectileEffects(projectile) {
                // Animate slow projectile rings
                if (projectile.tower.type === 'slow') {
                    projectile.mesh.children.forEach((child, index) => {
                        if (index > 0) { // Skip main crystal
                            child.rotation.x += child.userData.rotationSpeed;
                            child.rotation.y += child.userData.rotationSpeed * 0.7;
                        }
                    });
                }

                // Animate mortar flame
                if (projectile.tower.type === 'splash') {
                    const flame = projectile.mesh.children[1];
                    if (flame) {
                        flame.scale.y = 0.8 + Math.sin(Date.now() * 0.01) * 0.2;
                    }
                }
            }

            createProjectileParticleTrail(projectile) {
                // Create trail particles for enhanced visual effect
                if (Math.random() < 0.3) { // Only create trail sometimes to avoid performance issues
                    const trailGeometry = new THREE.SphereGeometry(0.02, 4, 3);
                    let trailMaterial;

                    switch (projectile.tower.type) {
                        case 'basic':
                            trailMaterial = new THREE.MeshBasicMaterial({
                                color: 0x0088ff,
                                transparent: true,
                                opacity: 0.6
                            });
                            break;
                        case 'splash':
                            trailMaterial = new THREE.MeshBasicMaterial({
                                color: 0xff6600,
                                transparent: true,
                                opacity: 0.5
                            });
                            break;
                        case 'slow':
                            trailMaterial = new THREE.MeshBasicMaterial({
                                color: 0x8844ff,
                                transparent: true,
                                opacity: 0.4
                            });
                            break;
                        default:
                            return; // No trail for sniper (already has beam)
                    }

                    const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                    trail.position.copy(projectile.mesh.position);
                    this.scene.add(trail);

                    // Animate trail fade out
                    let opacity = trailMaterial.opacity;
                    const fadeTrail = () => {
                        opacity -= 0.05;
                        trail.material.opacity = opacity;
                        if (opacity <= 0) {
                            this.scene.remove(trail);
                        } else {
                            requestAnimationFrame(fadeTrail);
                        }
                    };
                    fadeTrail();
                }
            }

            projectileHit(projectile) {
                // Create explosion effect
                this.createExplosion(projectile.mesh.position);

                // Apply damage
                if (projectile.tower.splash) {
                    // Splash damage
                    for (const [enemyId, enemy] of this.enemies) {
                        const distance = projectile.mesh.position.distanceTo(enemy.mesh.position);
                        if (distance <= projectile.tower.splash) {
                            this.damageEnemy(enemy, projectile.damage, projectile.tower);
                        }
                    }
                } else {
                    // Single target damage
                    if (this.enemies.has(projectile.target.id)) {
                        this.damageEnemy(projectile.target, projectile.damage, projectile.tower);
                    }
                }
            }

            createExplosion(position) {
                // Enhanced explosion effect with particles
                const explosionGroup = new THREE.Group();

                // Main explosion sphere
                const explosionGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const explosionMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6b35,
                    transparent: true,
                    opacity: 0.8
                });
                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosionGroup.add(explosion);

                // Add particle sparks
                for (let i = 0; i < 8; i++) {
                    const sparkGeometry = new THREE.SphereGeometry(0.05, 4, 3);
                    const sparkMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffaa44,
                        transparent: true,
                        opacity: 1
                    });
                    const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);

                    // Random direction
                    const angle = (i / 8) * Math.PI * 2;
                    spark.position.set(
                        Math.cos(angle) * 0.2,
                        Math.random() * 0.2,
                        Math.sin(angle) * 0.2
                    );
                    spark.userData.velocity = {
                        x: Math.cos(angle) * 0.05,
                        y: Math.random() * 0.05,
                        z: Math.sin(angle) * 0.05
                    };
                    explosionGroup.add(spark);
                }

                explosionGroup.position.copy(position);
                this.scene.add(explosionGroup);

                // Animate explosion with enhanced effects
                let scale = 0;
                let time = 0;
                const animateExplosion = () => {
                    time += 0.1;
                    scale += 0.15;

                    // Main explosion scaling and fading
                    explosion.scale.setScalar(scale);
                    explosion.material.opacity = Math.max(0, 0.8 - time * 2);

                    // Animate sparks
                    explosionGroup.children.forEach((child, index) => {
                        if (index > 0) { // Skip main explosion
                            child.position.add(new THREE.Vector3(
                                child.userData.velocity.x,
                                child.userData.velocity.y,
                                child.userData.velocity.z
                            ));
                            child.material.opacity = Math.max(0, 1 - time * 3);
                            child.userData.velocity.y -= 0.002; // Gravity
                        }
                    });

                    if (explosion.material.opacity <= 0) {
                        this.scene.remove(explosionGroup);
                    } else {
                        requestAnimationFrame(animateExplosion);
                    }
                };
                animateExplosion();
            }

            damageEnemy(enemy, damage, tower) {
                // Apply power-up damage boost
                let finalDamage = damage;
                if (this.activePowerUps && this.activePowerUps.damageBoost && Date.now() < this.activePowerUps.damageBoost) {
                    finalDamage = Math.floor(damage * 1.5);
                }

                // Apply enemy special abilities
                if (enemy.dodge && Math.random() < enemy.dodge) {
                    this.showNotification(`üí® ${enemy.name || 'Enemy'} dodged!`);
                    return; // Attack missed
                }

                if (enemy.armor) {
                    finalDamage = Math.floor(finalDamage * (1 - enemy.armor));
                }

                if (enemy.shield && enemy.shieldActive) {
                    enemy.shieldActive = false;
                    this.showNotification(`üõ°Ô∏è ${enemy.name || 'Enemy'} shield broken!`);
                    return; // Shield absorbed the hit
                }

                enemy.health -= finalDamage;

                // Update tower stats
                tower.totalDamage = (tower.totalDamage || 0) + finalDamage;

                // Apply slow effect
                if (tower.slow) {
                    enemy.slowEffect = tower.slow;
                    this.createSlowEffect(enemy);
                }

                // Create damage effect
                this.createDamageEffect(enemy.mesh.position, finalDamage);

                if (enemy.health <= 0) {
                    // Update tower kill count
                    tower.kills = (tower.kills || 0) + 1;
                    this.totalKills++;

                    // Create death effect before removing enemy
                    this.createDeathEffect(enemy);

                    // Enemy killed - check for power-up drop
                    const shouldDropPowerUp = Math.random() < 0.15; // 15% chance
                    if (shouldDropPowerUp) {
                        this.createPowerUp(enemy.mesh.position.clone());
                    }

                    // Bonus rewards for combo kills
                    let goldBonus = enemy.reward;
                    let scoreBonus = enemy.reward * 10;

                    if (this.killCombo > 0) {
                        const comboMultiplier = Math.min(1 + (this.killCombo * 0.1), 3.0);
                        goldBonus = Math.floor(enemy.reward * comboMultiplier);
                        scoreBonus = Math.floor(enemy.reward * 10 * comboMultiplier);
                        this.showNotification(`üî• ${this.killCombo}x COMBO! +$${goldBonus}`);
                    } else {
                        this.showNotification(`üí∞ +$${goldBonus}`);
                    }

                    this.killCombo++;
                    this.comboTimer = 3000; // 3 seconds to maintain combo

                    // Apply power-up modifiers
                    if (this.activePowerUps && this.activePowerUps.goldBoost && Date.now() < this.activePowerUps.goldBoost) {
                        goldBonus *= 2;
                    }

                    this.gold += goldBonus;
                    this.currentScore += scoreBonus;
                    this.enemies.delete(enemy.id);
                    this.scene.remove(enemy.mesh);
                }

                // Update tower info panel if this tower is selected
                if (this.selectedTower && this.selectedTower.id === tower.id) {
                    this.updateTowerInfoPanel(tower);
                }
            }

            createDamageEffect(position, damage) {
                // Create floating damage number
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 64;
                canvas.height = 32;

                context.fillStyle = '#ff4444';
                context.font = 'bold 20px Arial';
                context.textAlign = 'center';
                context.fillText('-' + damage, 32, 24);

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(material);
                sprite.position.copy(position);
                sprite.position.y += 0.5;
                sprite.scale.set(0.5, 0.25, 1);
                this.scene.add(sprite);

                // Animate damage number
                let time = 0;
                const animateDamage = () => {
                    time += 0.1;
                    sprite.position.y += 0.02;
                    sprite.material.opacity = Math.max(0, 1 - time);
                    sprite.scale.setScalar(1 + time * 0.5);

                    if (sprite.material.opacity <= 0) {
                        this.scene.remove(sprite);
                    } else {
                        requestAnimationFrame(animateDamage);
                    }
                };
                animateDamage();
            }

            createDeathEffect(enemy) {
                const position = enemy.mesh.position.clone();
                const deathGroup = new THREE.Group();

                // Simple particle-only death effect that doesn't block anything
                const isBoss = enemy.type === 'boss';
                const particleCount = this.performanceMode ? (isBoss ? 8 : 5) : (isBoss ? 12 : 8);

                // Tiny particle sparks that don't block visibility
                for (let i = 0; i < particleCount; i++) {
                    // Use very small spheres as particles
                    const fragmentGeometry = new THREE.SphereGeometry(0.015, 3, 3);
                    const fragmentMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(
                            Math.random() * 0.1 + (isBoss ? 0.7 : 0.0), // Purple for boss, red-orange for normal
                            0.9,
                            0.6 + Math.random() * 0.3
                        ),
                        transparent: true,
                        opacity: 1
                    });

                    const fragment = new THREE.Mesh(fragmentGeometry, fragmentMaterial);

                    // Compact particle spread - keeps effects localized
                    const angle = (i / particleCount) * Math.PI * 2 + Math.random() * 0.3;
                    const elevation = Math.random() * Math.PI / 6 - Math.PI / 12;
                    const speed = 0.05 + Math.random() * 0.08;
                    const radius = 0.05 + Math.random() * 0.15;

                    fragment.position.set(
                        Math.cos(angle) * radius,
                        Math.random() * 0.2,
                        Math.sin(angle) * radius
                    );

                    fragment.userData.velocity = {
                        x: Math.cos(angle) * Math.cos(elevation) * speed,
                        y: Math.sin(elevation) * speed + Math.random() * 0.1,
                        z: Math.sin(angle) * Math.cos(elevation) * speed
                    };
                    fragment.userData.angularVelocity = {
                        x: (Math.random() - 0.5) * 0.3,
                        y: (Math.random() - 0.5) * 0.3,
                        z: (Math.random() - 0.5) * 0.3
                    };
                    fragment.userData.startTime = Math.random() * 0.3; // Stagger appearance
                    deathGroup.add(fragment);
                }

                // Add energy shockwave
                const shockwaveGeometry = new THREE.RingGeometry(0.1, baseSize * 2, 16);
                const shockwaveMaterial = new THREE.MeshBasicMaterial({
                    color: isBoss ? 0xffffff : 0xffff88,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
                shockwave.rotation.x = -Math.PI / 2;
                shockwave.position.y = 0.1;
                deathGroup.add(shockwave);

                // Add simple electrical sparks for boss
                if (isBoss) {
                    for (let i = 0; i < 4; i++) {
                        const sparkGeometry = new THREE.SphereGeometry(0.04, 4, 3);
                        const sparkMaterial = new THREE.MeshBasicMaterial({
                            color: 0x88ddff,
                            transparent: true,
                            opacity: 0.8
                        });
                        const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                        spark.position.set(
                            (Math.random() - 0.5) * 1.0,
                            Math.random() * 0.6,
                            (Math.random() - 0.5) * 1.0
                        );
                        spark.userData.sparkDelay = Math.random() * 0.3;
                        deathGroup.add(spark);
                    }
                }

                deathGroup.position.copy(position);
                this.scene.add(deathGroup);

                // Enhanced animation
                let time = 0;
                const animateDeath = () => {
                    time += 0.05;

                    // Animate explosion rings
                    deathGroup.children.forEach((child, index) => {
                        if (child.userData.ringIndex !== undefined) {
                            const ringDelay = child.userData.ringIndex * 0.15;
                            const ringTime = Math.max(0, time - ringDelay);
                            child.scale.setScalar(1 + ringTime * 4);
                            child.material.opacity = Math.max(0, (0.9 - child.userData.ringIndex * 0.2) - ringTime * 2);
                        }
                    });

                    // Animate shockwave
                    if (shockwave) {
                        shockwave.scale.setScalar(1 + time * 8);
                        shockwave.material.opacity = Math.max(0, 0.6 - time * 1.5);
                    }

                    // Enhanced fragment animation
                    deathGroup.children.forEach((child) => {
                        if (child.userData.velocity && time > child.userData.startTime) {
                            const effectiveTime = time - child.userData.startTime;

                            // Movement with physics
                            child.position.add(new THREE.Vector3(
                                child.userData.velocity.x,
                                child.userData.velocity.y,
                                child.userData.velocity.z
                            ));

                            // Apply gravity and air resistance
                            child.userData.velocity.y -= 0.008;
                            child.userData.velocity.x *= 0.995;
                            child.userData.velocity.z *= 0.995;

                            // Rotation
                            child.rotation.x += child.userData.angularVelocity.x;
                            child.rotation.y += child.userData.angularVelocity.y;
                            child.rotation.z += child.userData.angularVelocity.z;

                            // Fade and shrink
                            child.material.opacity = Math.max(0, 1 - effectiveTime * 1.2);
                            child.scale.setScalar(Math.max(0.1, 1 - effectiveTime * 0.8));
                        }

                        // Animate sparks
                        if (child.userData.sparkDelay !== undefined && time > child.userData.sparkDelay) {
                            child.material.opacity = Math.max(0, 0.8 - (time - child.userData.sparkDelay) * 3);
                            child.rotation.z += 0.2;
                        }
                    });

                    // Remove when done
                    if (time > 3.0) {
                        this.scene.remove(deathGroup);
                    } else {
                        requestAnimationFrame(animateDeath);
                    }
                };
                animateDeath();
            }

            createSlowEffect(enemy) {
                // Remove any existing slow effect
                if (enemy.slowIndicator) {
                    enemy.mesh.remove(enemy.slowIndicator);
                }

                // Create ice/frost visual effect
                const slowGroup = new THREE.Group();

                // Ice crystals around the enemy - reduced count
                for (let i = 0; i < 4; i++) {
                    const crystalGeometry = new THREE.ConeGeometry(0.05, 0.15, 4);
                    const crystalMaterial = new THREE.MeshBasicMaterial({
                        color: 0x88ccff,
                        transparent: true,
                        opacity: 0.7
                    });
                    const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);

                    const angle = (i / 4) * Math.PI * 2;
                    crystal.position.set(
                        Math.cos(angle) * 0.6,
                        0.2 + Math.random() * 0.4,
                        Math.sin(angle) * 0.6
                    );
                    crystal.rotation.y = angle;
                    crystal.userData.floatOffset = Math.random() * Math.PI * 2;
                    slowGroup.add(crystal);
                }

                // Frost aura ring
                const auraGeometry = new THREE.RingGeometry(0.4, 0.7, 16);
                const auraMaterial = new THREE.MeshBasicMaterial({
                    color: 0x66aaff,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                aura.rotation.x = -Math.PI / 2;
                aura.position.y = 0.05;
                slowGroup.add(aura);

                // Swirling snow particles - reduced count
                for (let i = 0; i < 6; i++) {
                    const snowGeometry = new THREE.SphereGeometry(0.02, 4, 3);
                    const snowMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.8
                    });
                    const snow = new THREE.Mesh(snowGeometry, snowMaterial);

                    const radius = 0.3 + Math.random() * 0.4;
                    const angle = Math.random() * Math.PI * 2;
                    snow.position.set(
                        Math.cos(angle) * radius,
                        0.1 + Math.random() * 0.6,
                        Math.sin(angle) * radius
                    );
                    snow.userData.orbitAngle = angle;
                    snow.userData.orbitRadius = radius;
                    snow.userData.orbitSpeed = 0.02 + Math.random() * 0.02;
                    slowGroup.add(snow);
                }

                enemy.mesh.add(slowGroup);
                enemy.slowIndicator = slowGroup;

                // Animate the slow effect
                let time = 0;
                const animateSlowEffect = () => {
                    if (!enemy.slowIndicator || enemy.slowEffect >= 0.9) {
                        // Remove effect when enemy is no longer slowed
                        if (enemy.slowIndicator) {
                            enemy.mesh.remove(enemy.slowIndicator);
                            enemy.slowIndicator = null;
                        }
                        return;
                    }

                    time += 0.05;

                    // Animate crystals
                    slowGroup.children.forEach((child, index) => {
                        if (child.userData.floatOffset !== undefined) {
                            // Ice crystals bob up and down
                            child.position.y = 0.2 + Math.sin(time * 3 + child.userData.floatOffset) * 0.1;
                            child.rotation.y += 0.01;
                        }

                        if (child.userData.orbitAngle !== undefined) {
                            // Snow particles orbit
                            child.userData.orbitAngle += child.userData.orbitSpeed;
                            child.position.x = Math.cos(child.userData.orbitAngle) * child.userData.orbitRadius;
                            child.position.z = Math.sin(child.userData.orbitAngle) * child.userData.orbitRadius;
                            child.position.y = 0.1 + Math.sin(time * 2 + child.userData.orbitAngle) * 0.2;
                        }
                    });

                    // Pulse the aura
                    if (aura) {
                        aura.material.opacity = 0.2 + Math.sin(time * 4) * 0.15;
                        aura.rotation.z += 0.005;
                    }

                    requestAnimationFrame(animateSlowEffect);
                };
                animateSlowEffect();
            }

            checkWaveCompletion() {
                if (this.isWaveActive && this.enemiesSpawned >= this.enemiesInWave && this.enemies.size === 0) {
                    // Wave completed
                    this.isWaveActive = false;
                    this.wave++;
                    this.gold += 20;
                    this.currentScore += (this.wave - 1) * 100;
                    this.startWaveBtn.disabled = false;
                    this.startWaveBtn.textContent = 'Start Wave';

                    this.showNotification(`üéâ Wave ${this.wave - 1} completed! +$20 bonus`);
                    this.nextWaveTimer = 30;
                    this.updateLeaderboardEntry();

                    // Auto-save progress every 5 waves
                    if ((this.wave - 1) % 5 === 0) {
                        setTimeout(() => this.saveGame(), 2000);
                    }
                }
            }

            startNextWaveTimer() {
                setInterval(() => {
                    if (!this.isWaveActive && this.nextWaveTimer > 0) {
                        this.nextWaveTimer -= this.gameSpeed;
                        this.nextWaveTime.textContent = Math.ceil(this.nextWaveTimer) + 's';

                        if (this.nextWaveTimer <= 0) {
                            this.startWave();
                            this.nextWaveTimer = 30;
                        }
                    }
                }, 1000);
            }

            startGameLoop() {
                const gameLoop = () => {
                    try {
                        if (this.gameRunning) {
                            this.moveEnemies();
                            this.towerShooting();
                            this.moveProjectiles();
                            this.animateTowerUpgrades();
                            this.checkWaveCompletion();
                            this.checkAchievements();
                            this.updateUI();
                            this.cleanupOldObjects();
                            this.updateSpecialEffects(); // New optimization
                        }
                    } catch (error) {
                        console.error('Game loop error:', error);
                        // Enhanced error recovery - less intrusive notifications
                        if (this.errorCount < 3) {
                            this.errorCount = (this.errorCount || 0) + 1;
                        } else {
                            this.showNotification('‚ö†Ô∏è Multiple errors detected - consider refreshing');
                        }
                    }

                    if (this.gameRunning) {
                        requestAnimationFrame(gameLoop);
                    }
                };
                this.gameRunning = true;
                gameLoop();
            }

            updateSpecialEffects() {
                // Consolidated special effects update for better performance
                try {
                    // Update enemy regeneration for boss types
                    for (const [id, enemy] of this.enemies) {
                        if (enemy.regen && Math.random() < 0.02) { // 2% chance per frame
                            enemy.health = Math.min(enemy.maxHealth, enemy.health + enemy.regen);
                        }

                        // Handle stealth effects
                        if (enemy.stealth && enemy.mesh) {
                            const stealthActive = Math.random() < enemy.stealth;
                            enemy.mesh.material.opacity = stealthActive ? 0.3 : 1.0;
                        }

                        // Reset shield for boss enemies periodically
                        if (enemy.shield && !enemy.shieldActive && Math.random() < 0.005) { // 0.5% chance
                            enemy.shieldActive = true;
                            this.createShieldEffect(enemy);
                        }
                    }
                } catch (error) {
                    console.error('Special effects update error:', error);
                }
            }

            createShieldEffect(enemy) {
                // Simple shield visual effect
                if (!enemy.mesh) return;

                const shieldGeometry = new THREE.SphereGeometry(0.6, 8, 8);
                const shieldMaterial = new THREE.MeshBasicMaterial({
                    color: 0x4444ff,
                    transparent: true,
                    opacity: 0.3,
                    wireframe: true
                });

                const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                shield.position.copy(enemy.mesh.position);
                this.scene.add(shield);

                // Animate shield appearance
                let opacity = 0.3;
                const animateShield = () => {
                    opacity -= 0.01;
                    shield.material.opacity = opacity;
                    shield.rotation.y += 0.1;

                    if (opacity <= 0) {
                        this.scene.remove(shield);
                    } else {
                        requestAnimationFrame(animateShield);
                    }
                };
                animateShield();
            }

            updateUI() {
                this.playerGoldDisplay.textContent = this.gold;
                this.playerLivesDisplay.textContent = this.lives;
                this.currentWaveDisplay.textContent = this.wave;
                this.playerScoreDisplay.textContent = this.currentScore.toLocaleString();
                this.enemiesLeft.textContent = this.enemies.size;

                // Update wave progress
                if (this.isWaveActive && this.enemiesInWave > 0) {
                    const progress = ((this.enemiesInWave - this.enemies.size) / this.enemiesInWave) * 100;
                    this.waveFill.style.width = Math.max(0, progress) + '%';
                } else {
                    this.waveFill.style.width = '0%';
                }

                // Update tower button states
                Object.keys(this.towerTypes).forEach(type => {
                    const btn = document.getElementById(type + 'TowerBtn');
                    const tower = this.towerTypes[type];
                    btn.disabled = this.gold < tower.cost;
                });
            }

            setCameraView(view) {
                this.isFreeCam = false;
                this.freeCamInstructions.style.display = 'none';

                switch (view) {
                    case 'top':
                        this.camera.position.set(0, 15, 0);
                        this.camera.lookAt(0, 0, 0);
                        break;
                    case 'angle':
                        this.camera.position.set(0, 10, 8);
                        this.camera.lookAt(0, 0, 0);
                        break;
                    case 'free':
                        this.isFreeCam = true;
                        this.cameraRotation = { x: 0, y: 0 };
                        this.freeCamInstructions.style.display = 'block';
                        break;
                }
            }

            handleKeyDown(e) {
                if (e.key === 'Escape') {
                    this.selectedTowerType = null;
                    this.hidePlacementGrid();
                    document.querySelectorAll('.tower-btn').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                } else if (e.key >= '1' && e.key <= '8') {
                    const types = ['basic', 'sniper', 'splash', 'slow', 'laser', 'poison', 'electric', 'booster'];
                    this.selectTowerType(types[parseInt(e.key) - 1]);
                } else if (e.key === 'u' && this.selectedTower) {
                    this.upgradeTower();
                } else if (e.key === 'd' && this.selectedTower) {
                    this.downgradeTower();
                } else if (e.key === 's' && this.selectedTower) {
                    this.sellTower();
                } else if (e.key === 'm' && this.selectedTower) {
                    this.moveTower();
                } else if (e.key === 'Enter' || e.key === ' ') {
                    this.startWave();
                } else if (e.key === 'F5' || (e.ctrlKey && e.key === 's')) {
                    e.preventDefault();
                    this.saveGame();
                } else if (e.key === 'F9' || (e.ctrlKey && e.key === 'l')) {
                    e.preventDefault();
                    this.loadGame();
                } else if (e.key === 'h' || e.key === '?') {
                    this.showHelpMessage();
                } else if (e.key === 'p') {
                    this.togglePause();
                }

                // Free camera controls
                if (this.isFreeCam) {
                    this.cameraKeys.add(e.key.toLowerCase());

                    // FOV/Perspective controls
                    if (e.key === '=' || e.key === '+') {
                        this.camera.fov = Math.max(10, this.camera.fov - 5);
                        this.camera.updateProjectionMatrix();
                    } else if (e.key === '-' || e.key === '_') {
                        this.camera.fov = Math.min(120, this.camera.fov + 5);
                        this.camera.updateProjectionMatrix();
                    }
                }
            }

            handleKeyUp(e) {
                if (this.isFreeCam) {
                    this.cameraKeys.delete(e.key.toLowerCase());
                }
            }

            handleMouseDown(e) {
                if (this.isFreeCam && e.button === 0) {
                    this.mouseDown = true;
                    this.lastMouse = { x: e.clientX, y: e.clientY };
                    this.canvas.requestPointerLock();
                }
            }

            handleMouseUp(e) {
                if (this.isFreeCam) {
                    this.mouseDown = false;
                }
            }

            handleMouseMove(e) {
                if (this.isFreeCam && document.pointerLockElement === this.canvas) {
                    const sensitivity = 0.002;
                    this.cameraRotation.y -= e.movementX * sensitivity;
                    this.cameraRotation.x -= e.movementY * sensitivity;

                    // Clamp vertical rotation
                    this.cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.cameraRotation.x));

                    // Apply rotation to camera
                    this.camera.rotation.order = 'YXZ';
                    this.camera.rotation.y = this.cameraRotation.y;
                    this.camera.rotation.x = this.cameraRotation.x;
                }
            }

            handleWheel(e) {
                if (this.isFreeCam) {
                    e.preventDefault();
                    const direction = new THREE.Vector3(0, 0, -1);
                    direction.applyQuaternion(this.camera.quaternion);
                    direction.multiplyScalar(-e.deltaY * 0.01); // Inverted for natural zoom
                    this.camera.position.add(direction);
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                // Performance monitoring
                this.frameCount++;
                const now = Date.now();
                if (this.frameCount % 60 === 0) { // Check every 60 frames
                    const fps = 60000 / (now - this.lastFrameTime);
                    this.performanceMode = fps < 30; // Enable performance mode if FPS drops below 30
                    this.lastFrameTime = now;
                }

                // Update combo timer
                if (this.comboTimer > 0) {
                    this.comboTimer -= 16; // Assuming ~60fps, 16ms per frame
                    if (this.comboTimer <= 0) {
                        this.killCombo = 0;
                    }
                }

                // Update power-ups
                this.updatePowerUps();

                // Update free camera
                if (this.isFreeCam) {
                    this.updateFreeCamera();
                }

                this.renderer.render(this.scene, this.camera);
            }

            updateFreeCamera() {
                const moveSpeed = 0.15;

                // Get camera direction vectors
                const forward = new THREE.Vector3(0, 0, -1);
                const right = new THREE.Vector3(1, 0, 0);
                const up = new THREE.Vector3(0, 1, 0);

                forward.applyQuaternion(this.camera.quaternion);
                right.applyQuaternion(this.camera.quaternion);

                const movement = new THREE.Vector3();

                // Forward/Backward movement (W/S and Arrow Up/Down)
                if (this.cameraKeys.has('w') || this.cameraKeys.has('arrowup')) {
                    movement.add(forward);
                }
                if (this.cameraKeys.has('s') || this.cameraKeys.has('arrowdown')) {
                    movement.add(forward.clone().negate());
                }

                // Left/Right movement (A/D and Arrow Left/Right)
                if (this.cameraKeys.has('a') || this.cameraKeys.has('arrowleft')) {
                    movement.add(right.clone().negate());
                }
                if (this.cameraKeys.has('d') || this.cameraKeys.has('arrowright')) {
                    movement.add(right);
                }

                // Up/Down movement (Space/Shift)
                if (this.cameraKeys.has(' ')) {
                    movement.add(up);
                }
                if (this.cameraKeys.has('shift')) {
                    movement.add(up.clone().negate());
                }

                // Apply movement
                if (movement.length() > 0) {
                    movement.normalize();
                    movement.multiplyScalar(moveSpeed);
                    this.camera.position.add(movement);
                }
            }

            setGameSpeed(speed) {
                this.gameSpeed = speed;

                // Update speed button states
                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(`speed${speed}x`).classList.add('active');
            }

            onWindowResize() {
                const width = window.innerWidth;
                const height = window.innerHeight - 80;

                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }

            createPowerUp(position) {
                const powerUpTypes = [
                    { type: 'goldBoost', color: 0xffd700, duration: 15000, effect: 'üí∞ Double Gold' },
                    { type: 'speedBoost', color: 0x00ffff, duration: 10000, effect: '‚ö° Speed Boost' },
                    { type: 'damageBoost', color: 0xff4444, duration: 12000, effect: 'üî• Damage Boost' },
                    { type: 'shield', color: 0x4444ff, duration: 8000, effect: 'üõ°Ô∏è Shield' }
                ];

                const powerUpType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                const powerUpId = this.nextPowerUpId++;

                // Create power-up visual
                const geometry = new THREE.OctahedronGeometry(0.2);
                const material = new THREE.MeshPhongMaterial({
                    color: powerUpType.color,
                    emissive: powerUpType.color,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.8
                });

                const powerUpMesh = new THREE.Mesh(geometry, material);
                powerUpMesh.position.copy(position);
                powerUpMesh.position.y += 0.5;

                // Add floating animation data
                powerUpMesh.userData.floatOffset = Math.random() * Math.PI * 2;
                powerUpMesh.userData.rotationSpeed = (Math.random() - 0.5) * 0.1;

                this.scene.add(powerUpMesh);

                // Store power-up data
                this.powerUps.set(powerUpId, {
                    id: powerUpId,
                    mesh: powerUpMesh,
                    type: powerUpType.type,
                    effect: powerUpType.effect,
                    duration: powerUpType.duration,
                    spawnTime: Date.now(),
                    collected: false
                });

                // Auto-remove after 30 seconds if not collected
                setTimeout(() => {
                    if (this.powerUps.has(powerUpId)) {
                        const powerUp = this.powerUps.get(powerUpId);
                        if (!powerUp.collected) {
                            this.scene.remove(powerUp.mesh);
                            this.powerUps.delete(powerUpId);
                        }
                    }
                }, 30000);
            }

            updatePowerUps() {
                const time = Date.now() * 0.001;

                for (const [id, powerUp] of this.powerUps) {
                    if (powerUp.collected) continue;

                    // Floating animation
                    powerUp.mesh.position.y = powerUp.mesh.position.y + Math.sin(time * 2 + powerUp.mesh.userData.floatOffset) * 0.002;
                    powerUp.mesh.rotation.y += powerUp.mesh.userData.rotationSpeed;

                    // Check for player collision (simplified)
                    const distance = powerUp.mesh.position.distanceTo(new THREE.Vector3(0, 0, 0));
                    if (distance < 1.0) {
                        this.collectPowerUp(powerUp);
                    }
                }
            }

            collectPowerUp(powerUp) {
                if (powerUp.collected) return;

                powerUp.collected = true;
                this.showNotification(`‚ú® ${powerUp.effect} collected!`);

                // Apply power-up effect
                switch (powerUp.type) {
                    case 'goldBoost':
                        this.activePowerUps = this.activePowerUps || {};
                        this.activePowerUps.goldBoost = Date.now() + powerUp.duration;
                        break;
                    case 'speedBoost':
                        this.gameSpeed = Math.min(this.gameSpeed * 1.5, 10);
                        setTimeout(() => {
                            this.gameSpeed = Math.max(this.gameSpeed / 1.5, 1);
                        }, powerUp.duration);
                        break;
                    case 'damageBoost':
                        this.activePowerUps = this.activePowerUps || {};
                        this.activePowerUps.damageBoost = Date.now() + powerUp.duration;
                        break;
                    case 'shield':
                        this.activePowerUps = this.activePowerUps || {};
                        this.activePowerUps.shield = Date.now() + powerUp.duration;
                        break;
                }

                // Create collection effect
                this.createPowerUpCollectionEffect(powerUp.mesh.position);

                // Remove from scene
                this.scene.remove(powerUp.mesh);
                this.powerUps.delete(powerUp.id);
            }

            createPowerUpCollectionEffect(position) {
                // Create sparkle effect
                for (let i = 0; i < 8; i++) {
                    const sparkGeometry = new THREE.SphereGeometry(0.03);
                    const sparkMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 1
                    });
                    const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);

                    const angle = (i / 8) * Math.PI * 2;
                    spark.position.copy(position);
                    spark.userData.velocity = {
                        x: Math.cos(angle) * 0.1,
                        y: Math.random() * 0.15 + 0.05,
                        z: Math.sin(angle) * 0.1
                    };

                    this.scene.add(spark);

                    // Animate spark
                    let time = 0;
                    const animateSpark = () => {
                        time += 0.05;
                        spark.position.x += spark.userData.velocity.x;
                        spark.position.y += spark.userData.velocity.y;
                        spark.position.z += spark.userData.velocity.z;
                        spark.userData.velocity.y -= 0.005; // Gravity
                        spark.material.opacity = Math.max(0, 1 - time);

                        if (spark.material.opacity <= 0) {
                            this.scene.remove(spark);
                        } else {
                            requestAnimationFrame(animateSpark);
                        }
                    };
                    animateSpark();
                }
            }

            // Leaderboard functions (simplified)
            async loadLeaderboard() {
                try {
                    const leaderboardRef = ref(database, 'leaderboard');
                    onValue(leaderboardRef, (snapshot) => {
                        if (snapshot.exists()) {
                            const data = snapshot.val();
                            this.leaderboard = Object.values(data).sort((a, b) => b.score - a.score);
                            this.updateLeaderboardDisplay();
                        }
                    });
                } catch (error) {
                    console.error('Failed to load leaderboard:', error);
                }
            }

            startLeaderboardSync() {
                setInterval(() => {
                    this.updateLeaderboardEntry();
                }, 10000);
            }

            async updateLeaderboardEntry() {
                try {
                    const leaderboardRef = ref(database, `leaderboard/${this.playerId}`);
                    await set(leaderboardRef, {
                        name: this.playerName,
                        score: this.currentScore,
                        wave: this.wave,
                        gold: this.gold,
                        lives: this.lives,
                        lastUpdated: serverTimestamp()
                    });
                } catch (error) {
                    console.error('Failed to update leaderboard:', error);
                }
            }

            updateLeaderboardDisplay() {
                this.leaderboardList.innerHTML = '';

                this.leaderboard.slice(0, 10).forEach((player, index) => {
                    const entry = document.createElement('div');
                    entry.className = 'leaderboard-entry';

                    if (player.name === this.playerName) {
                        entry.classList.add('current-player');
                    }

                    let rankIcon = '';
                    if (index === 0) rankIcon = '<span class="crown">üëë</span>';
                    else if (index === 1) rankIcon = '<span class="medal">ü•à</span>';
                    else if (index === 2) rankIcon = '<span class="bronze">ü•â</span>';

                    entry.innerHTML = `
                        <div class="player-rank">${rankIcon}${index + 1}</div>
                        <div class="player-info">
                            <div>${player.name}</div>
                            <div class="player-stats">Wave ${player.wave} ‚Ä¢ $${player.gold}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-weight: bold; color: #00f5ff;">${player.score.toLocaleString()}</div>
                            <div style="font-size: 0.7rem; opacity: 0.7;">‚ù§Ô∏è${player.lives}</div>
                        </div>
                    `;

                    this.leaderboardList.appendChild(entry);
                });
            }

            async gameOver() {
                await this.updateLeaderboardEntry();

                const gameOverDiv = document.createElement('div');
                gameOverDiv.className = 'game-over';
                gameOverDiv.innerHTML = `
                    <h1>GAME OVER</h1>
                    <p>You reached wave ${this.wave}</p>
                    <p>Final Score: <span style="color: #00f5ff; font-weight: bold;">${this.currentScore.toLocaleString()}</span></p>
                    <p>Gold Earned: $${this.gold}</p>
                    <button class="btn btn-primary" onclick="location.reload()">Play Again</button>
                `;
                this.gameContainer.appendChild(gameOverDiv);
            }

            showNotification(message) {
                // Enhanced notification system with different types
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.innerHTML = message; // Use innerHTML to support emojis and formatting

                // Add special styling for different notification types
                if (message.includes('COMBO')) {
                    notification.style.background = 'linear-gradient(135deg, #ff6b6b, #ffa500)';
                    notification.style.animation = 'pulse 0.5s ease-in-out';
                } else if (message.includes('Achievement') || message.includes('üèÜ')) {
                    notification.style.background = 'linear-gradient(135deg, #ffd700, #ffed4e)';
                    notification.style.color = '#333';
                    notification.style.fontWeight = 'bold';
                } else if (message.includes('‚ú®') || message.includes('collected')) {
                    notification.style.background = 'linear-gradient(135deg, #00f5ff, #0080ff)';
                }

                document.body.appendChild(notification);

                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 2500);
            }

            showError(message) {
                this.nameError.textContent = message;
                this.nameError.style.display = 'block';
                setTimeout(() => {
                    this.nameError.style.display = 'none';
                }, 5000);
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            new TowerDefense3D();
        });
    </script>
</body>
</html>