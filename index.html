<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tower Defense - Multiplayer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #2d1b69 100%);
            color: white;
            overflow: hidden;
        }

        .game-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .name-prompt {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #2d1b69 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .name-card {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
            padding: 3rem;
            border-radius: 20px;
            text-align: center;
            border: 2px solid rgba(0, 245, 255, 0.3);
            min-width: 400px;
        }

        .name-title {
            font-size: 2rem;
            font-weight: 800;
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 2rem;
        }

        .input-group {
            margin: 1rem 0;
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #00f5ff;
            font-weight: 600;
        }

        .input-group input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        .input-group input:focus {
            outline: none;
            border-color: #00f5ff;
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
        }

        .connection-status {
            margin: 1rem 0;
            padding: 0.5rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-connected {
            color: #4ade80;
            background: rgba(74, 222, 128, 0.1);
        }

        .status-disconnected {
            color: #f87171;
            background: rgba(248, 113, 113, 0.1);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00f5ff;
            animation: blink 2s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            position: relative;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stats {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem 1rem;
            border-radius: 25px;
            backdrop-filter: blur(5px);
        }

        .stat-value {
            font-weight: 700;
            color: #00f5ff;
        }

        #gameCanvas {
            display: block;
            background: radial-gradient(circle, #1a2332 0%, #0f1419 100%);
        }

        .game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .tower-menu {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            pointer-events: auto;
        }

        .tower-btn {
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            min-width: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            pointer-events: auto;
        }

        .tower-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .tower-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .tower-btn.basic {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
        }

        .tower-btn.sniper {
            background: linear-gradient(135deg, #5cb85c, #449d44);
            color: white;
        }

        .tower-btn.splash {
            background: linear-gradient(135deg, #f0ad4e, #ec971f);
            color: white;
        }

        .tower-btn.slow {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
        }

        .tower-btn.selected {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
        }

        .tower-cost {
            font-size: 0.7rem;
            opacity: 0.9;
        }

        .wave-info {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            min-width: 200px;
            pointer-events: auto;
        }

        .wave-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin: 0.5rem 0;
            overflow: hidden;
        }

        .wave-fill {
            height: 100%;
            background: linear-gradient(90deg, #00f5ff, #0066ff);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .leaderboard {
            position: fixed;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            min-width: 250px;
            max-height: 400px;
            overflow-y: auto;
            pointer-events: auto;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            margin: 0.25rem 0;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .leaderboard-entry:hover {
            background: rgba(0, 245, 255, 0.1);
            transform: translateX(5px);
        }

        .leaderboard-entry.current-player {
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
        }

        .player-rank {
            font-weight: bold;
            color: #00f5ff;
            min-width: 30px;
        }

        .player-info {
            flex: 1;
            margin: 0 0.5rem;
        }

        .player-stats {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .crown {
            color: #ffd700;
            margin-right: 0.25rem;
        }

        .medal {
            color: #c0c0c0;
            margin-right: 0.25rem;
        }

        .bronze {
            color: #cd7f32;
            margin-right: 0.25rem;
        }

        .camera-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 0.5rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            pointer-events: auto;
        }

        .camera-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0.25rem;
            display: block;
            width: 100%;
        }

        .camera-btn:hover {
            background: rgba(0, 245, 255, 0.2);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            pointer-events: auto;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .notification {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            border-radius: 15px;
            text-align: center;
            z-index: 1001;
            animation: notification-appear 0.3s ease-out;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }

        @keyframes notification-appear {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .game-over h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: #e74c3c;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00f5ff;
            font-size: 1.2rem;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <!-- Name Prompt Screen -->
    <div class="name-prompt" id="namePrompt">
        <div class="name-card">
            <h1 class="name-title">3D TOWER DEFENSE</h1>
            <p style="margin-bottom: 2rem; opacity: 0.8;">Multiplayer Strategy Defense</p>

            <div class="connection-status" id="connectionStatus">
                <div class="status-dot"></div>
                <span>Connecting...</span>
            </div>

            <div class="input-group">
                <label for="playerName">Player Name</label>
                <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
            </div>

            <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                <button class="btn btn-primary" id="joinGameBtn" disabled>Join Game</button>
            </div>

            <div id="nameError" style="color: #f87171; margin-top: 1rem; display: none;"></div>
        </div>
    </div>

    <!-- Game Screen -->
    <div class="game-container" id="gameContainer" style="display: none;">
        <div class="header">
            <div class="logo">3D TOWER DEFENSE</div>
            <div class="stats">
                <div class="stat-item">
                    <span>💰</span>
                    <span class="stat-value" id="playerGold">100</span>
                </div>
                <div class="stat-item">
                    <span>❤️</span>
                    <span class="stat-value" id="playerLives">20</span>
                </div>
                <div class="stat-item">
                    <span>Wave:</span>
                    <span class="stat-value" id="currentWave">1</span>
                </div>
                <div class="stat-item">
                    <span>Score:</span>
                    <span class="stat-value" id="playerScore">0</span>
                </div>
                <div class="connection-status">
                    <div class="status-dot"></div>
                    <span>Online</span>
                </div>
            </div>
        </div>

        <div style="position: relative; flex: 1;">
            <canvas id="gameCanvas"></canvas>
            <div class="loading" id="loadingText">Loading 3D assets...</div>

            <div class="game-ui">
                <div class="tower-menu">
                    <button class="tower-btn basic" id="basicTowerBtn">
                        <span>🔫 Basic</span>
                        <span class="tower-cost">$10</span>
                    </button>
                    <button class="tower-btn sniper" id="sniperTowerBtn">
                        <span>🎯 Sniper</span>
                        <span class="tower-cost">$25</span>
                    </button>
                    <button class="tower-btn splash" id="splashTowerBtn">
                        <span>💥 Splash</span>
                        <span class="tower-cost">$40</span>
                    </button>
                    <button class="tower-btn slow" id="slowTowerBtn">
                        <span>❄️ Slow</span>
                        <span class="tower-cost">$30</span>
                    </button>
                </div>

                <div class="wave-info">
                    <h3 style="margin-bottom: 0.5rem; color: #00f5ff;">Wave Progress</h3>
                    <div class="wave-progress">
                        <div class="wave-fill" id="waveFill" style="width: 0%;"></div>
                    </div>
                    <div style="font-size: 0.9rem; margin-top: 0.5rem;">
                        <div>Enemies: <span id="enemiesLeft">0</span></div>
                        <div>Next Wave: <span id="nextWaveTime">30s</span></div>
                    </div>
                    <button class="btn btn-primary" id="startWaveBtn" style="margin-top: 1rem; width: 100%;">Start Wave</button>
                </div>

                <div class="leaderboard">
                    <h3 style="margin-bottom: 0.5rem; color: #00f5ff;">🏆 Leaderboard</h3>
                    <div id="leaderboardList">
                        <!-- Leaderboard entries will be populated here -->
                    </div>
                </div>

                <div class="camera-controls">
                    <button class="camera-btn" id="topViewBtn">Top View</button>
                    <button class="camera-btn" id="angleViewBtn">Angle View</button>
                    <button class="camera-btn" id="freeViewBtn">Free Camera</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Firebase SDKs -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, onValue, push, remove, onDisconnect, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBLkFMipRS631fDNr8uwgozmxXBnqLd5_o",
            authDomain: "base-control-b391e.firebaseapp.com",
            databaseURL: "https://base-control-b391e-default-rtdb.firebaseio.com/",
            projectId: "base-control-b391e",
            storageBucket: "base-control-b391e.firebasestorage.app",
            messagingSenderId: "116375376675",
            appId: "1:116375376675:web:cdc8688222c7c35accf296",
            measurementId: "G-JY7P6D49HM"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        class TowerDefense3D {
            constructor() {
                this.playerId = this.generatePlayerId();
                this.playerName = '';
                this.roomCode = 'tower-defense-3d';
                this.gameState = null;
                this.isConnected = false;

                // Game state
                this.gold = 100;
                this.lives = 20;
                this.wave = 1;
                this.currentScore = 0;
                this.selectedTowerType = null;
                this.isWaveActive = false;
                this.enemiesInWave = 0;
                this.enemiesSpawned = 0;
                this.nextWaveTimer = 30;
                this.leaderboard = [];

                // 3D Objects
                this.towers = new Map();
                this.enemies = new Map();
                this.projectiles = new Map();

                // Tower types
                this.towerTypes = {
                    basic: { cost: 10, damage: 15, range: 3, fireRate: 1000, color: 0x4a90e2 },
                    sniper: { cost: 25, damage: 40, range: 6, fireRate: 2000, color: 0x5cb85c },
                    splash: { cost: 40, damage: 25, range: 2.5, fireRate: 1500, color: 0xf0ad4e, splash: 1.5 },
                    slow: { cost: 30, damage: 10, range: 3, fireRate: 800, color: 0x9b59b6, slow: 0.5 }
                };

                // Enemy types
                this.enemyTypes = {
                    basic: { health: 50, speed: 0.02, reward: 5, color: 0xe74c3c },
                    fast: { health: 30, speed: 0.04, reward: 8, color: 0xf39c12 },
                    tank: { health: 150, speed: 0.01, reward: 15, color: 0x34495e },
                    boss: { health: 300, speed: 0.015, reward: 50, color: 0x8e44ad }
                };

                // Path waypoints (3D coordinates)
                this.pathPoints = [
                    { x: -8, z: 0, y: 0 },
                    { x: -6, z: 2, y: 0 },
                    { x: -4, z: 3, y: 0 },
                    { x: -2, z: 2, y: 0 },
                    { x: 0, z: 0, y: 0 },
                    { x: 2, z: -2, y: 0 },
                    { x: 4, z: -3, y: 0 },
                    { x: 6, z: -2, y: 0 },
                    { x: 8, z: 0, y: 0 }
                ];

                this.init();
            }

            generatePlayerId() {
                return 'player_' + Math.random().toString(36).substr(2, 9);
            }

            init() {
                this.initializeElements();
                this.bindEvents();
                this.checkConnection();
                this.setupThreeJS();
            }

            initializeElements() {
                this.namePrompt = document.getElementById('namePrompt');
                this.gameContainer = document.getElementById('gameContainer');
                this.connectionStatus = document.getElementById('connectionStatus');
                this.playerNameInput = document.getElementById('playerName');
                this.joinGameBtn = document.getElementById('joinGameBtn');
                this.playerGoldDisplay = document.getElementById('playerGold');
                this.playerLivesDisplay = document.getElementById('playerLives');
                this.currentWaveDisplay = document.getElementById('currentWave');
                this.playerScoreDisplay = document.getElementById('playerScore');
                this.waveFill = document.getElementById('waveFill');
                this.enemiesLeft = document.getElementById('enemiesLeft');
                this.nextWaveTime = document.getElementById('nextWaveTime');
                this.startWaveBtn = document.getElementById('startWaveBtn');
                this.nameError = document.getElementById('nameError');
                this.leaderboardList = document.getElementById('leaderboardList');
                this.loadingText = document.getElementById('loadingText');

                this.basicTowerBtn = document.getElementById('basicTowerBtn');
                this.sniperTowerBtn = document.getElementById('sniperTowerBtn');
                this.splashTowerBtn = document.getElementById('splashTowerBtn');
                this.slowTowerBtn = document.getElementById('slowTowerBtn');

                this.topViewBtn = document.getElementById('topViewBtn');
                this.angleViewBtn = document.getElementById('angleViewBtn');
                this.freeViewBtn = document.getElementById('freeViewBtn');
            }

            bindEvents() {
                this.joinGameBtn.addEventListener('click', () => this.joinGame());
                this.playerNameInput.addEventListener('input', () => this.validateForm());
                this.playerNameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !this.joinGameBtn.disabled) {
                        this.joinGame();
                    }
                });

                this.basicTowerBtn.addEventListener('click', () => this.selectTowerType('basic'));
                this.sniperTowerBtn.addEventListener('click', () => this.selectTowerType('sniper'));
                this.splashTowerBtn.addEventListener('click', () => this.selectTowerType('splash'));
                this.slowTowerBtn.addEventListener('click', () => this.selectTowerType('slow'));

                this.startWaveBtn.addEventListener('click', () => this.startWave());

                this.topViewBtn.addEventListener('click', () => this.setCameraView('top'));
                this.angleViewBtn.addEventListener('click', () => this.setCameraView('angle'));
                this.freeViewBtn.addEventListener('click', () => this.setCameraView('free'));

                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
            }

            async checkConnection() {
                try {
                    const connectedRef = ref(database, '.info/connected');
                    onValue(connectedRef, (snapshot) => {
                        this.isConnected = snapshot.val() === true;
                        this.updateConnectionStatus();
                        this.validateForm();
                    });
                } catch (error) {
                    console.error('Connection failed:', error);
                    this.updateConnectionStatus(false);
                }
            }

            updateConnectionStatus(connected = this.isConnected) {
                const statusElement = this.connectionStatus;
                if (connected) {
                    statusElement.className = 'connection-status status-connected';
                    statusElement.innerHTML = '<div class="status-dot"></div><span>Connected</span>';
                } else {
                    statusElement.className = 'connection-status status-disconnected';
                    statusElement.innerHTML = '<div class="status-dot"></div><span>Connection failed</span>';
                }
            }

            validateForm() {
                const nameValid = this.playerNameInput.value.trim().length > 0;
                const connected = this.isConnected;
                this.joinGameBtn.disabled = !nameValid || !connected;
            }

            setupThreeJS() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0f1419);

                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight - 80), 0.1, 1000);
                this.camera.position.set(0, 10, 8);
                this.camera.lookAt(0, 0, 0);

                // Renderer
                this.canvas = document.getElementById('gameCanvas');
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight - 80);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Lighting
                this.setupLighting();

                // Battlefield
                this.createBattlefield();

                // Raycaster for mouse interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));

                // Start render loop
                this.animate();

                this.loadingText.style.display = 'none';
            }

            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);

                // Directional light (sun)
                this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                this.directionalLight.position.set(10, 20, 5);
                this.directionalLight.castShadow = true;
                this.directionalLight.shadow.mapSize.width = 2048;
                this.directionalLight.shadow.mapSize.height = 2048;
                this.directionalLight.shadow.camera.near = 0.5;
                this.directionalLight.shadow.camera.far = 50;
                this.directionalLight.shadow.camera.left = -20;
                this.directionalLight.shadow.camera.right = 20;
                this.directionalLight.shadow.camera.top = 20;
                this.directionalLight.shadow.camera.bottom = -20;
                this.scene.add(this.directionalLight);

                // Point light for dramatic effect
                const pointLight = new THREE.PointLight(0x00f5ff, 0.5, 30);
                pointLight.position.set(0, 8, 0);
                this.scene.add(pointLight);
            }

            createBattlefield() {
                // Ground plane
                const groundGeometry = new THREE.PlaneGeometry(20, 12);
                const groundMaterial = new THREE.MeshLambertMaterial({
                    color: 0x2d3748,
                    transparent: true,
                    opacity: 0.8
                });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);

                // Grid helper
                const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x444444);
                gridHelper.material.opacity = 0.3;
                gridHelper.material.transparent = true;
                this.scene.add(gridHelper);

                // Path visualization
                this.createPath();
            }

            createPath() {
                const pathGeometry = new THREE.BufferGeometry();
                const pathVertices = [];

                for (let i = 0; i < this.pathPoints.length; i++) {
                    const point = this.pathPoints[i];
                    pathVertices.push(point.x, point.y + 0.1, point.z);
                }

                pathGeometry.setAttribute('position', new THREE.Float32BufferAttribute(pathVertices, 3));

                const pathMaterial = new THREE.LineBasicMaterial({
                    color: 0x8b4513,
                    linewidth: 5
                });

                this.pathLine = new THREE.Line(pathGeometry, pathMaterial);
                this.scene.add(this.pathLine);

                // Add path markers
                this.pathPoints.forEach((point, index) => {
                    const markerGeometry = new THREE.SphereGeometry(0.2, 8, 6);
                    let markerMaterial;

                    if (index === 0) {
                        markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Start - Red
                    } else if (index === this.pathPoints.length - 1) {
                        markerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // End - Green
                    } else {
                        markerMaterial = new THREE.MeshBasicMaterial({ color: 0x8b4513 }); // Path - Brown
                    }

                    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.set(point.x, point.y + 0.3, point.z);
                    this.scene.add(marker);
                });
            }

            handleCanvasClick(event) {
                if (!this.selectedTowerType) return;

                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.ground);

                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const position = intersect.point;

                    // Snap to grid
                    position.x = Math.round(position.x);
                    position.z = Math.round(position.z);
                    position.y = 0;

                    // Check if position is valid (not on path, not occupied)
                    if (this.isValidTowerPosition(position)) {
                        this.placeTower(position, this.selectedTowerType);
                    }
                }
            }

            handleCanvasMouseMove(event) {
                // Add hover effects here if needed
            }

            isValidTowerPosition(position) {
                // Check if position is too close to path
                for (const pathPoint of this.pathPoints) {
                    const distance = Math.sqrt(
                        (position.x - pathPoint.x) ** 2 +
                        (position.z - pathPoint.z) ** 2
                    );
                    if (distance < 1.5) return false;
                }

                // Check if position is occupied by another tower
                for (const tower of this.towers.values()) {
                    const distance = Math.sqrt(
                        (position.x - tower.position.x) ** 2 +
                        (position.z - tower.position.z) ** 2
                    );
                    if (distance < 1) return false;
                }

                // Check bounds
                if (Math.abs(position.x) > 9 || Math.abs(position.z) > 5) return false;

                return true;
            }

            selectTowerType(type) {
                // Clear previous selection
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.classList.remove('selected');
                });

                if (this.selectedTowerType === type) {
                    this.selectedTowerType = null;
                } else {
                    this.selectedTowerType = type;
                    const btn = document.getElementById(type + 'TowerBtn');
                    btn.classList.add('selected');
                }
            }

            placeTower(position, type) {
                const towerConfig = this.towerTypes[type];
                if (this.gold < towerConfig.cost) {
                    this.showNotification('❌ Not enough gold!');
                    return;
                }

                const towerId = 'tower_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);

                // Create 3D tower model
                const towerGroup = new THREE.Group();

                // Base
                const baseGeometry = new THREE.CylinderGeometry(0.4, 0.5, 0.3, 8);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.15;
                base.castShadow = true;
                towerGroup.add(base);

                // Tower body
                const bodyGeometry = new THREE.CylinderGeometry(0.25, 0.35, 0.8, 6);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: towerConfig.color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.7;
                body.castShadow = true;
                towerGroup.add(body);

                // Weapon (different for each type)
                this.addTowerWeapon(towerGroup, type);

                towerGroup.position.copy(position);
                this.scene.add(towerGroup);

                // Store tower data
                const towerData = {
                    id: towerId,
                    type: type,
                    position: position.clone(),
                    mesh: towerGroup,
                    lastFired: 0,
                    ...towerConfig
                };

                this.towers.set(towerId, towerData);
                this.gold -= towerConfig.cost;
                this.updateUI();

                this.showNotification(`🏗️ ${type.charAt(0).toUpperCase() + type.slice(1)} tower placed!`);
                this.selectedTowerType = null;
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.classList.remove('selected');
                });
            }

            addTowerWeapon(towerGroup, type) {
                switch (type) {
                    case 'basic':
                        // Simple cannon
                        const cannonGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.6, 6);
                        const cannonMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                        const cannon = new THREE.Mesh(cannonGeometry, cannonMaterial);
                        cannon.position.y = 1.2;
                        cannon.rotation.z = Math.PI / 2;
                        towerGroup.add(cannon);
                        break;

                    case 'sniper':
                        // Long barrel
                        const barrelGeometry = new THREE.CylinderGeometry(0.03, 0.04, 1.0, 8);
                        const barrelMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e50 });
                        const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                        barrel.position.y = 1.3;
                        barrel.rotation.z = Math.PI / 2;
                        towerGroup.add(barrel);
                        break;

                    case 'splash':
                        // Mortar tube
                        const mortarGeometry = new THREE.CylinderGeometry(0.15, 0.12, 0.4, 6);
                        const mortarMaterial = new THREE.MeshLambertMaterial({ color: 0xd35400 });
                        const mortar = new THREE.Mesh(mortarGeometry, mortarMaterial);
                        mortar.position.y = 1.3;
                        towerGroup.add(mortar);
                        break;

                    case 'slow':
                        // Crystal array
                        for (let i = 0; i < 4; i++) {
                            const crystalGeometry = new THREE.ConeGeometry(0.05, 0.3, 4);
                            const crystalMaterial = new THREE.MeshLambertMaterial({
                                color: 0x9b59b6,
                                transparent: true,
                                opacity: 0.8
                            });
                            const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                            crystal.position.y = 1.2;
                            crystal.position.x = Math.cos(i * Math.PI / 2) * 0.2;
                            crystal.position.z = Math.sin(i * Math.PI / 2) * 0.2;
                            towerGroup.add(crystal);
                        }
                        break;
                }
            }

            async joinGame() {
                this.playerName = this.playerNameInput.value.trim();

                try {
                    // Add player to the game
                    const playerRef = ref(database, `rooms/${this.roomCode}/players/${this.playerId}`);
                    await set(playerRef, {
                        name: this.playerName,
                        gold: this.gold,
                        lives: this.lives,
                        wave: this.wave,
                        score: this.currentScore,
                        connected: true,
                        joinedAt: serverTimestamp()
                    });

                    this.startGame();
                } catch (error) {
                    this.showError('Failed to join game: ' + error.message);
                }
            }

            startGame() {
                this.namePrompt.style.display = 'none';
                this.gameContainer.style.display = 'flex';

                // Set up Firebase listeners
                this.setupGameListeners();
                this.setupDisconnectCleanup();

                // Start game loops
                this.startGameLoop();
                this.startNextWaveTimer();
                this.loadLeaderboard();
                this.startLeaderboardSync();

                // Resize renderer
                this.onWindowResize();
                window.addEventListener('resize', () => this.onWindowResize());
            }

            setupGameListeners() {
                const roomRef = ref(database, `rooms/${this.roomCode}`);
                onValue(roomRef, (snapshot) => {
                    if (snapshot.exists()) {
                        this.gameState = snapshot.val();
                    }
                });
            }

            setupDisconnectCleanup() {
                const playerRef = ref(database, `rooms/${this.roomCode}/players/${this.playerId}`);
                onDisconnect(playerRef).remove();
            }

            async startWave() {
                if (this.isWaveActive) return;

                this.isWaveActive = true;
                this.enemiesInWave = Math.min(5 + this.wave * 2, 30);
                this.enemiesSpawned = 0;
                this.startWaveBtn.disabled = true;
                this.startWaveBtn.textContent = 'Wave Active';

                this.showNotification(`🌊 Wave ${this.wave} starting! ${this.enemiesInWave} enemies incoming!`);

                // Spawn enemies with delay
                const spawnInterval = setInterval(() => {
                    if (this.enemiesSpawned >= this.enemiesInWave) {
                        clearInterval(spawnInterval);
                        return;
                    }

                    this.spawnEnemy();
                    this.enemiesSpawned++;
                }, 1500);
            }

            spawnEnemy() {
                let enemyType;

                // Different enemy types based on wave
                if (this.wave < 3) {
                    enemyType = 'basic';
                } else if (this.wave < 6) {
                    enemyType = Math.random() < 0.7 ? 'basic' : 'fast';
                } else if (this.wave < 10) {
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic';
                    else if (rand < 0.8) enemyType = 'fast';
                    else enemyType = 'tank';
                } else {
                    const rand = Math.random();
                    if (rand < 0.3) enemyType = 'basic';
                    else if (rand < 0.6) enemyType = 'fast';
                    else if (rand < 0.9) enemyType = 'tank';
                    else enemyType = 'boss';
                }

                const enemyId = 'enemy_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                const enemyConfig = this.enemyTypes[enemyType];

                // Create 3D enemy model
                const enemyGroup = new THREE.Group();

                let geometry, material;
                switch (enemyType) {
                    case 'basic':
                        geometry = new THREE.SphereGeometry(0.2, 8, 6);
                        break;
                    case 'fast':
                        geometry = new THREE.ConeGeometry(0.2, 0.4, 6);
                        break;
                    case 'tank':
                        geometry = new THREE.BoxGeometry(0.4, 0.3, 0.4);
                        break;
                    case 'boss':
                        geometry = new THREE.OctahedronGeometry(0.3);
                        break;
                }

                material = new THREE.MeshLambertMaterial({ color: enemyConfig.color });
                const enemyMesh = new THREE.Mesh(geometry, material);
                enemyMesh.castShadow = true;
                enemyGroup.add(enemyMesh);

                // Health bar
                const healthBarGeometry = new THREE.PlaneGeometry(0.4, 0.05);
                const healthBarMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);
                healthBar.position.y = 0.5;
                healthBar.lookAt(this.camera.position);
                enemyGroup.add(healthBar);

                // Position at start of path
                const startPos = this.pathPoints[0];
                enemyGroup.position.set(startPos.x, startPos.y + 0.2, startPos.z);
                this.scene.add(enemyGroup);

                // Store enemy data
                const enemyData = {
                    id: enemyId,
                    type: enemyType,
                    mesh: enemyGroup,
                    healthBar: healthBar,
                    pathIndex: 0,
                    pathProgress: 0,
                    health: enemyConfig.health * (1 + this.wave * 0.1),
                    maxHealth: enemyConfig.health * (1 + this.wave * 0.1),
                    speed: enemyConfig.speed,
                    reward: enemyConfig.reward,
                    slowEffect: 1
                };

                this.enemies.set(enemyId, enemyData);
            }

            moveEnemies() {
                for (const [enemyId, enemy] of this.enemies) {
                    // Move along path
                    enemy.pathProgress += enemy.speed * enemy.slowEffect;

                    if (enemy.pathProgress >= 1) {
                        enemy.pathIndex++;
                        enemy.pathProgress = 0;
                    }

                    if (enemy.pathIndex >= this.pathPoints.length - 1) {
                        // Enemy reached the end
                        this.lives--;
                        this.enemies.delete(enemyId);
                        this.scene.remove(enemy.mesh);
                        this.showNotification(`💔 Enemy reached base! Lives: ${this.lives}`);

                        if (this.lives <= 0) {
                            this.gameOver();
                        }
                        continue;
                    }

                    // Interpolate position between path points
                    const currentPoint = this.pathPoints[enemy.pathIndex];
                    const nextPoint = this.pathPoints[enemy.pathIndex + 1];

                    const position = new THREE.Vector3();
                    position.lerpVectors(
                        new THREE.Vector3(currentPoint.x, currentPoint.y + 0.2, currentPoint.z),
                        new THREE.Vector3(nextPoint.x, nextPoint.y + 0.2, nextPoint.z),
                        enemy.pathProgress
                    );

                    enemy.mesh.position.copy(position);

                    // Update health bar
                    const healthPercent = enemy.health / enemy.maxHealth;
                    enemy.healthBar.scale.x = healthPercent;
                    enemy.healthBar.material.color.setRGB(1 - healthPercent, healthPercent, 0);
                    enemy.healthBar.lookAt(this.camera.position);

                    // Reset slow effect
                    enemy.slowEffect = Math.min(1, enemy.slowEffect + 0.02);
                }
            }

            towerShooting() {
                const now = Date.now();

                for (const [towerId, tower] of this.towers) {
                    if (now - tower.lastFired < tower.fireRate) continue;

                    // Find nearest enemy in range
                    let target = null;
                    let nearestDistance = Infinity;

                    for (const [enemyId, enemy] of this.enemies) {
                        const distance = tower.position.distanceTo(enemy.mesh.position);

                        if (distance <= tower.range && distance < nearestDistance) {
                            nearestDistance = distance;
                            target = enemy;
                        }
                    }

                    if (target) {
                        this.fireTower(tower, target);
                        tower.lastFired = now;
                    }
                }
            }

            fireTower(tower, enemy) {
                // Create 3D projectile
                const projectileGeometry = new THREE.SphereGeometry(0.05, 6, 4);
                const projectileMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00f5ff,
                    emissive: 0x004455
                });
                const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);

                projectile.position.copy(tower.position);
                projectile.position.y += 1.2; // Fire from tower top
                this.scene.add(projectile);

                const projectileId = 'proj_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                const projectileData = {
                    id: projectileId,
                    mesh: projectile,
                    target: enemy,
                    tower: tower,
                    speed: 0.3,
                    damage: tower.damage
                };

                this.projectiles.set(projectileId, projectileData);
            }

            moveProjectiles() {
                for (const [projectileId, projectile] of this.projectiles) {
                    if (!this.enemies.has(projectile.target.id)) {
                        // Target is gone, remove projectile
                        this.scene.remove(projectile.mesh);
                        this.projectiles.delete(projectileId);
                        continue;
                    }

                    const target = projectile.target.mesh.position;
                    const direction = new THREE.Vector3().subVectors(target, projectile.mesh.position);
                    const distance = direction.length();

                    if (distance < 0.2) {
                        // Hit target
                        this.projectileHit(projectile);
                        this.scene.remove(projectile.mesh);
                        this.projectiles.delete(projectileId);
                    } else {
                        // Move towards target
                        direction.normalize();
                        projectile.mesh.position.add(direction.multiplyScalar(projectile.speed));
                    }
                }
            }

            projectileHit(projectile) {
                // Create explosion effect
                this.createExplosion(projectile.mesh.position);

                // Apply damage
                if (projectile.tower.splash) {
                    // Splash damage
                    for (const [enemyId, enemy] of this.enemies) {
                        const distance = projectile.mesh.position.distanceTo(enemy.mesh.position);
                        if (distance <= projectile.tower.splash) {
                            this.damageEnemy(enemy, projectile.damage, projectile.tower);
                        }
                    }
                } else {
                    // Single target damage
                    if (this.enemies.has(projectile.target.id)) {
                        this.damageEnemy(projectile.target, projectile.damage, projectile.tower);
                    }
                }
            }

            createExplosion(position) {
                // Simple explosion effect
                const explosionGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const explosionMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6b35,
                    transparent: true,
                    opacity: 0.8
                });
                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosion.position.copy(position);
                this.scene.add(explosion);

                // Animate explosion
                let scale = 0;
                const animateExplosion = () => {
                    scale += 0.1;
                    explosion.scale.setScalar(scale);
                    explosion.material.opacity -= 0.05;

                    if (explosion.material.opacity <= 0) {
                        this.scene.remove(explosion);
                    } else {
                        requestAnimationFrame(animateExplosion);
                    }
                };
                animateExplosion();
            }

            damageEnemy(enemy, damage, tower) {
                enemy.health -= damage;

                // Apply slow effect
                if (tower.slow) {
                    enemy.slowEffect = tower.slow;
                }

                if (enemy.health <= 0) {
                    // Enemy killed
                    this.gold += enemy.reward;
                    this.currentScore += enemy.reward * 10;
                    this.enemies.delete(enemy.id);
                    this.scene.remove(enemy.mesh);
                    this.showNotification(`💰 +$${enemy.reward}`);
                }
            }

            checkWaveCompletion() {
                if (this.isWaveActive && this.enemiesSpawned >= this.enemiesInWave && this.enemies.size === 0) {
                    // Wave completed
                    this.isWaveActive = false;
                    this.wave++;
                    this.gold += 20;
                    this.currentScore += (this.wave - 1) * 100;
                    this.startWaveBtn.disabled = false;
                    this.startWaveBtn.textContent = 'Start Wave';

                    this.showNotification(`🎉 Wave ${this.wave - 1} completed! +$20 bonus`);
                    this.nextWaveTimer = 30;
                    this.updateLeaderboardEntry();
                }
            }

            startNextWaveTimer() {
                setInterval(() => {
                    if (!this.isWaveActive && this.nextWaveTimer > 0) {
                        this.nextWaveTimer--;
                        this.nextWaveTime.textContent = this.nextWaveTimer + 's';

                        if (this.nextWaveTimer === 0) {
                            this.startWave();
                            this.nextWaveTimer = 30;
                        }
                    }
                }, 1000);
            }

            startGameLoop() {
                const gameLoop = () => {
                    this.moveEnemies();
                    this.towerShooting();
                    this.moveProjectiles();
                    this.checkWaveCompletion();
                    this.updateUI();
                    requestAnimationFrame(gameLoop);
                };
                gameLoop();
            }

            updateUI() {
                this.playerGoldDisplay.textContent = this.gold;
                this.playerLivesDisplay.textContent = this.lives;
                this.currentWaveDisplay.textContent = this.wave;
                this.playerScoreDisplay.textContent = this.currentScore.toLocaleString();
                this.enemiesLeft.textContent = this.enemies.size;

                // Update wave progress
                if (this.isWaveActive && this.enemiesInWave > 0) {
                    const progress = ((this.enemiesInWave - this.enemies.size) / this.enemiesInWave) * 100;
                    this.waveFill.style.width = Math.max(0, progress) + '%';
                } else {
                    this.waveFill.style.width = '0%';
                }

                // Update tower button states
                Object.keys(this.towerTypes).forEach(type => {
                    const btn = document.getElementById(type + 'TowerBtn');
                    const tower = this.towerTypes[type];
                    btn.disabled = this.gold < tower.cost;
                });
            }

            setCameraView(view) {
                switch (view) {
                    case 'top':
                        this.camera.position.set(0, 15, 0);
                        this.camera.lookAt(0, 0, 0);
                        break;
                    case 'angle':
                        this.camera.position.set(0, 10, 8);
                        this.camera.lookAt(0, 0, 0);
                        break;
                    case 'free':
                        // Enable orbital controls here
                        break;
                }
            }

            handleKeyDown(e) {
                if (e.key === 'Escape') {
                    this.selectedTowerType = null;
                    document.querySelectorAll('.tower-btn').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                } else if (e.key >= '1' && e.key <= '4') {
                    const types = ['basic', 'sniper', 'splash', 'slow'];
                    this.selectTowerType(types[parseInt(e.key) - 1]);
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.renderer.render(this.scene, this.camera);
            }

            onWindowResize() {
                const width = window.innerWidth;
                const height = window.innerHeight - 80;

                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }

            // Leaderboard functions (simplified)
            async loadLeaderboard() {
                try {
                    const leaderboardRef = ref(database, 'leaderboard');
                    onValue(leaderboardRef, (snapshot) => {
                        if (snapshot.exists()) {
                            const data = snapshot.val();
                            this.leaderboard = Object.values(data).sort((a, b) => b.score - a.score);
                            this.updateLeaderboardDisplay();
                        }
                    });
                } catch (error) {
                    console.error('Failed to load leaderboard:', error);
                }
            }

            startLeaderboardSync() {
                setInterval(() => {
                    this.updateLeaderboardEntry();
                }, 10000);
            }

            async updateLeaderboardEntry() {
                try {
                    const leaderboardRef = ref(database, `leaderboard/${this.playerId}`);
                    await set(leaderboardRef, {
                        name: this.playerName,
                        score: this.currentScore,
                        wave: this.wave,
                        gold: this.gold,
                        lives: this.lives,
                        lastUpdated: serverTimestamp()
                    });
                } catch (error) {
                    console.error('Failed to update leaderboard:', error);
                }
            }

            updateLeaderboardDisplay() {
                this.leaderboardList.innerHTML = '';

                this.leaderboard.slice(0, 10).forEach((player, index) => {
                    const entry = document.createElement('div');
                    entry.className = 'leaderboard-entry';

                    if (player.name === this.playerName) {
                        entry.classList.add('current-player');
                    }

                    let rankIcon = '';
                    if (index === 0) rankIcon = '<span class="crown">👑</span>';
                    else if (index === 1) rankIcon = '<span class="medal">🥈</span>';
                    else if (index === 2) rankIcon = '<span class="bronze">🥉</span>';

                    entry.innerHTML = `
                        <div class="player-rank">${rankIcon}${index + 1}</div>
                        <div class="player-info">
                            <div>${player.name}</div>
                            <div class="player-stats">Wave ${player.wave} • $${player.gold}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-weight: bold; color: #00f5ff;">${player.score.toLocaleString()}</div>
                            <div style="font-size: 0.7rem; opacity: 0.7;">❤️${player.lives}</div>
                        </div>
                    `;

                    this.leaderboardList.appendChild(entry);
                });
            }

            async gameOver() {
                await this.updateLeaderboardEntry();

                const gameOverDiv = document.createElement('div');
                gameOverDiv.className = 'game-over';
                gameOverDiv.innerHTML = `
                    <h1>GAME OVER</h1>
                    <p>You reached wave ${this.wave}</p>
                    <p>Final Score: <span style="color: #00f5ff; font-weight: bold;">${this.currentScore.toLocaleString()}</span></p>
                    <p>Gold Earned: $${this.gold}</p>
                    <button class="btn btn-primary" onclick="location.reload()">Play Again</button>
                `;
                this.gameContainer.appendChild(gameOverDiv);
            }

            showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 2500);
            }

            showError(message) {
                this.nameError.textContent = message;
                this.nameError.style.display = 'block';
                setTimeout(() => {
                    this.nameError.style.display = 'none';
                }, 5000);
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            new TowerDefense3D();
        });
    </script>
</body>
</html>