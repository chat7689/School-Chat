<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense - Multiplayer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #2d1b69 100%);
            min-height: 100vh;
            color: white;
            overflow: hidden;
        }

        .game-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .name-prompt {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #2d1b69 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .name-card {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
            padding: 3rem;
            border-radius: 20px;
            text-align: center;
            border: 2px solid rgba(0, 245, 255, 0.3);
            min-width: 400px;
        }

        .name-title {
            font-size: 2rem;
            font-weight: 800;
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 2rem;
        }

        .input-group {
            margin: 1rem 0;
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #00f5ff;
            font-weight: 600;
        }

        .input-group input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        .input-group input:focus {
            outline: none;
            border-color: #00f5ff;
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
        }

        .connection-status {
            margin: 1rem 0;
            padding: 0.5rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-connected {
            color: #4ade80;
            background: rgba(74, 222, 128, 0.1);
        }

        .status-disconnected {
            color: #f87171;
            background: rgba(248, 113, 113, 0.1);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00f5ff;
            animation: blink 2s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stats {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem 1rem;
            border-radius: 25px;
            backdrop-filter: blur(5px);
        }

        .stat-value {
            font-weight: 700;
            color: #00f5ff;
        }

        .game-field {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: linear-gradient(45deg, #1a2332 0%, #2d3748 50%, #1a2332 100%);
        }

        .game-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            grid-template-rows: repeat(15, 1fr);
            gap: 1px;
        }

        .grid-cell {
            border: 1px solid rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .grid-cell:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: rgba(0, 245, 255, 0.3);
        }

        .grid-cell.path {
            background: rgba(139, 69, 19, 0.3);
            border-color: rgba(139, 69, 19, 0.5);
        }

        .grid-cell.spawn {
            background: rgba(255, 0, 0, 0.3);
            border-color: rgba(255, 0, 0, 0.5);
        }

        .grid-cell.goal {
            background: rgba(0, 255, 0, 0.3);
            border-color: rgba(0, 255, 0, 0.5);
        }

        .grid-cell.occupied {
            background: rgba(255, 255, 255, 0.1);
            cursor: not-allowed;
        }

        .tower {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
        }

        .tower:hover {
            transform: scale(1.1);
        }

        .tower.basic {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            border: 2px solid #2171b5;
        }

        .tower.sniper {
            background: linear-gradient(135deg, #5cb85c, #449d44);
            border: 2px solid #398439;
        }

        .tower.splash {
            background: linear-gradient(135deg, #f0ad4e, #ec971f);
            border: 2px solid #d58512;
        }

        .tower.slow {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            border: 2px solid #7d3c98;
        }

        .enemy {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 8;
            transition: all 0.1s ease;
        }

        .enemy.basic {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            border: 2px solid #a93226;
        }

        .enemy.fast {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            border: 2px solid #d35400;
        }

        .enemy.tank {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            border: 2px solid #1b2631;
            width: 25px;
            height: 25px;
        }

        .enemy.boss {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            border: 2px solid #7d3c98;
            width: 30px;
            height: 30px;
        }

        .health-bar {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 24px;
            height: 3px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 2px;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f1c40f, #2ecc71);
            border-radius: 2px;
            transition: width 0.2s ease;
        }

        .projectile {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #00f5ff;
            border-radius: 50%;
            box-shadow: 0 0 8px #00f5ff;
            z-index: 9;
        }

        .explosion {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff6b35, #f7931e, transparent);
            animation: explode 0.5s ease-out forwards;
            z-index: 15;
        }

        @keyframes explode {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        .tower-menu {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
        }

        .tower-btn {
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            min-width: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }

        .tower-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .tower-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .tower-btn.basic {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
        }

        .tower-btn.sniper {
            background: linear-gradient(135deg, #5cb85c, #449d44);
            color: white;
        }

        .tower-btn.splash {
            background: linear-gradient(135deg, #f0ad4e, #ec971f);
            color: white;
        }

        .tower-btn.slow {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
        }

        .tower-cost {
            font-size: 0.7rem;
            opacity: 0.9;
        }

        .wave-info {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1001;
            min-width: 200px;
        }

        .wave-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin: 0.5rem 0;
            overflow: hidden;
        }

        .wave-fill {
            height: 100%;
            background: linear-gradient(90deg, #00f5ff, #0066ff);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00f5ff, #0066ff);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .notification {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            border-radius: 15px;
            text-align: center;
            z-index: 1001;
            animation: notification-appear 0.3s ease-out;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }

        @keyframes notification-appear {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .game-over h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: #e74c3c;
        }

        .range-indicator {
            position: absolute;
            border: 2px dashed rgba(0, 245, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>
    <!-- Name Prompt Screen -->
    <div class="name-prompt" id="namePrompt">
        <div class="name-card">
            <h1 class="name-title">TOWER DEFENSE</h1>
            <p style="margin-bottom: 2rem; opacity: 0.8;">Multiplayer Strategy Defense</p>

            <div class="connection-status" id="connectionStatus">
                <div class="status-dot"></div>
                <span>Connecting...</span>
            </div>

            <div class="input-group">
                <label for="playerName">Player Name</label>
                <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
            </div>

            <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                <button class="btn btn-primary" id="joinGameBtn" disabled>Join Game</button>
            </div>

            <div id="nameError" style="color: #f87171; margin-top: 1rem; display: none;"></div>
        </div>
    </div>

    <!-- Game Screen -->
    <div class="game-container" id="gameContainer" style="display: none;">
        <div class="header">
            <div class="logo">TOWER DEFENSE</div>
            <div class="stats">
                <div class="stat-item">
                    <span>üí∞</span>
                    <span class="stat-value" id="playerGold">100</span>
                </div>
                <div class="stat-item">
                    <span>‚ù§Ô∏è</span>
                    <span class="stat-value" id="playerLives">20</span>
                </div>
                <div class="stat-item">
                    <span>Wave:</span>
                    <span class="stat-value" id="currentWave">1</span>
                </div>
                <div class="connection-status">
                    <div class="status-dot"></div>
                    <span>Online</span>
                </div>
            </div>
        </div>

        <div class="game-field" id="gameField">
            <div class="game-grid" id="gameGrid">
                <!-- Grid cells will be generated here -->
            </div>
        </div>

        <div class="tower-menu">
            <button class="tower-btn basic" id="basicTowerBtn">
                <span>üî´ Basic</span>
                <span class="tower-cost">$10</span>
            </button>
            <button class="tower-btn sniper" id="sniperTowerBtn">
                <span>üéØ Sniper</span>
                <span class="tower-cost">$25</span>
            </button>
            <button class="tower-btn splash" id="splashTowerBtn">
                <span>üí• Splash</span>
                <span class="tower-cost">$40</span>
            </button>
            <button class="tower-btn slow" id="slowTowerBtn">
                <span>‚ùÑÔ∏è Slow</span>
                <span class="tower-cost">$30</span>
            </button>
        </div>

        <div class="wave-info">
            <h3 style="margin-bottom: 0.5rem; color: #00f5ff;">Wave Progress</h3>
            <div class="wave-progress">
                <div class="wave-fill" id="waveFill" style="width: 0%;"></div>
            </div>
            <div style="font-size: 0.9rem; margin-top: 0.5rem;">
                <div>Enemies: <span id="enemiesLeft">0</span></div>
                <div>Next Wave: <span id="nextWaveTime">30s</span></div>
            </div>
            <button class="btn btn-primary" id="startWaveBtn" style="margin-top: 1rem; width: 100%;">Start Wave</button>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, onValue, push, remove, onDisconnect, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBLkFMipRS631fDNr8uwgozmxXBnqLd5_o",
            authDomain: "base-control-b391e.firebaseapp.com",
            databaseURL: "https://base-control-b391e-default-rtdb.firebaseio.com/",
            projectId: "base-control-b391e",
            storageBucket: "base-control-b391e.firebasestorage.app",
            messagingSenderId: "116375376675",
            appId: "1:116375376675:web:cdc8688222c7c35accf296",
            measurementId: "G-JY7P6D49HM"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // Disable right-click context menu
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            return false;
        });

        class TowerDefenseGame {
            constructor() {
                this.playerId = this.generatePlayerId();
                this.playerName = '';
                this.roomCode = 'tower-defense-room';
                this.gameState = null;
                this.isConnected = false;

                // Game state
                this.gold = 100;
                this.lives = 20;
                this.wave = 1;
                this.selectedTowerType = null;
                this.towers = new Map();
                this.enemies = new Map();
                this.projectiles = new Map();
                this.gameGrid = [];
                this.path = [];
                this.isWaveActive = false;
                this.enemiesInWave = 0;
                this.enemiesSpawned = 0;
                this.nextWaveTimer = 30;

                // Tower types
                this.towerTypes = {
                    basic: { cost: 10, damage: 15, range: 80, fireRate: 1000, icon: 'üî´' },
                    sniper: { cost: 25, damage: 40, range: 150, fireRate: 2000, icon: 'üéØ' },
                    splash: { cost: 40, damage: 25, range: 70, fireRate: 1500, icon: 'üí•', splash: 50 },
                    slow: { cost: 30, damage: 10, range: 90, fireRate: 800, icon: '‚ùÑÔ∏è', slow: 0.5 }
                };

                // Enemy types
                this.enemyTypes = {
                    basic: { health: 50, speed: 1, reward: 5, icon: 'üëæ' },
                    fast: { health: 30, speed: 2, reward: 8, icon: '‚ö°' },
                    tank: { health: 150, speed: 0.5, reward: 15, icon: 'üõ°Ô∏è' },
                    boss: { health: 300, speed: 0.8, reward: 50, icon: 'üíÄ' }
                };

                this.initializeElements();
                this.bindEvents();
                this.checkConnection();
            }

            generatePlayerId() {
                return 'player_' + Math.random().toString(36).substr(2, 9);
            }

            initializeElements() {
                this.namePrompt = document.getElementById('namePrompt');
                this.gameContainer = document.getElementById('gameContainer');
                this.connectionStatus = document.getElementById('connectionStatus');
                this.playerNameInput = document.getElementById('playerName');
                this.joinGameBtn = document.getElementById('joinGameBtn');
                this.gameField = document.getElementById('gameField');
                this.gameGridElement = document.getElementById('gameGrid');
                this.playerGoldDisplay = document.getElementById('playerGold');
                this.playerLivesDisplay = document.getElementById('playerLives');
                this.currentWaveDisplay = document.getElementById('currentWave');
                this.waveFill = document.getElementById('waveFill');
                this.enemiesLeft = document.getElementById('enemiesLeft');
                this.nextWaveTime = document.getElementById('nextWaveTime');
                this.startWaveBtn = document.getElementById('startWaveBtn');
                this.nameError = document.getElementById('nameError');

                this.basicTowerBtn = document.getElementById('basicTowerBtn');
                this.sniperTowerBtn = document.getElementById('sniperTowerBtn');
                this.splashTowerBtn = document.getElementById('splashTowerBtn');
                this.slowTowerBtn = document.getElementById('slowTowerBtn');
            }

            bindEvents() {
                this.joinGameBtn.addEventListener('click', () => this.joinGame());
                this.playerNameInput.addEventListener('input', () => this.validateForm());
                this.playerNameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !this.joinGameBtn.disabled) {
                        this.joinGame();
                    }
                });

                this.basicTowerBtn.addEventListener('click', () => this.selectTowerType('basic'));
                this.sniperTowerBtn.addEventListener('click', () => this.selectTowerType('sniper'));
                this.splashTowerBtn.addEventListener('click', () => this.selectTowerType('splash'));
                this.slowTowerBtn.addEventListener('click', () => this.selectTowerType('slow'));

                this.startWaveBtn.addEventListener('click', () => this.startWave());

                document.addEventListener('click', (e) => this.handleClick(e));
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
            }

            async checkConnection() {
                try {
                    const connectedRef = ref(database, '.info/connected');
                    onValue(connectedRef, (snapshot) => {
                        this.isConnected = snapshot.val() === true;
                        this.updateConnectionStatus();
                        this.validateForm();
                    });
                } catch (error) {
                    console.error('Connection failed:', error);
                    this.updateConnectionStatus(false);
                }
            }

            updateConnectionStatus(connected = this.isConnected) {
                const statusElement = this.connectionStatus;
                if (connected) {
                    statusElement.className = 'connection-status status-connected';
                    statusElement.innerHTML = '<div class="status-dot"></div><span>Connected</span>';
                } else {
                    statusElement.className = 'connection-status status-disconnected';
                    statusElement.innerHTML = '<div class="status-dot"></div><span>Connection failed</span>';
                }
            }

            validateForm() {
                const nameValid = this.playerNameInput.value.trim().length > 0;
                const connected = this.isConnected;
                this.joinGameBtn.disabled = !nameValid || !connected;
            }

            async joinGame() {
                this.playerName = this.playerNameInput.value.trim();

                try {
                    // Add player to the game
                    const playerRef = ref(database, `rooms/${this.roomCode}/players/${this.playerId}`);
                    await set(playerRef, {
                        name: this.playerName,
                        gold: this.gold,
                        lives: this.lives,
                        wave: this.wave,
                        connected: true,
                        joinedAt: serverTimestamp()
                    });

                    this.startGame();
                } catch (error) {
                    this.showError('Failed to join game: ' + error.message);
                }
            }

            startGame() {
                this.namePrompt.style.display = 'none';
                this.gameContainer.style.display = 'flex';

                // Initialize game grid
                this.createGameGrid();
                this.createPath();
                this.renderPath();

                // Set up Firebase listeners
                this.setupGameListeners();

                // Set up disconnect cleanup
                this.setupDisconnectCleanup();

                // Start game loops
                this.startGameLoop();
                this.startNextWaveTimer();
            }

            createGameGrid() {
                this.gameGrid = [];
                this.gameGridElement.innerHTML = '';

                for (let row = 0; row < 15; row++) {
                    this.gameGrid[row] = [];
                    for (let col = 0; col < 20; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        this.gameGridElement.appendChild(cell);
                        this.gameGrid[row][col] = { type: 'empty', element: cell };
                    }
                }
            }

            createPath() {
                // Create a simple path from left to right with some curves
                this.path = [
                    { row: 7, col: 0 }, { row: 7, col: 1 }, { row: 7, col: 2 }, { row: 7, col: 3 },
                    { row: 6, col: 4 }, { row: 5, col: 5 }, { row: 4, col: 6 }, { row: 3, col: 7 },
                    { row: 3, col: 8 }, { row: 3, col: 9 }, { row: 4, col: 10 }, { row: 5, col: 11 },
                    { row: 6, col: 12 }, { row: 7, col: 13 }, { row: 8, col: 14 }, { row: 9, col: 15 },
                    { row: 10, col: 16 }, { row: 11, col: 17 }, { row: 11, col: 18 }, { row: 11, col: 19 }
                ];

                // Mark path cells
                this.path.forEach((pos, index) => {
                    if (this.gameGrid[pos.row] && this.gameGrid[pos.row][pos.col]) {
                        if (index === 0) {
                            this.gameGrid[pos.row][pos.col].type = 'spawn';
                        } else if (index === this.path.length - 1) {
                            this.gameGrid[pos.row][pos.col].type = 'goal';
                        } else {
                            this.gameGrid[pos.row][pos.col].type = 'path';
                        }
                    }
                });
            }

            renderPath() {
                this.path.forEach((pos, index) => {
                    const cell = this.gameGrid[pos.row][pos.col].element;
                    if (index === 0) {
                        cell.className = 'grid-cell spawn';
                    } else if (index === this.path.length - 1) {
                        cell.className = 'grid-cell goal';
                    } else {
                        cell.className = 'grid-cell path';
                    }
                });
            }

            setupGameListeners() {
                const roomRef = ref(database, `rooms/${this.roomCode}`);
                onValue(roomRef, (snapshot) => {
                    if (snapshot.exists()) {
                        this.gameState = snapshot.val();
                        this.updateGameDisplay();
                    }
                });
            }

            setupDisconnectCleanup() {
                const playerRef = ref(database, `rooms/${this.roomCode}/players/${this.playerId}`);
                onDisconnect(playerRef).remove();
            }

            selectTowerType(type) {
                // Clear previous selection
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.style.transform = '';
                    btn.style.boxShadow = '';
                });

                if (this.selectedTowerType === type) {
                    this.selectedTowerType = null;
                    this.hideRangeIndicator();
                } else {
                    this.selectedTowerType = type;
                    const btn = document.getElementById(type + 'TowerBtn');
                    btn.style.transform = 'scale(1.1)';
                    btn.style.boxShadow = '0 0 20px rgba(0, 245, 255, 0.5)';
                }
            }

            handleClick(e) {
                const cell = e.target.closest('.grid-cell');
                if (!cell || !this.selectedTowerType) return;

                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const cellData = this.gameGrid[row][col];

                if (cellData.type === 'empty') {
                    this.placeTower(row, col, this.selectedTowerType);
                }
            }

            handleKeyDown(e) {
                if (e.key === 'Escape') {
                    this.selectedTowerType = null;
                    this.hideRangeIndicator();
                    document.querySelectorAll('.tower-btn').forEach(btn => {
                        btn.style.transform = '';
                        btn.style.boxShadow = '';
                    });
                } else if (e.key >= '1' && e.key <= '4') {
                    const types = ['basic', 'sniper', 'splash', 'slow'];
                    this.selectTowerType(types[parseInt(e.key) - 1]);
                }
            }

            async placeTower(row, col, type) {
                const tower = this.towerTypes[type];
                if (this.gold < tower.cost) {
                    this.showNotification('‚ùå Not enough gold!');
                    return;
                }

                const towerId = 'tower_' + this.playerId + '_' + Date.now();
                const towerData = {
                    id: towerId,
                    type: type,
                    row: row,
                    col: col,
                    owner: this.playerId,
                    lastFired: 0,
                    ...tower
                };

                this.towers.set(towerId, towerData);
                this.gold -= tower.cost;

                // Update visual
                this.gameGrid[row][col].type = 'occupied';
                this.gameGrid[row][col].element.className = 'grid-cell occupied';
                this.renderTower(towerData);

                // Update database
                await this.updatePlayerStats();
                this.updateGameDisplay();

                this.showNotification(`üèóÔ∏è ${type.charAt(0).toUpperCase() + type.slice(1)} tower placed!`);
            }

            renderTower(tower) {
                const towerElement = document.createElement('div');
                towerElement.className = `tower ${tower.type}`;
                towerElement.dataset.id = tower.id;
                towerElement.textContent = tower.icon;

                const cellRect = tower.row * (this.gameField.clientHeight / 15);
                const cellWidth = this.gameField.clientWidth / 20;
                const cellHeight = this.gameField.clientHeight / 15;

                towerElement.style.left = (tower.col * cellWidth + cellWidth / 2 - 15) + 'px';
                towerElement.style.top = (tower.row * cellHeight + cellHeight / 2 - 15) + 'px';

                towerElement.addEventListener('mouseenter', () => this.showRangeIndicator(tower));
                towerElement.addEventListener('mouseleave', () => this.hideRangeIndicator());

                this.gameField.appendChild(towerElement);
            }

            showRangeIndicator(tower) {
                this.hideRangeIndicator();

                const indicator = document.createElement('div');
                indicator.className = 'range-indicator';
                indicator.id = 'rangeIndicator';

                const cellWidth = this.gameField.clientWidth / 20;
                const cellHeight = this.gameField.clientHeight / 15;

                const centerX = tower.col * cellWidth + cellWidth / 2;
                const centerY = tower.row * cellHeight + cellHeight / 2;

                indicator.style.left = (centerX - tower.range) + 'px';
                indicator.style.top = (centerY - tower.range) + 'px';
                indicator.style.width = (tower.range * 2) + 'px';
                indicator.style.height = (tower.range * 2) + 'px';

                this.gameField.appendChild(indicator);
            }

            hideRangeIndicator() {
                const indicator = document.getElementById('rangeIndicator');
                if (indicator) {
                    indicator.remove();
                }
            }

            async startWave() {
                if (this.isWaveActive) return;

                this.isWaveActive = true;
                this.enemiesInWave = Math.min(5 + this.wave * 2, 30);
                this.enemiesSpawned = 0;
                this.startWaveBtn.disabled = true;
                this.startWaveBtn.textContent = 'Wave Active';

                this.showNotification(`üåä Wave ${this.wave} starting! ${this.enemiesInWave} enemies incoming!`);

                // Spawn enemies with delay
                const spawnInterval = setInterval(() => {
                    if (this.enemiesSpawned >= this.enemiesInWave) {
                        clearInterval(spawnInterval);
                        return;
                    }

                    this.spawnEnemy();
                    this.enemiesSpawned++;
                }, 1000);
            }

            spawnEnemy() {
                const enemyTypes = Object.keys(this.enemyTypes);
                let enemyType;

                // Different enemy types based on wave
                if (this.wave < 3) {
                    enemyType = 'basic';
                } else if (this.wave < 6) {
                    enemyType = Math.random() < 0.7 ? 'basic' : 'fast';
                } else if (this.wave < 10) {
                    const rand = Math.random();
                    if (rand < 0.5) enemyType = 'basic';
                    else if (rand < 0.8) enemyType = 'fast';
                    else enemyType = 'tank';
                } else {
                    const rand = Math.random();
                    if (rand < 0.3) enemyType = 'basic';
                    else if (rand < 0.6) enemyType = 'fast';
                    else if (rand < 0.9) enemyType = 'tank';
                    else enemyType = 'boss';
                }

                const enemyId = 'enemy_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                const enemyData = {
                    id: enemyId,
                    type: enemyType,
                    pathIndex: 0,
                    health: this.enemyTypes[enemyType].health * (1 + this.wave * 0.1), // Scale with wave
                    maxHealth: this.enemyTypes[enemyType].health * (1 + this.wave * 0.1),
                    speed: this.enemyTypes[enemyType].speed,
                    reward: this.enemyTypes[enemyType].reward,
                    icon: this.enemyTypes[enemyType].icon,
                    slowEffect: 1
                };

                this.enemies.set(enemyId, enemyData);
                this.renderEnemy(enemyData);
            }

            renderEnemy(enemy) {
                const enemyElement = document.createElement('div');
                enemyElement.className = `enemy ${enemy.type}`;
                enemyElement.dataset.id = enemy.id;
                enemyElement.textContent = enemy.icon;

                // Health bar
                const healthBar = document.createElement('div');
                healthBar.className = 'health-bar';
                const healthFill = document.createElement('div');
                healthFill.className = 'health-fill';
                healthFill.style.width = '100%';
                healthBar.appendChild(healthFill);
                enemyElement.appendChild(healthBar);

                this.gameField.appendChild(enemyElement);
                this.updateEnemyPosition(enemy);
            }

            updateEnemyPosition(enemy) {
                const enemyElement = document.querySelector(`[data-id="${enemy.id}"]`);
                if (!enemyElement || enemy.pathIndex >= this.path.length) return;

                const pos = this.path[enemy.pathIndex];
                const cellWidth = this.gameField.clientWidth / 20;
                const cellHeight = this.gameField.clientHeight / 15;

                const x = pos.col * cellWidth + cellWidth / 2 - 10;
                const y = pos.row * cellHeight + cellHeight / 2 - 10;

                enemyElement.style.left = x + 'px';
                enemyElement.style.top = y + 'px';

                // Update health bar
                const healthFill = enemyElement.querySelector('.health-fill');
                const healthPercent = (enemy.health / enemy.maxHealth) * 100;
                healthFill.style.width = healthPercent + '%';
            }

            moveEnemies() {
                for (const [enemyId, enemy] of this.enemies) {
                    enemy.pathIndex += enemy.speed * enemy.slowEffect * 0.05;

                    if (enemy.pathIndex >= this.path.length - 1) {
                        // Enemy reached the goal
                        this.lives--;
                        this.enemies.delete(enemyId);
                        const enemyElement = document.querySelector(`[data-id="${enemyId}"]`);
                        if (enemyElement) enemyElement.remove();

                        this.showNotification(`üíî Enemy reached base! Lives: ${this.lives}`);

                        if (this.lives <= 0) {
                            this.gameOver();
                        }
                    } else {
                        this.updateEnemyPosition(enemy);
                    }

                    // Reset slow effect
                    enemy.slowEffect = Math.min(1, enemy.slowEffect + 0.02);
                }
            }

            towerShooting() {
                const now = Date.now();

                for (const [towerId, tower] of this.towers) {
                    if (now - tower.lastFired < tower.fireRate) continue;

                    // Find nearest enemy in range
                    let target = null;
                    let nearestDistance = Infinity;

                    for (const [enemyId, enemy] of this.enemies) {
                        const enemyPos = this.path[Math.floor(enemy.pathIndex)];
                        if (!enemyPos) continue;

                        const cellWidth = this.gameField.clientWidth / 20;
                        const cellHeight = this.gameField.clientHeight / 15;

                        const towerX = tower.col * cellWidth + cellWidth / 2;
                        const towerY = tower.row * cellHeight + cellHeight / 2;
                        const enemyX = enemyPos.col * cellWidth + cellWidth / 2;
                        const enemyY = enemyPos.row * cellHeight + cellHeight / 2;

                        const distance = Math.sqrt((towerX - enemyX) ** 2 + (towerY - enemyY) ** 2);

                        if (distance <= tower.range && distance < nearestDistance) {
                            nearestDistance = distance;
                            target = enemy;
                        }
                    }

                    if (target) {
                        this.fireTower(tower, target);
                        tower.lastFired = now;
                    }
                }
            }

            fireTower(tower, enemy) {
                const cellWidth = this.gameField.clientWidth / 20;
                const cellHeight = this.gameField.clientHeight / 15;

                const towerX = tower.col * cellWidth + cellWidth / 2;
                const towerY = tower.row * cellHeight + cellHeight / 2;

                const enemyPos = this.path[Math.floor(enemy.pathIndex)];
                const enemyX = enemyPos.col * cellWidth + cellWidth / 2;
                const enemyY = enemyPos.row * cellHeight + cellHeight / 2;

                // Create projectile
                const projectileId = 'proj_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                const projectile = {
                    id: projectileId,
                    x: towerX,
                    y: towerY,
                    targetX: enemyX,
                    targetY: enemyY,
                    damage: tower.damage,
                    tower: tower,
                    target: enemy,
                    speed: 300
                };

                this.projectiles.set(projectileId, projectile);
                this.renderProjectile(projectile);
            }

            renderProjectile(projectile) {
                const projectileElement = document.createElement('div');
                projectileElement.className = 'projectile';
                projectileElement.dataset.id = projectile.id;
                projectileElement.style.left = projectile.x + 'px';
                projectileElement.style.top = projectile.y + 'px';

                this.gameField.appendChild(projectileElement);
            }

            moveProjectiles() {
                for (const [projectileId, projectile] of this.projectiles) {
                    const dx = projectile.targetX - projectile.x;
                    const dy = projectile.targetY - projectile.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 5) {
                        // Hit target
                        this.projectileHit(projectile);
                        this.projectiles.delete(projectileId);
                        const projectileElement = document.querySelector(`[data-id="${projectileId}"]`);
                        if (projectileElement) projectileElement.remove();
                    } else {
                        // Move towards target
                        const moveX = (dx / distance) * projectile.speed * 0.016;
                        const moveY = (dy / distance) * projectile.speed * 0.016;

                        projectile.x += moveX;
                        projectile.y += moveY;

                        const projectileElement = document.querySelector(`[data-id="${projectileId}"]`);
                        if (projectileElement) {
                            projectileElement.style.left = projectile.x + 'px';
                            projectileElement.style.top = projectile.y + 'px';
                        }
                    }
                }
            }

            projectileHit(projectile) {
                // Create explosion effect
                const explosion = document.createElement('div');
                explosion.className = 'explosion';
                explosion.style.left = (projectile.x - 20) + 'px';
                explosion.style.top = (projectile.y - 20) + 'px';
                this.gameField.appendChild(explosion);

                setTimeout(() => explosion.remove(), 500);

                // Apply damage
                if (projectile.tower.splash) {
                    // Splash damage
                    for (const [enemyId, enemy] of this.enemies) {
                        const enemyPos = this.path[Math.floor(enemy.pathIndex)];
                        if (!enemyPos) continue;

                        const cellWidth = this.gameField.clientWidth / 20;
                        const cellHeight = this.gameField.clientHeight / 15;
                        const enemyX = enemyPos.col * cellWidth + cellWidth / 2;
                        const enemyY = enemyPos.row * cellHeight + cellHeight / 2;

                        const distance = Math.sqrt((projectile.x - enemyX) ** 2 + (projectile.y - enemyY) ** 2);

                        if (distance <= projectile.tower.splash) {
                            this.damageEnemy(enemy, projectile.damage, projectile.tower);
                        }
                    }
                } else {
                    // Single target damage
                    if (this.enemies.has(projectile.target.id)) {
                        this.damageEnemy(projectile.target, projectile.damage, projectile.tower);
                    }
                }
            }

            damageEnemy(enemy, damage, tower) {
                enemy.health -= damage;

                // Apply slow effect
                if (tower.slow) {
                    enemy.slowEffect = tower.slow;
                }

                if (enemy.health <= 0) {
                    // Enemy killed
                    this.gold += enemy.reward;
                    this.enemies.delete(enemy.id);
                    const enemyElement = document.querySelector(`[data-id="${enemy.id}"]`);
                    if (enemyElement) enemyElement.remove();

                    this.showNotification(`üí∞ +$${enemy.reward}`);
                }
            }

            checkWaveCompletion() {
                if (this.isWaveActive && this.enemiesSpawned >= this.enemiesInWave && this.enemies.size === 0) {
                    // Wave completed
                    this.isWaveActive = false;
                    this.wave++;
                    this.gold += 20; // Wave completion bonus
                    this.startWaveBtn.disabled = false;
                    this.startWaveBtn.textContent = 'Start Wave';

                    this.showNotification(`üéâ Wave ${this.wave - 1} completed! +$20 bonus`);
                    this.nextWaveTimer = 30;
                }
            }

            startNextWaveTimer() {
                setInterval(() => {
                    if (!this.isWaveActive && this.nextWaveTimer > 0) {
                        this.nextWaveTimer--;
                        this.nextWaveTime.textContent = this.nextWaveTimer + 's';

                        if (this.nextWaveTimer === 0) {
                            this.startWave();
                            this.nextWaveTimer = 30;
                        }
                    }
                }, 1000);
            }

            startGameLoop() {
                const gameLoop = () => {
                    this.moveEnemies();
                    this.towerShooting();
                    this.moveProjectiles();
                    this.checkWaveCompletion();
                    this.updateUI();
                    requestAnimationFrame(gameLoop);
                };
                gameLoop();
            }

            updateUI() {
                this.playerGoldDisplay.textContent = this.gold;
                this.playerLivesDisplay.textContent = this.lives;
                this.currentWaveDisplay.textContent = this.wave;
                this.enemiesLeft.textContent = this.enemies.size;

                // Update wave progress
                if (this.isWaveActive && this.enemiesInWave > 0) {
                    const progress = ((this.enemiesInWave - this.enemies.size) / this.enemiesInWave) * 100;
                    this.waveFill.style.width = Math.max(0, progress) + '%';
                } else {
                    this.waveFill.style.width = '0%';
                }

                // Update tower button states
                Object.keys(this.towerTypes).forEach(type => {
                    const btn = document.getElementById(type + 'TowerBtn');
                    const tower = this.towerTypes[type];
                    btn.disabled = this.gold < tower.cost;
                });
            }

            updateGameDisplay() {
                // Sync with other players if needed
                if (this.gameState && this.gameState.players && this.gameState.players[this.playerId]) {
                    const playerData = this.gameState.players[this.playerId];
                    // Sync game state with server if needed
                }
            }

            async updatePlayerStats() {
                try {
                    const playerRef = ref(database, `rooms/${this.roomCode}/players/${this.playerId}`);
                    await set(playerRef, {
                        name: this.playerName,
                        gold: this.gold,
                        lives: this.lives,
                        wave: this.wave,
                        connected: true,
                        joinedAt: serverTimestamp()
                    });
                } catch (error) {
                    console.error('Failed to update player stats:', error);
                }
            }

            gameOver() {
                const gameOverDiv = document.createElement('div');
                gameOverDiv.className = 'game-over';
                gameOverDiv.innerHTML = `
                    <h1>GAME OVER</h1>
                    <p>You reached wave ${this.wave}</p>
                    <button class="btn btn-primary" onclick="location.reload()">Play Again</button>
                `;
                this.gameContainer.appendChild(gameOverDiv);
            }

            showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 2500);
            }

            showError(message) {
                this.nameError.textContent = message;
                this.nameError.style.display = 'block';
                setTimeout(() => {
                    this.nameError.style.display = 'none';
                }, 5000);
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            new TowerDefenseGame();
        });
    </script>
</body>
</html>